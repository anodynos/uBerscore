// Combined file generated by uRequire v0.3.0beta1, with help from r.js & almond
(function (){
  var __isAMD = (typeof define === 'function' && define.amd),
    __isNode = (typeof exports === 'object'),
    __isWeb = !__isNode;


  var __global = null,
      __nodeRequire = function(){};

  if (__isNode) {
      __nodeRequire = require;
      __global = global;
  } else {
      __global = window;
  };

  factory = function() {
/**
 * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("almond", function(){});

define('chai',[],function () {
  if (typeof chai !== 'undefined'){return chai;}return __nodeRequire('chai');
});
define('lodash',[],function () {
  if (typeof _ !== 'undefined'){return _;}return __nodeRequire('lodash');
});
define('uberscore',[],function () {
  if (typeof _B !== 'undefined'){return _B;}return __nodeRequire('uberscore');
});
(function (window) {
  define('spec-data',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', './spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var Class0, Class1, Class2, Class3, c3, data, earth, earth_laboratory_experiment, expectedPropertyValues, experiment, experiment_laboratory_earth, inheritedDeepClone, inheritedDeepCloneParent, inheritedShallowClone, inheritedShallowCloneParent, laboratory, laboratory_experiment, object, object1, object2, object3, objectDeepClone1, objectDeepClone2, objectShallowClone1, objectShallowClone2, objectWithProtoInheritedProps, prop1, _, _ref, _ref1, _ref2, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
    for (var key in parent) {
        if (__hasProp.call(parent, key)) child[key] = parent[key];
    }
    function ctor() {
        this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
};

_ = require("lodash");

prop1 = {
    "aProp1.1": "o1.aVal1.1",
    "aProp1.2": "o1.aVal1.2"
};

object1 = {
    aProp1: {},
    aProp2: "o1.aVal2"
};

object1.aProp1.__proto__ = prop1;

object2 = {
    aProp2: "o2.aVal2-1"
};

object2.__proto__ = object1;

object3 = {
    aProp2: "o3.aVal2-2",
    aProp3: [ 1, "2", 3, {
        aProp4: "o3.aVal3"
    } ]
};

object3.__proto__ = object2;

objectWithProtoInheritedProps = {
    aProp0: "o0.aVal0"
};

objectWithProtoInheritedProps.__proto__ = object3;

Class0 = function() {
    function Class0() {
        this.aProp0 = "o0.aVal0";
    }
    return Class0;
}();

Class1 = function(_super) {
    __extends(Class1, _super);
    function Class1() {
        _ref = Class1.__super__.constructor.apply(this, arguments);
        return _ref;
    }
    Class1.prototype.aProp1 = prop1;
    Class1.prototype.aProp2 = "o1.aVal2";
    return Class1;
}(Class0);

Class2 = function(_super) {
    __extends(Class2, _super);
    function Class2() {
        _ref1 = Class2.__super__.constructor.apply(this, arguments);
        return _ref1;
    }
    Class2.prototype.aProp2 = "o2.aVal2-1";
    return Class2;
}(Class1);

Class3 = function(_super) {
    __extends(Class3, _super);
    function Class3() {
        _ref2 = Class3.__super__.constructor.apply(this, arguments);
        return _ref2;
    }
    Class3.prototype.aProp2 = "o3.aVal2-2";
    Class3.prototype.aProp3 = [ 1, "2", 3, {
        aProp4: "o3.aVal3"
    } ];
    return Class3;
}(Class2);

c3 = new Class3;

expectedPropertyValues = {
    aProp0: "o0.aVal0",
    aProp1: {
        "aProp1.1": "o1.aVal1.1",
        "aProp1.2": "o1.aVal1.2"
    },
    aProp2: "o3.aVal2-2",
    aProp3: [ 1, "2", 3, {
        aProp4: "o3.aVal3"
    } ]
};

object = {
    p1: 1,
    p2: {
        p2_2: 3
    }
};

objectShallowClone1 = {
    p1: 1,
    p2: object.p2
};

objectShallowClone2 = _.clone(object);

objectDeepClone1 = {
    p1: 1,
    p2: {
        p2_2: 3
    }
};

objectDeepClone2 = _.clone(object, true);

inheritedShallowCloneParent = {
    p2: object.p2
};

inheritedShallowClone = {
    p1: 1
};

inheritedShallowClone.__proto__ = inheritedShallowCloneParent;

inheritedDeepCloneParent = {
    p2: {
        p2_2: 3
    }
};

inheritedDeepClone = {
    p1: 1
};

inheritedDeepClone.__proto__ = inheritedDeepCloneParent;

earth = {
    name: "earthDefaults",
    environment: {
        temperature: 20,
        gravity: 9.8,
        moisture: {
            min: 10
        }
    },
    life: true
};

laboratory = {
    name: "laboratoryDefaults",
    environment: {
        temperature: 35,
        moisture: {
            max: 40
        }
    },
    life: {
        races: [ "Caucasian", "African", "Asian" ],
        people: [ {
            name: "moe",
            age: 40
        }, {
            name: "larry",
            age: 50
        } ]
    }
};

experiment = {
    name: "experimentDefaults",
    environment: {
        gravity: 1.5,
        temperature: null
    },
    life: {
        races: [ "Kafkasian", "ApHriCan", "Azian", "Mutant" ],
        people: [ {
            name: "moe",
            age: 400
        }, {
            name: "blanka",
            age: 20
        }, {
            name: "ken",
            age: 25
        }, {
            name: "ryu",
            age: 28
        }, {
            name: "larry",
            age: 500
        } ]
    },
    results: {
        success: false
    }
};

earth_laboratory_experiment = {
    name: "earthDefaults",
    environment: {
        temperature: 20,
        gravity: 9.8,
        moisture: {
            min: 10,
            max: 40
        }
    },
    life: true,
    results: {
        success: false
    }
};

experiment_laboratory_earth = {
    name: "experimentDefaults",
    environment: {
        gravity: 1.5,
        temperature: 35,
        moisture: {
            max: 40,
            min: 10
        }
    },
    life: {
        races: [ "Kafkasian", "ApHriCan", "Azian", "Mutant" ],
        people: [ {
            name: "moe",
            age: 400
        }, {
            name: "blanka",
            age: 20
        }, {
            name: "ken",
            age: 25
        }, {
            name: "ryu",
            age: 28
        }, {
            name: "larry",
            age: 500
        } ]
    },
    results: {
        success: false
    }
};

laboratory_experiment = {
    name: "laboratoryDefaults",
    environment: {
        gravity: 1.5,
        temperature: 35,
        moisture: {
            max: 40
        }
    },
    life: {
        races: [ "Caucasian", "African", "Asian", "Mutant" ],
        people: [ {
            name: "moe",
            age: 40
        }, {
            name: "larry",
            age: 50
        }, {
            name: "ken",
            age: 25
        }, {
            name: "ryu",
            age: 28
        }, {
            name: "larry",
            age: 500
        } ]
    },
    results: {
        success: false
    }
};

data = {
    objectWithProtoInheritedProps: objectWithProtoInheritedProps,
    Class3: Class3,
    c3: c3,
    expectedPropertyValues: expectedPropertyValues,
    object: object,
    objectShallowClone1: objectShallowClone1,
    objectShallowClone2: objectShallowClone2,
    objectDeepClone1: objectDeepClone1,
    objectDeepClone2: objectDeepClone2,
    inheritedShallowClone: inheritedShallowClone,
    inheritedDeepClone: inheritedDeepClone,
    obj: {
        ciba: 4,
        aaa: 7,
        b: 2,
        c: -1
    },
    arrInt: [ 4, 7, 2, -1 ],
    arrInt2: [ 7, -1, 3, 5 ],
    arrStr: [ "Pikoulas", "Anodynos", "Babylon", "Agelos" ],
    earth: earth,
    laboratory: laboratory,
    experiment: experiment,
    earth_laboratory_experiment: earth_laboratory_experiment,
    experiment_laboratory_earth: experiment_laboratory_earth,
    laboratory_experiment: laboratory_experiment,
    team: {
        enabled: true,
        bundleRoot: "/team",
        compilers: {
            "rjs-build": "team-rjs"
        }
    },
    project: {
        bundleRoot: "/team/project",
        compilers: {
            "rjs-build": "project-rjs-build"
        }
    },
    bundle: {
        bundleRoot: "/team/project/bundle",
        compilers: {
            "coffee-script": {
                params: "w b"
            },
            urequire: {
                scanPrevent: true
            }
        }
    },
    bundle_project_team: {
        enabled: true,
        bundleRoot: "/team/project/bundle",
        compilers: {
            "coffee-script": {
                params: "w b"
            },
            urequire: {
                scanPrevent: true
            },
            "rjs-build": "project-rjs-build"
        }
    }
};

module.exports = data;
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('blending/Blender-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var assert, expect, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
    for (var key in parent) {
        if (__hasProp.call(parent, key)) child[key] = parent[key];
    }
    function ctor() {
        this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
}, __slice = [].slice;

assert = chai.assert;

expect = chai.expect;

describe("Blender:", function() {
    describe("Internals: blender.adjustBlenderBehavior:", function() {
        return describe("corectly transforms nested types of srcDstSpecs to short format", function() {
            it("works with simple 'src' and 'dst'", function() {
                var blender, expectedAdjustedBb, longTypeNamesBb;
                longTypeNamesBb = {
                    order: [ "src", "dst" ],
                    Array: {
                        String: "someAction"
                    },
                    Object: {
                        Array: "doSomeAction",
                        Null: function() {}
                    },
                    doSomeAction: function() {}
                };
                expectedAdjustedBb = {
                    order: [ "src", "dst" ],
                    doSomeAction: longTypeNamesBb.doSomeAction,
                    "[]": {
                        "''": "someAction"
                    },
                    "{}": {
                        "[]": "doSomeAction",
                        "null": longTypeNamesBb["Object"].Null
                    }
                };
                blender = new _B.Blender(longTypeNamesBb);
                return expect(_.isEqual(blender.blenderBehaviors[0], expectedAdjustedBb)).to.be["true"];
            });
            return it("works with bbOrder specs ['src', 'path', 'dst']", function() {
                var expectedAdjustededBb, longTypePathBb;
                longTypePathBb = {
                    order: [ "src", "path", "dst" ],
                    Function: function() {},
                    String: {
                        "bundle:dependencies:variableNames:*": {
                            basics: {
                                "|": {
                                    Object: function() {
                                        return "Iam a someObjectAction";
                                    },
                                    Array: "someArrayAction, found on a preceding blenderBehavior or blender",
                                    String: function(prop, src, dst, blender) {
                                        return B.Blender.SKIP;
                                    }
                                }
                            }
                        },
                        "bundle:dependencies:_knownVariableNames": {
                            String: {
                                Array: {
                                    Function: {
                                        "|": {
                                            Function: function() {
                                                return _B.Blender.SKIP;
                                            },
                                            Array: "someArrayAction"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    someAction: function() {}
                };
                expectedAdjustededBb = {
                    order: [ "src", "path", "dst" ],
                    "->": longTypePathBb.Function,
                    "''": {
                        bundle: {
                            dependencies: {
                                variableNames: {
                                    "*": {
                                        basics: {
                                            "|": {
                                                "{}": longTypePathBb["String"]["bundle:dependencies:variableNames:*"].basics["|"]["Object"],
                                                "[]": longTypePathBb["String"]["bundle:dependencies:variableNames:*"].basics["|"]["Array"],
                                                "''": longTypePathBb["String"]["bundle:dependencies:variableNames:*"].basics["|"]["String"]
                                            }
                                        }
                                    }
                                },
                                _knownVariableNames: {
                                    String: {
                                        Array: {
                                            Function: {
                                                "|": {
                                                    "->": longTypePathBb["String"]["bundle:dependencies:_knownVariableNames"].String.Array.Function["|"]["Function"],
                                                    "[]": "someArrayAction"
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    someAction: longTypePathBb.someAction
                };
                return expect((new _B.DeepCloneBlender(longTypePathBb)).blenderBehaviors[0]).to.deep.equal(expectedAdjustededBb);
            });
        });
    });
    describe("Handles primitives:", function() {
        var blender;
        blender = new _B.Blender;
        it("overwrites undefined / null:", function() {
            expect(blender.blend(void 0, 6, 18)).to.equal(18);
            expect(blender.blend(void 0, "a string")).to.equal("a string");
            expect(blender.blend(null, 16.7)).to.equal(16.7);
            expect(blender.blend(null, "a string")).to.equal("a string");
            return expect(blender.blend(void 0, 18, {
                prop: "someValue"
            })).to.deep.equal({
                prop: "someValue"
            });
        });
        return it("overwrites primitives", function() {
            expect(blender.blend(6, 18)).to.equal(18);
            expect(blender.blend("a string", 18, "another string")).to.equal("another string");
            return expect(blender.blend("a string", 18, {
                prop: "someValue"
            })).to.deep.equal({
                prop: "someValue"
            });
        });
    });
    describe("Options passing:", function() {
        it("deepCloneBlender.anOption is someOptions.anOption", function() {
            var deepCloneBlender, someOptions;
            someOptions = {
                anOption: function() {
                    return "I am a function";
                }
            };
            deepCloneBlender = new _B.DeepCloneBlender([], someOptions);
            return expect(deepCloneBlender.anOption).to.equal(someOptions.anOption);
        });
        it("real options: ", function() {
            var deepCloneBlender, myCopyProto, myInherited;
            deepCloneBlender = new _B.DeepCloneBlender;
            expect(deepCloneBlender.inherited).to.be["false"];
            expect(deepCloneBlender.copyProto).to.be["false"];
            myCopyProto = function() {};
            myInherited = function() {};
            deepCloneBlender = new _B.DeepCloneBlender([], {
                inherited: myInherited,
                copyProto: myCopyProto
            });
            expect(deepCloneBlender.inherited).to.equal(myInherited);
            return expect(deepCloneBlender.copyProto).to.equal(myCopyProto);
        });
        return describe("Options go up the inheritance:", function() {
            var SomeBlender, SomeOtherBlender;
            SomeBlender = function(_super) {
                __extends(SomeBlender, _super);
                function SomeBlender() {
                    var blenderBehaviors;
                    blenderBehaviors = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    this.blenderBehaviors = blenderBehaviors;
                    (this._optionsList || (this._optionsList = [])).unshift({
                        someOption: "someOptionValue"
                    });
                    SomeBlender.__super__.constructor.apply(this, arguments);
                }
                return SomeBlender;
            }(_B.Blender);
            SomeOtherBlender = function(_super) {
                __extends(SomeOtherBlender, _super);
                function SomeOtherBlender() {
                    var blenderBehaviors;
                    blenderBehaviors = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                    this.blenderBehaviors = blenderBehaviors;
                    (this._optionsList || (this._optionsList = [])).unshift({
                        someOtherOption: "someOtherOptionValue",
                        someOption: "someOptionValue of SomeOtherBlender"
                    });
                    SomeOtherBlender.__super__.constructor.apply(this, arguments);
                }
                return SomeOtherBlender;
            }(_B.Blender);
            it("respecting subclassed options #1", function() {
                var someBlender;
                someBlender = new SomeBlender;
                expect(someBlender.someOption).to.equal("someOptionValue");
                someBlender = new SomeBlender([], {
                    someOption: "someRedefinedOptionValue"
                });
                return expect(someBlender.someOption).to.equal("someRedefinedOptionValue");
            });
            return it("respecting subclassed options #2", function() {
                var someOtherBlender;
                someOtherBlender = new SomeOtherBlender;
                expect(someOtherBlender.someOption).to.equal("someOptionValue of SomeOtherBlender");
                someOtherBlender = new SomeOtherBlender([], {
                    someOption: "someRedefinedOptionValue"
                });
                expect(someOtherBlender.someOption).to.equal("someRedefinedOptionValue");
                return expect(someOtherBlender.someOtherOption).to.equal === "someOtherOptionValue";
            });
        });
    });
    return describe("Blender behaviors:", function() {
        describe("Simple examples:", function() {
            var o1, o2;
            o1 = {
                p1: 5,
                p2: {
                    p21: "A String",
                    p22: [ 5, 6, "String in array" ]
                },
                p3: "Some string"
            };
            o2 = {
                p1: 10,
                p2: {
                    p21: "Another String",
                    p22: [ 20, 40 ]
                }
            };
            it("Numbers dont just overwrite each other: the source is doubled and then added up to destination", function() {
                var deepCloneBlenderAddingNumbers;
                deepCloneBlenderAddingNumbers = new _B.DeepCloneBlender({
                    Number: {
                        Number: function(prop, src, dst) {
                            return dst[prop] + src[prop] * 2;
                        }
                    }
                });
                return expect(deepCloneBlenderAddingNumbers.blend({}, o1, o2)).to.deep.equal({
                    p1: 25,
                    p2: {
                        p21: "Another String",
                        p22: [ 45, 86, "String in array" ]
                    },
                    p3: "Some string"
                });
            });
            it("src Array items dont just overwrite the destination Array ones: they are doubled (if numbers) & then pushed to dst.", function() {
                var deepCloneBlenderAddingNumbers;
                deepCloneBlenderAddingNumbers = new _B.DeepCloneBlender({
                    Array: {
                        Array: function(prop, src, dst, bldr) {
                            var item, _i, _len, _ref;
                            _ref = src[prop];
                            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                                item = _ref[_i];
                                item = bldr.blend({}, {
                                    hack: item
                                }).hack;
                                dst[prop].push(_.isNumber(item) ? item * 2 : item);
                            }
                            return _B.Blender.SKIP;
                        }
                    }
                });
                return expect(deepCloneBlenderAddingNumbers.blend({}, o1, o2)).to.deep.equal({
                    p1: 10,
                    p2: {
                        p21: "Another String",
                        p22: [ 5, 6, "String in array", 40, 80 ]
                    },
                    p3: "Some string"
                });
            });
            return it("filters objects - Strings are banned:", function() {
                var deepCloneBlenderOmmitingStrings, result;
                deepCloneBlenderOmmitingStrings = new _B.DeepCloneBlender({
                    order: [ "src" ],
                    String: function(prop, src, dst, bldr) {
                        return _B.Blender.SKIP;
                    }
                });
                return result = expect(deepCloneBlenderOmmitingStrings.blend({}, o1, o2)).to.deep.equal({
                    p1: 10,
                    p2: {
                        p22: [ 20, 40 ]
                    }
                });
            });
        });
        return describe("Advanced examples:", function() {
            var o1, o2;
            o1 = {
                p1: 5,
                p2: {
                    p21: function(num) {
                        return num * 4;
                    },
                    p22: [ 5, "String" ]
                },
                p3: "Some string"
            };
            o2 = {
                p1: 10,
                p2: {
                    p21: 128,
                    p22: [ 20, 40 ]
                }
            };
            return describe("Chained BlenderBehaviors & Subclassed Blenders (are the same stuff): ", function() {
                var FunctionOverWriterBlender, UselessBlender, WeirdBlender, addingNumbersAndConcatEmToStringBlender, bi, blender, funcOverwrite, weirdBB, weirdBlender, _i, _len, _ref, _ref1, _results;
                addingNumbersAndConcatEmToStringBlender = new _B.DeepCloneBlender(funcOverwrite = {
                    Function: "overwrite"
                }, weirdBB = {
                    order: [ "dst", "src" ],
                    Function: {
                        Number: function(prop, src, dst) {
                            return dst[prop](src[prop]);
                        }
                    },
                    Number: {
                        Number: function(prop, src, dst) {
                            return dst[prop] + src[prop] * 2;
                        },
                        String: function(prop, src, dst) {
                            return dst[prop] + "--got a String-->:" + src[prop];
                        }
                    },
                    String: {
                        Number: function(prop, src, dst) {
                            return dst[prop] + "--got a Numba * 3-->:" + src[prop] * 3;
                        }
                    }
                });
                FunctionOverWriterBlender = function(_super) {
                    __extends(FunctionOverWriterBlender, _super);
                    function FunctionOverWriterBlender() {
                        var blenderBehaviors;
                        blenderBehaviors = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                        this.blenderBehaviors = blenderBehaviors;
                        (this.defaultBlenderBehaviors || (this.defaultBlenderBehaviors = [])).push(funcOverwrite);
                        FunctionOverWriterBlender.__super__.constructor.apply(this, arguments);
                    }
                    return FunctionOverWriterBlender;
                }(_B.DeepCloneBlender);
                UselessBlender = function(_super) {
                    __extends(UselessBlender, _super);
                    function UselessBlender() {
                        _ref = UselessBlender.__super__.constructor.apply(this, arguments);
                        return _ref;
                    }
                    return UselessBlender;
                }(FunctionOverWriterBlender);
                WeirdBlender = function(_super) {
                    __extends(WeirdBlender, _super);
                    function WeirdBlender() {
                        var blenderBehaviors;
                        blenderBehaviors = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                        this.blenderBehaviors = blenderBehaviors;
                        (this.defaultBlenderBehaviors || (this.defaultBlenderBehaviors = [])).push(weirdBB);
                        WeirdBlender.__super__.constructor.apply(this, arguments);
                    }
                    return WeirdBlender;
                }(UselessBlender);
                weirdBlender = new WeirdBlender;
                _ref1 = [ addingNumbersAndConcatEmToStringBlender, weirdBlender ];
                _results = [];
                for (bi = _i = 0, _len = _ref1.length; _i < _len; bi = ++_i) {
                    blender = _ref1[bi];
                    it("works {}<--o1<--o2 with blender #" + bi, function() {
                        return expect(blender.blend({}, o1, o2)).to.deep.equal({
                            p1: 25,
                            p2: {
                                p21: 128 * 4,
                                p22: [ 45, "String--got a Numba * 3-->:120" ]
                            },
                            p3: "Some string"
                        });
                    });
                    _results.push(it("works {}<--o2<--o1 with blender #" + bi, function() {
                        var result;
                        return result = expect(blender.blend({}, o2, o1)).to.deep.equal({
                            p1: 20,
                            p2: {
                                p21: o1.p2.p21,
                                p22: [ 30, "40--got a String-->:String" ]
                            },
                            p3: "Some string"
                        });
                    }));
                }
                return _results;
            });
        });
    });
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('blending/shared/deepExtendExamples-specs',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../../spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var arrInt, arrInt2, arrStr, assert, bundle, expect, global, obj, project, _ref;

assert = chai.assert;

expect = chai.expect;

_ref = _.clone(data, true), project = _ref.project, global = _ref.global, bundle = _ref.bundle, obj = _ref.obj, arrInt = _ref.arrInt, arrInt2 = _ref.arrInt2, arrStr = _ref.arrStr;

module.exports = function(deepExtendMergeBlend) {
    describe("deepExtend source code examples : ", function() {
        it("replaceRE allows you to concatenate strings.", function() {
            return expect(deepExtendMergeBlend({
                url: "www.example.com"
            }, {
                url: "http://${_}/path/to/file.html"
            })).to.deep.equal({
                url: "http://www.example.com/path/to/file.html"
            });
        });
        it("replaceRE also acts as a placeholder, which can be useful when you need to change one value in an array,\nwhile leaving the others untouched.", function() {
            return expect(deepExtendMergeBlend([ 100, {
                id: 1234
            }, true, "foo", [ 250, 500 ] ], [ "${_}", "${_}", false, "${_}", "${_}" ])).to.deep.equal([ 100, {
                id: 1234
            }, false, "foo", [ 250, 500 ] ]);
        });
        it("replaceRE also acts as a placeholder, #2 ", function() {
            return expect(deepExtendMergeBlend([ 100, {
                id: 1234
            }, true, "foo", [ 250, 500 ] ], [ "${_}", {}, false, "${_}", [] ])).to.deep.equal([ 100, {
                id: 1234
            }, false, "foo", [ 250, 500 ] ]);
        });
        it("replaceRE also acts as a placeholder, #3", function() {
            return expect(deepExtendMergeBlend([ 100, {
                id: 1234
            }, true, "foo", [ 250, 500 ] ], [ "${_}", {}, false ])).to.deep.equal([ 100, {
                id: 1234
            }, false, "foo", [ 250, 500 ] ]);
        });
        it("Array order is important.", function() {
            return expect(deepExtendMergeBlend([ 1, 2, 3, 4 ], [ 1, 4, 3, 2 ])).to.deep.equal([ 1, 4, 3, 2 ]);
        });
        return it("Remove Array element in destination object, by setting same index to null in a source object.", function() {
            return expect(deepExtendMergeBlend({
                arr: [ 1, 2, 3, 4 ]
            }, {
                arr: [ "${_}", null, void 0 ]
            })).to.deep.equal({
                arr: [ 1, 4 ]
            });
        });
    });
    return describe("more deepExtend examples: ", function() {
        return it("Remove Object key in destination object, by setting same key to undefined in a source object, similar to null in Array!", function() {
            return expect(deepExtendMergeBlend({
                foo: "foo",
                bar: {
                    name: "bar",
                    price: 20
                }
            }, {
                foo: void 0,
                bar: {
                    price: null
                }
            })).to.deep.equal({
                bar: {
                    name: "bar"
                }
            });
        });
    });
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('blending/shared/lodashMerge-specs',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../../spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var arrInt, arrInt2, arrStr, assert, bundle, expect, global, obj, project, _ref;

assert = chai.assert;

expect = chai.expect;

_ref = _.clone(data, true), project = _ref.project, global = _ref.global, bundle = _ref.bundle, obj = _ref.obj, arrInt = _ref.arrInt, arrInt2 = _ref.arrInt2, arrStr = _ref.arrStr;

module.exports = function(deepExtendMergeBlend) {
    return describe("lodash.merge specs", function() {
        it("should merge `source` into the destination object", function() {
            var ages, expected, heights, names;
            names = {
                stooges: [ {
                    name: "moe"
                }, {
                    name: "larry"
                } ]
            };
            ages = {
                stooges: [ {
                    age: 40
                }, {
                    age: 50
                } ]
            };
            heights = {
                stooges: [ {
                    height: "5'4\""
                }, {
                    height: "5'5\""
                } ]
            };
            expected = {
                stooges: [ {
                    name: "moe",
                    age: 40,
                    height: "5'4\""
                }, {
                    name: "larry",
                    age: 50,
                    height: "5'5\""
                } ]
            };
            return expect(deepExtendMergeBlend(names, ages, heights)).to.deep.equal(expected);
        });
        it("should merge sources containing circular references", function() {
            var actual, object, source;
            object = {
                foo: {
                    a: 1
                },
                bar: {
                    a: 2
                }
            };
            source = {
                foo: {
                    b: {
                        foo: {
                            c: {}
                        }
                    }
                },
                bar: {}
            };
            source.foo.b.foo.c = source;
            source.bar.b = source.foo.b;
            actual = deepExtendMergeBlend(object, source);
            return expect(actual.bar.b === actual.foo.b && actual.foo.b.foo.c === actual.foo.b.foo.c.foo.b.foo.c).to.be["true"];
        });
        return it("should merge problem JScript properties (test in IE < 9)", function() {
            var blended, object, source;
            object = {
                constructor: 1,
                hasOwnProperty: 2,
                isPrototypeOf: 3
            };
            source = {
                propertyIsEnumerable: 4,
                toLocaleString: 5,
                toString: 6,
                valueOf: 7
            };
            blended = deepExtendMergeBlend(object, source);
            return expect(blended).to.deep.equal({
                constructor: 1,
                hasOwnProperty: 2,
                isPrototypeOf: 3,
                propertyIsEnumerable: 4,
                toLocaleString: 5,
                toString: 6,
                valueOf: 7
            });
        });
    });
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('blending/deepExtend-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../spec-data', './shared/deepExtendExamples-specs', './shared/lodashMerge-specs'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var assert, expect;

assert = chai.assert;

expect = chai.expect;

describe("deepExtend :", function() {
    require("./shared/deepExtendExamples-specs")(_B.deepExtend);
    return require("./shared/lodashMerge-specs")(_B.deepExtend);
});

describe("DeepExtendBlender", function() {
    var deepExtendblender;
    deepExtendblender = new _B.DeepExtendBlender;
    return require("./shared/deepExtendExamples-specs")(deepExtendblender.blend);
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('blending/shared/lodashMerge_Blender-specs',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../../spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var arrInt, arrInt2, arrStr, assert, bundle, expect, global, obj, personDetails, personDetails2, persons, project, _ref;

assert = chai.assert;

expect = chai.expect;

_ref = _.clone(data, true), project = _ref.project, global = _ref.global, bundle = _ref.bundle, obj = _ref.obj, arrInt = _ref.arrInt, arrInt2 = _ref.arrInt2, arrStr = _ref.arrStr;

persons = [ {
    name: "agelos",
    male: true
}, {
    name: "AnoDyNoS"
} ];

personDetails = [ {
    age: 37,
    address: "1 Peak Str, Earth",
    familyState: null
}, {
    age: 33,
    familyState: {
        married: false
    }
} ];

personDetails2 = [ {
    surname: "Peakoulas",
    name: "Agelos",
    age: void 0,
    address: {
        street: "1 Peak Str",
        country: "Earth"
    },
    familyState: {
        married: true,
        children: 3
    }
}, {
    job: "Dreamer, developer, doer"
} ];

module.exports = function(deepExtendMergeBlend) {
    return describe("lodashMerge_Blender-specs (shared): ", function() {
        var blended;
        blended = deepExtendMergeBlend(persons, personDetails, personDetails2);
        it("'Persons' are deeply extended, overwriting from right to left.", function() {
            return expect(blended).to.deep.equal([ {
                surname: "Peakoulas",
                name: "Agelos",
                age: 37,
                male: true,
                address: {
                    street: "1 Peak Str",
                    country: "Earth"
                },
                familyState: {
                    married: true,
                    children: 3
                }
            }, {
                name: "AnoDyNoS",
                age: 33,
                job: "Dreamer, developer, doer",
                familyState: {
                    married: false
                }
            } ]);
        });
        it("'Persons' === the destination/target/extended object: ", function() {
            return expect(blended).to.equal(persons);
        });
        it("merges/blends 'Object <-- Array", function() {
            var result;
            result = deepExtendMergeBlend({
                property: "I am an Object"
            }, [ "I am", "an", "Array" ]);
            return expect(result).to.deep.equal({
                property: "I am an Object",
                0: "I am",
                1: "an",
                2: "Array"
            });
        });
        it("Array <-- Object", function() {
            var expected, result;
            result = deepExtendMergeBlend([ "I am", "an", "Array" ], {
                property: "I am an Object"
            });
            expected = [ "I am", "an", "Array" ];
            expected.property = "I am an Object";
            return expect(result).to.deep.equal(expected);
        });
        it("'Undefined' as source is ignored", function() {
            var result;
            result = deepExtendMergeBlend([ "I am", "an", {
                objProp: "Object property",
                anotherProp: "Another Object Property"
            } ], [ void 0, "another", {
                objProp: "Object Property2",
                anotherProp: void 0
            } ], [ "You are", void 0, {
                objProp: void 0
            } ]);
            return expect(result).to.deep.equal([ "You are", "another", {
                objProp: "Object Property2",
                anotherProp: "Another Object Property"
            } ]);
        });
        it("'Null' as source IS NOT ignored, it overwrites", function() {
            var result;
            result = deepExtendMergeBlend([ "I am", "an", {
                objProp: "Object property",
                anotherProp: "Another Object Property"
            } ], [ null, void 0, {
                objProp: "Object property",
                anotherProp: null
            } ]);
            return expect(result).to.deep.equal([ null, "an", {
                objProp: "Object property",
                anotherProp: null
            } ]);
        });
        return it("Null / Undefined as overwritten destination", function() {
            var result;
            result = deepExtendMergeBlend([ null, void 0, null, {
                objProp: "Undefined doesn't hurt me!",
                anotherProp: "null kills me!"
            } ], [ 111, null, void 0, void 0 ], [ null, "I am", "an", {
                objProp: void 0,
                anotherProp: null
            } ]);
            return expect(result).to.deep.equal([ null, "I am", "an", {
                objProp: "Undefined doesn't hurt me!",
                anotherProp: null
            } ]);
        });
    });
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('blending/lodash-merge-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../spec-data', './shared/lodashMerge-specs', './shared/lodashMerge_Blender-specs'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var assert, expect;

assert = chai.assert;

expect = chai.expect;

describe("lodash's `merge` :", function() {
    require("./shared/lodashMerge-specs")(_.merge);
    return require("./shared/lodashMerge_Blender-specs")(_.merge);
});

describe("lodash.merge-like blender", function() {
    var lodashMerge_like_blender;
    lodashMerge_like_blender = new _B.Blender({
        order: [ "src" ],
        Undefined: function() {
            return _B.Blender.SKIP;
        }
    });
    require("./shared/lodashMerge-specs")(lodashMerge_like_blender.blend);
    return require("./shared/lodashMerge_Blender-specs")(lodashMerge_like_blender.blend);
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('blending/Mergers_Blender-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var Class3, assert, c3, expect, expectedPropertyValues, objectWithProtoInheritedProps;

assert = chai.assert;

expect = chai.expect;

objectWithProtoInheritedProps = data.objectWithProtoInheritedProps, Class3 = data.Class3, c3 = data.c3, expectedPropertyValues = data.expectedPropertyValues;

describe("Default 'Blender.blend'", function() {
    describe("Default settings: with inherited:false, copyProto:false", function() {
        var defaultBlender;
        defaultBlender = new _B.Blender;
        describe("clones POJSO Object (no inheritance)", function() {
            return describe("(shallowClone = defaultBlender.blend {}, expectedPropertyValues)", function() {
                var shallowClone;
                shallowClone = defaultBlender.blend(expectedPropertyValues);
                return describe("is a shallow clone and compared to source: ", function() {
                    it("is not RefDisjoint - (there is at least one common reference))", function() {
                        return expect(_B.isRefDisjoint(shallowClone, expectedPropertyValues, {
                            deep: true,
                            inherited: true
                        })).to.be["false"];
                    });
                    it("has common references of all nested objects", function() {
                        var cRefs, sRefs;
                        sRefs = _B.getRefs(expectedPropertyValues, {
                            deep: true,
                            inherited: true
                        });
                        cRefs = _B.getRefs(shallowClone, {
                            deep: true,
                            inherited: true
                        });
                        return expect(_B.isEqualArraySet(sRefs, cRefs)).to.be["true"];
                    });
                    it("has a nested object copied by reference", function() {
                        expect(shallowClone.aProp1 === expectedPropertyValues.aProp1);
                        return expect(shallowClone.aProp1).to.not.be.an("undefined");
                    });
                    it("_.isEqual true (soft equality, same values/JSON)", function() {
                        return expect(_.isEqual(shallowClone, expectedPropertyValues)).to.be["true"];
                    });
                    it("_B.isEqual true (soft equality, same values/JSON)", function() {
                        return expect(_B.isEqual(shallowClone, expectedPropertyValues)).to.be["true"];
                    });
                    return it("_B.isExact true (strict references equality)", function() {
                        return expect(_B.isExact(shallowClone, expectedPropertyValues)).to.be["true"];
                    });
                });
            });
        });
        return describe("clones objectWithProtoInheritedProps (with inheritance)", function() {
            return describe("(shallowClone = defaultBlender.blend {}, objectWithProtoInheritedProps)", function() {
                var shallowIncompleteClone;
                shallowIncompleteClone = defaultBlender.blend({}, objectWithProtoInheritedProps);
                return describe("is an incomplete shallow clone, not copied inherited props: ", function() {
                    it("has NOT common references of all nested objects", function() {
                        var cRefs, sRefs;
                        sRefs = _B.getRefs(objectWithProtoInheritedProps, {
                            deep: true,
                            inherited: true
                        });
                        cRefs = _B.getRefs(shallowIncompleteClone, {
                            deep: true,
                            inherited: true
                        });
                        return expect(_B.isDisjoint(sRefs, cRefs)).to.be["true"];
                    });
                    it("has NOT copied inherited nested object", function() {
                        return expect(shallowIncompleteClone.aProp1 === void 0).to.be["true"];
                    });
                    it("_.isEqual true (soft equality, same values/JSON)", function() {
                        return expect(_.isEqual(shallowIncompleteClone, objectWithProtoInheritedProps)).to.be["true"];
                    });
                    it("_B.isEqual true (soft equality, same values/JSON)", function() {
                        return expect(_B.isEqual(shallowIncompleteClone, objectWithProtoInheritedProps)).to.be["true"];
                    });
                    it("_B.isExact true (strict references equality, no inherited props)", function() {
                        return expect(_B.isExact(shallowIncompleteClone, objectWithProtoInheritedProps)).to.be["true"];
                    });
                    it("_B.isIqual false (inherited props, soft object equality)", function() {
                        return expect(!_B.isIqual(shallowIncompleteClone, objectWithProtoInheritedProps)).to.be["true"];
                    });
                    return it("_B.isIxact false (inherited props equality + strict references equality)", function() {
                        return expect(!_B.isIxact(shallowIncompleteClone, objectWithProtoInheritedProps)).to.be["true"];
                    });
                });
            });
        });
    });
    describe("Default 'Blender.blend' with inherited:true", function() {
        var defaultBlenderInheritedCopier;
        defaultBlenderInheritedCopier = new _B.Blender([], {
            inherited: true
        });
        return describe("clones objectWithProtoInheritedProps (with inheritance)", function() {
            return describe("(shallowCloneInheritedCopied = defaultBlenderInheritedCopier.blend {}, objectWithProtoInheritedProps)", function() {
                var shallowCloneInheritedCopied;
                shallowCloneInheritedCopied = defaultBlenderInheritedCopier.blend(objectWithProtoInheritedProps);
                return describe("is a complete shallow clone, having shallow copied all inherited props: ", function() {
                    it("has common references of all nested objects", function() {
                        var cRefs, sRefs;
                        sRefs = _B.getRefs(objectWithProtoInheritedProps, {
                            deep: true,
                            inherited: true
                        });
                        cRefs = _B.getRefs(shallowCloneInheritedCopied, {
                            deep: true,
                            inherited: true
                        });
                        return expect(_B.isEqualArraySet(sRefs, cRefs)).to.be["true"];
                    });
                    it("has copied inherited nested object", function() {
                        expect(shallowCloneInheritedCopied.aProp1).to.equal(objectWithProtoInheritedProps.aProp1);
                        return expect(shallowCloneInheritedCopied.aProp1).to.not.be.an("undefined");
                    });
                    it("_.isEqual is false (soft equality, not looking at inherited props of source)", function() {
                        return expect(_.isEqual(shallowCloneInheritedCopied, objectWithProtoInheritedProps)).to.be["false"];
                    });
                    it("_B.isEqual is false (soft equality, not looking at inherited props of source)", function() {
                        return expect(_B.isEqual(shallowCloneInheritedCopied, objectWithProtoInheritedProps)).to.be["false"];
                    });
                    it("_B.isExact is false (strict references equality, no inherited props of source)", function() {
                        return expect(_B.isExact(shallowCloneInheritedCopied, objectWithProtoInheritedProps)).to.be["false"];
                    });
                    it("_B.isIqual is true (inherited props, soft object equality)", function() {
                        return expect(_B.isIqual(shallowCloneInheritedCopied, objectWithProtoInheritedProps)).to.be["true"];
                    });
                    return it("_B.isIxact true (inherited props, strict references equality)", function() {
                        return expect(_B.isIxact(shallowCloneInheritedCopied, objectWithProtoInheritedProps)).to.be["true"];
                    });
                });
            });
        });
    });
    return describe("Default 'Blender.blend' with copyProto:true", function() {
        var defaultBlenderProtoCopier;
        defaultBlenderProtoCopier = new _B.Blender([], {
            copyProto: true
        });
        return describe("clones objectWithProtoInheritedProps (with inheritance)", function() {
            return describe("(shallowClone = defaultBlenderProtoCopier.blend {}, objectWithProtoInheritedProps)", function() {
                var shallowCloneProtoCopied;
                shallowCloneProtoCopied = defaultBlenderProtoCopier.blend({}, objectWithProtoInheritedProps);
                return describe("is a complete shallow clone, having shallow copied only own props & __proto__: ", function() {
                    it("has ALL common references of all nested objects", function() {
                        var cRefs, sRefs;
                        sRefs = _B.getRefs(objectWithProtoInheritedProps, {
                            deep: true,
                            inherited: true
                        });
                        cRefs = _B.getRefs(shallowCloneProtoCopied, {
                            deep: true,
                            inherited: true
                        });
                        return expect(_B.isEqualArraySet(sRefs, cRefs)).to.be["true"];
                    });
                    it("has not copied inherited nested object, but can access it through __proto__ inheritance", function() {
                        expect(shallowCloneProtoCopied.aProp1).to.equal(objectWithProtoInheritedProps.aProp1);
                        expect(shallowCloneProtoCopied.aProp1).to.not.be.an("undefined");
                        expect(objectWithProtoInheritedProps.hasOwnProperty("aProp1")).to.be["false"];
                        return expect(shallowCloneProtoCopied.hasOwnProperty("aProp1")).to.be["false"];
                    });
                    it("_.isEqual is true (soft equality, not looking at inherited props of either)", function() {
                        return expect(_.isEqual(shallowCloneProtoCopied, objectWithProtoInheritedProps)).to.be["true"];
                    });
                    it("_B.isEqual is true (soft equality, not looking at inherited props of either)", function() {
                        return expect(_B.isEqual(shallowCloneProtoCopied, objectWithProtoInheritedProps)).to.be["true"];
                    });
                    it("_B.isExact is true (strict references equality, no inherited props of either)", function() {
                        return expect(_B.isExact(shallowCloneProtoCopied, objectWithProtoInheritedProps)).to.be["true"];
                    });
                    it("_B.isIqual is true (inherited props, soft object equality)", function() {
                        return expect(_B.isIqual(shallowCloneProtoCopied, objectWithProtoInheritedProps)).to.be["true"];
                    });
                    return it("_B.isIxact true (inherited props, strict references equality)", function() {
                        return expect(_B.isIxact(shallowCloneProtoCopied, objectWithProtoInheritedProps)).to.be["true"];
                    });
                });
            });
        });
    });
});

describe("DeepCloneBlender .blend:", function() {
    describe("Default settings: with inherited:false, copyProto:false", function() {
        var deepCloneBlender;
        deepCloneBlender = new _B.DeepCloneBlender;
        describe("clones POJSO Object (no inheritance)", function() {
            return describe("(deepClone = deepCloneBlender.blend {}, expectedPropertyValues)", function() {
                var deepClone;
                deepClone = deepCloneBlender.blend(expectedPropertyValues);
                return describe("is a deep clone", function() {
                    it("_B.isDisjoint true, NO common references in objects", function() {
                        return expect(_B.isRefDisjoint(deepClone, expectedPropertyValues, {
                            deep: true,
                            inherited: true
                        })).to.be["true"];
                    });
                    it("nested object is a clone it self - NOT the same reference", function() {
                        return expect(deepClone.aProp1).to.not.equal(expectedPropertyValues.aProp1);
                    });
                    it("_.isEqual true (soft equality, same values/JSON)", function() {
                        return expect(_.isEqual(deepClone, expectedPropertyValues)).to.be["true"];
                    });
                    it("_B.isEqual true (soft equality, same values/JSON)", function() {
                        return expect(_B.isEqual(deepClone, expectedPropertyValues)).to.be["true"];
                    });
                    return it("_B.isExact is false (strict references equality)", function() {
                        return expect(_B.isExact(deepClone, expectedPropertyValues)).to.be["false"];
                    });
                });
            });
        });
        return describe("clones objectWithProtoInheritedProps (with inheritance)", function() {
            return describe("(deepIncompleteClone = deepCloneBlender.blend {}, objectWithProtoInheritedProps)", function() {
                var deepIncompleteClone;
                deepIncompleteClone = deepCloneBlender.blend({}, objectWithProtoInheritedProps);
                return describe("is an incomplete deep clone, not copied inherited props: ", function() {
                    it("_B.isDisjoint true, has NO common references of all nested objects", function() {
                        return expect(_B.isRefDisjoint(objectWithProtoInheritedProps, deepIncompleteClone, {
                            deep: true,
                            inherited: true
                        })).to.be["true"];
                    });
                    it("has NOT copied inherited nested object", function() {
                        return expect(deepIncompleteClone.aProp1).to.be.an("undefined");
                    });
                    describe("equality of deepIncompleteClone, objectWithProtoInheritedProps", function() {
                        it("_.isEqual true (soft equality, same values/JSON)", function() {
                            return expect(_.isEqual(deepIncompleteClone, objectWithProtoInheritedProps)).to.be["true"];
                        });
                        it("_B.isEqual true (soft equality, same values/JSON)", function() {
                            return expect(_B.isEqual(deepIncompleteClone, objectWithProtoInheritedProps)).to.be["true"];
                        });
                        it("_B.isIqual false (inherited props)", function() {
                            return expect(_B.isIqual(deepIncompleteClone, objectWithProtoInheritedProps)).to.be["false"];
                        });
                        it("_B.isExact true (strict references equality)", function() {
                            return expect(_B.isExact(deepIncompleteClone, objectWithProtoInheritedProps)).to.be["true"];
                        });
                        return it("_B.isIxact false (inherited props, scrict references equality)", function() {
                            return expect(_B.isIxact(deepIncompleteClone, objectWithProtoInheritedProps)).to.be["false"];
                        });
                    });
                    return describe("equality of deepInheritedClone, expectedPropertyValues", function() {
                        it("_.isEqual false (soft equality, same values/JSON)", function() {
                            return expect(_.isEqual(deepIncompleteClone, expectedPropertyValues)).to.be["false"];
                        });
                        it("_B.isEqual false (soft equality, same values/JSON)", function() {
                            return expect(_B.isEqual(deepIncompleteClone, expectedPropertyValues)).to.be["false"];
                        });
                        it("_B.isIqual false (inherited props)", function() {
                            return expect(_B.isIqual(deepIncompleteClone, expectedPropertyValues)).to.be["false"];
                        });
                        it("_B.isExact false (strict references equality)", function() {
                            return expect(_B.isExact(deepIncompleteClone, expectedPropertyValues)).to.be["false"];
                        });
                        return it("_B.isIxact false (inherited props, scrict references equality)", function() {
                            return expect(_B.isIxact(deepIncompleteClone, expectedPropertyValues)).to.be["false"];
                        });
                    });
                });
            });
        });
    });
    return describe("with inherited:true :", function() {
        var deepCloneInheritedBlender;
        deepCloneInheritedBlender = new _B.DeepCloneBlender([], {
            inherited: true
        });
        describe("clones objectWithProtoInheritedProps (with inheritance)", function() {
            return describe("(deepInheritedClone = deepCloneInheritedBlender .blend {}, objectWithProtoInheritedProps)", function() {
                var deepInheritedClone;
                deepInheritedClone = deepCloneInheritedBlender.blend({}, objectWithProtoInheritedProps);
                return describe("is a complete deep clone, having deep cloned all inherited props as its own: ", function() {
                    it("_B.isDisjoint true, has NO common references of all nested objects", function() {
                        return expect(_B.isRefDisjoint(objectWithProtoInheritedProps, deepInheritedClone, {
                            deep: true,
                            inherited: true
                        })).to.be["true"];
                    });
                    describe("equality of deepInheritedClone, objectWithProtoInheritedProps", function() {
                        it("_.isEqual false (soft equality, not looking at inherited props of either)", function() {
                            return expect(_.isEqual(deepInheritedClone, objectWithProtoInheritedProps)).to.be["false"];
                        });
                        it("_B.isEqual false (soft equality, not looking at inherited props of either)", function() {
                            return expect(_B.isEqual(deepInheritedClone, objectWithProtoInheritedProps)).to.be["false"];
                        });
                        it("_B.isIqual true (soft equality, inherited props)", function() {
                            return expect(_B.isIqual(deepInheritedClone, objectWithProtoInheritedProps)).to.be["true"];
                        });
                        it("_B.isExact false (strict references equality)", function() {
                            return expect(_B.isExact(deepInheritedClone, objectWithProtoInheritedProps)).to.be["false"];
                        });
                        return it("_B.isIxact false (inherited props, scrict references equality)", function() {
                            return expect(_B.isIxact(deepInheritedClone, objectWithProtoInheritedProps)).to.be["false"];
                        });
                    });
                    return describe("equality of deepInheritedClone, expectedPropertyValues", function() {
                        it("_.isEqual true (soft equality, all props are equal )", function() {
                            return expect(_.isEqual(deepInheritedClone, expectedPropertyValues)).to.be["true"];
                        });
                        it("_B.isEqual true (soft equality, all props are equal)", function() {
                            return expect(_B.isEqual(deepInheritedClone, expectedPropertyValues)).to.be["true"];
                        });
                        it("_B.isIqual true (soft equality, inherited props, all props are equal)", function() {
                            return expect(_B.isIqual(deepInheritedClone, expectedPropertyValues)).to.be["true"];
                        });
                        it("_B.isExact false (strict references equality)", function() {
                            return expect(_B.isExact(deepInheritedClone, expectedPropertyValues)).to.be["false"];
                        });
                        return it("_B.isIxact false (inherited props, scrict references equality)", function() {
                            return expect(_B.isIxact(deepInheritedClone, expectedPropertyValues)).to.be["false"];
                        });
                    });
                });
            });
        });
        return describe("Using ['path'] orders in BlenderBehavior:", function() {
            var bi, blender, blenders, expected, o1, o2, _i, _len, _results;
            blenders = [];
            blenders.push(new _B.DeepCloneBlender([ {
                order: [ "dst", "path", "src" ],
                String: {
                    bundle: {
                        basics: {
                            "|": {
                                String: function(prop, src, dst, blender) {
                                    return _B.Blender.SKIP;
                                }
                            }
                        }
                    }
                }
            } ], {
                isExactPath: false
            }));
            blenders.push(new _B.DeepCloneBlender([ {
                order: [ "path", "src", "dst" ],
                bundle: {
                    basics: {
                        "|": {
                            String: {
                                String: function(prop, src, dst, blender) {
                                    return _B.Blender.SKIP;
                                }
                            }
                        }
                    }
                }
            } ], {
                isExactPath: false
            }));
            blenders.push(new _B.DeepCloneBlender([ {
                order: [ "path", "src", "dst" ],
                "bundle : basics": {
                    "|": {
                        String: {
                            String: function(prop, src, dst, blender) {
                                return _B.Blender.SKIP;
                            }
                        }
                    }
                }
            } ], {
                isExactPath: false
            }));
            blenders.push(new _B.DeepCloneBlender([ {
                order: [ "src", "dst", "path" ],
                String: {
                    String: {
                        " bundle: basics": {
                            "|": function(prop, src, dst, blender) {
                                return _B.Blender.SKIP;
                            }
                        }
                    }
                }
            } ], {
                isExactPath: false
            }));
            blenders.push(new _B.DeepCloneBlender([ {
                order: [ "src", "dst", "path" ],
                String: {
                    String: {
                        bundle: {
                            basics: {
                                "|": function(prop, src, dst, blender) {
                                    return _B.Blender.SKIP;
                                }
                            }
                        }
                    }
                }
            } ], {
                isExactPath: false
            }));
            o1 = {
                bundle: {
                    someOkString: "OLD String#1",
                    someOkStrings: [ "OLD [String]#1", "OLD [String]#2" ],
                    basics: {
                        newString2: 665,
                        someObject: {
                            skippedString: "OLD string #2"
                        },
                        skippedString: "OLD string #3",
                        skippedStrings: [ "OLD [String]#3", "OLD [String]#4" ],
                        anIntAsString: "665",
                        anInt: 8
                    }
                }
            };
            o2 = {
                bundle: {
                    someOkString: "OVERWRITTEN String#1",
                    someOkStrings: [ "OVERWRITTEN [String]#1", "OVERWRITTEN [String]#2" ],
                    basics: {
                        newString: "I am a OVERWRITTEN String, but on `undefined <-- String`, so I am ok!",
                        newString2: "I am a OVERWRITTEN String, but on `Number <-- String`, so I am ok!",
                        someObject: {
                            skippedString: "SKIPed string #2"
                        },
                        skippedString: "SKIPed string #3",
                        skippedStrings: [ "SKIPed [String]#3", "SKIPed [String]#4" ],
                        anIntAsString: 77,
                        anInt: "18"
                    }
                }
            };
            expected = {
                bundle: {
                    someOkString: "OVERWRITTEN String#1",
                    someOkStrings: [ "OVERWRITTEN [String]#1", "OVERWRITTEN [String]#2" ],
                    basics: {
                        newString: "I am a OVERWRITTEN String, but on `undefined <-- String`, so I am ok!",
                        newString2: "I am a OVERWRITTEN String, but on `Number <-- String`, so I am ok!",
                        someObject: {
                            skippedString: "OLD string #2"
                        },
                        skippedString: "OLD string #3",
                        skippedStrings: [ "OLD [String]#3", "OLD [String]#4" ],
                        anIntAsString: 77,
                        anInt: "18"
                    }
                }
            };
            _results = [];
            for (bi = _i = 0, _len = blenders.length; _i < _len; bi = ++_i) {
                blender = blenders[bi];
                _results.push(it("_.isEqual is true for blender #" + bi, function() {
                    var result;
                    result = blender.blend({}, o1, o2);
                    return expect(_.isEqual(result, expected)).to.be["true"];
                }));
            }
            return _results;
        });
    });
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('blending/DeepDefaultsBlender-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var Class3, assert, bundle, bundle_project_team, c3, earth, earth_laboratory_experiment, expect, expectedPropertyValues, experiment, experiment_laboratory_earth, laboratory, laboratory_experiment, objectWithProtoInheritedProps, project, team;

assert = chai.assert;

expect = chai.expect;

objectWithProtoInheritedProps = data.objectWithProtoInheritedProps, Class3 = data.Class3, c3 = data.c3, expectedPropertyValues = data.expectedPropertyValues, project = data.project, team = data.team, bundle = data.bundle, bundle_project_team = data.bundle_project_team, earth = data.earth, laboratory = data.laboratory, experiment = data.experiment, earth_laboratory_experiment = data.earth_laboratory_experiment, experiment_laboratory_earth = data.experiment_laboratory_earth, laboratory_experiment = data.laboratory_experiment;

describe("Defaults: The DeepDefaultsBlender, overwritting only null/undefined & merging all nested types", function() {
    describe("Default settings:", function() {
        var deepDefaultsBlender;
        deepDefaultsBlender = new _B.DeepDefaultsBlender;
        describe("bundle, project, team", function() {
            var result;
            result = deepDefaultsBlender.blend({}, bundle, project, team);
            it("_.isEqual result, bundle_project_team", function() {
                return expect(_.isEqual(result, bundle_project_team)).to.be["true"];
            });
            return it("_.isRefDisjoint result with each of bundle, project, team", function() {
                var o, _i, _len, _ref, _results;
                _ref = [ bundle, project, team ];
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    o = _ref[_i];
                    _results.push(expect(_B.isRefDisjoint(result, o)).to.be["true"]);
                }
                return _results;
            });
        });
        describe("earth, laboratory, experiment", function() {
            var result;
            result = deepDefaultsBlender.blend({}, earth, laboratory, experiment);
            it("_.isEqual result, earth_laboratory_experiment", function() {
                return expect(_.isEqual(result, earth_laboratory_experiment)).to.be["true"];
            });
            return it("_.isRefDisjoint result with each of earth, laboratory, experiment", function() {
                var o, _i, _len, _ref, _results;
                _ref = [ bundle, project, team ];
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    o = _ref[_i];
                    _results.push(expect(_B.isRefDisjoint(result, o)).to.be["true"]);
                }
                return _results;
            });
        });
        describe("experiment, laboratory, earth", function() {
            var result;
            result = deepDefaultsBlender.blend({}, experiment, laboratory, earth);
            it("_.isEqual result, experiment_laboratory_earth", function() {
                return expect(_.isEqual(result, experiment_laboratory_earth)).to.be["true"];
            });
            return it("_.isRefDisjoint result with each of experiment, laboratory, earth", function() {
                var o, _i, _len, _ref, _results;
                _ref = [ experiment, laboratory, earth ];
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    o = _ref[_i];
                    _results.push(expect(_B.isRefDisjoint(result, o)).to.be["true"]);
                }
                return _results;
            });
        });
        return describe("laboratory, experiment", function() {
            var result;
            result = deepDefaultsBlender.blend({}, laboratory, experiment);
            it("_.isEqual result, laboratory_experiment", function() {
                return expect(_.isEqual(result, laboratory_experiment)).to.be["true"];
            });
            return it("_.isRefDisjoint result with each of laboratory, experiment", function() {
                var o, _i, _len, _ref, _results;
                _ref = [ laboratory, experiment ];
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    o = _ref[_i];
                    _results.push(expect(_B.isRefDisjoint(result, o)).to.be["true"]);
                }
                return _results;
            });
        });
    });
    return describe("Using path in BlenderBehavior.order: ", function() {
        var peopleUniqueBlender, result;
        peopleUniqueBlender = new _B.DeepDefaultsBlender({
            order: [ "src", "path" ],
            Array: {
                life: {
                    people: {
                        "|": function(prop, src, dst, blender) {
                            var foundPerson, person, _i, _len, _ref;
                            _ref = src[prop];
                            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                                person = _ref[_i];
                                if (!_.isArray(dst[prop])) {
                                    dst[prop] = [];
                                } else {
                                    foundPerson = _.find(dst[prop], function(v) {
                                        return v.name === person.name;
                                    });
                                }
                                if (!foundPerson) {
                                    dst[prop].push(person);
                                } else {
                                    _.extend(foundPerson, person);
                                }
                            }
                            return dst[prop];
                        }
                    }
                }
            }
        });
        result = peopleUniqueBlender.blend(laboratory, experiment);
        return it("_.isEqual result, laboratory_experiment", function() {
            return expect(_.isEqual(result, {
                name: "laboratoryDefaults",
                environment: {
                    temperature: 35,
                    moisture: {
                        max: 40
                    },
                    gravity: 1.5
                },
                life: {
                    races: [ "Caucasian", "African", "Asian", "Mutant" ],
                    people: [ {
                        name: "moe",
                        age: 400
                    }, {
                        name: "larry",
                        age: 500
                    }, {
                        name: "blanka",
                        age: 20
                    }, {
                        name: "ken",
                        age: 25
                    }, {
                        name: "ryu",
                        age: 28
                    } ]
                },
                results: {
                    success: false
                }
            })).to.be["true"];
        });
    });
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('objects/getInheritedPropertyNames-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var Class3, assert, expect, objectWithProtoInheritedProps;

assert = chai.assert;

expect = chai.expect;

objectWithProtoInheritedProps = data.objectWithProtoInheritedProps, Class3 = data.Class3;

describe("getInheritedPropertyNames: ", function() {
    it("reads property names of __proro__ linked object hierarchy", function() {
        var inheritedProps;
        inheritedProps = _B.getInheritedPropertyNames(objectWithProtoInheritedProps);
        return expect(_B.isEqualArraySet(inheritedProps, [ "aProp1", "aProp2", "aProp3" ])).to.be["true"];
    });
    return it("reads property names of coffeescript class-inherited objects", function() {
        return expect(_B.isEqualArraySet(_B.getInheritedPropertyNames(new Class3), [ "aProp3", "aProp2", "aProp1" ])).to.be["true"];
    });
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('objects/getRefs-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var assert, expect;

assert = chai.assert;

expect = chai.expect;

describe("getRefs:", function() {
    it("from array, deep = false", function() {
        var oa, refs;
        oa = [ 0, 1, {
            p: [ {
                PP: 3
            } ]
        }, {
            a: {
                b: function() {}
            }
        }, 4 ];
        refs = _B.getRefs(oa);
        return expect(_B.isEqualArraySet(refs, [ oa[3], oa[2] ])).to.be["true"];
    });
    it("from array, deep = true:", function() {
        var oa, refs;
        oa = [ 0, 1, {
            p: [ {
                PP: 3
            } ]
        }, {
            a: {
                b: function() {}
            }
        }, 4 ];
        refs = _B.getRefs(oa, {
            deep: true
        });
        return expect(_B.isEqualArraySet(refs, [ oa[2], oa[2].p, oa[2].p[0], oa[3], oa[3].a, oa[3].a.b ])).to.be["true"];
    });
    return it("from object, deep = true:", function() {
        var oa, refs;
        oa = {
            p0: 0,
            p1: 1,
            p2: {
                p: [ {
                    PP: 3
                } ]
            },
            p3: {
                a: {
                    b: function() {}
                }
            },
            p4: 4
        };
        refs = _B.getRefs(oa, {
            deep: true
        });
        return expect(_B.isEqualArraySet(refs, [ oa.p2.p, oa.p2.p[0], oa.p2, oa.p3, oa.p3.a, oa.p3.a.b ])).to.be["true"];
    });
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('objects/getValueAtPath-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var assert, expect;

assert = chai.assert;

expect = chai.expect;

describe("objects/getValueAtPath ", function() {
    var o;
    o = {
        $: {
            bundle: {
                anArray: [ "arrayItem1", 2, {
                    arrayItem3: 3
                } ],
                "*": {
                    IamA: "defaultValue"
                },
                dependencies: {
                    variableNames: "Bingo"
                },
                someOtherKey: {
                    "*": {
                        notReached: "defaultValue"
                    },
                    "#": {
                        IamA: {
                            Stop: "Value"
                        }
                    }
                },
                leadingToTerminate: {
                    "|": {
                        terminated: "terminated value"
                    },
                    someKey: {
                        someOtherKey: "someValue"
                    }
                }
            }
        }
    };
    describe("basic tests - retrieving value: ", function() {
        it("primitive", function() {
            return expect(_B.getValueAtPath(o, "$/bundle/dependencies/variableNames")).to.deep.equal("Bingo");
        });
        it("object", function() {
            return expect(_B.getValueAtPath(o, "$/bundle/dependencies")).to.deep.equal({
                variableNames: "Bingo"
            });
        });
        it("object, with sep at end", function() {
            return expect(_B.getValueAtPath(o, "$/bundle/dependencies/")).to.deep.equal({
                variableNames: "Bingo"
            });
        });
        it("array item (3rd)", function() {
            return expect(_B.getValueAtPath(o, "$/bundle/anArray/2/")).to.deep.equal({
                arrayItem3: 3
            });
        });
        it("property of (3rd) array item ", function() {
            return expect(_B.getValueAtPath(o, "$/bundle/anArray/2/arrayItem3")).to.deep.equal(3);
        });
        it("object, with alternative sep", function() {
            return expect(_B.getValueAtPath(o, "$.bundle.dependencies.", {
                separator: "."
            })).to.deep.equal({
                variableNames: "Bingo"
            });
        });
        it("undefined, for non existent key", function() {
            return expect(_B.getValueAtPath(o, "$/bundle/dependencies/variableNames/notfound")).to.deep.equal(void 0);
        });
        return it("undefined, for path of inexistent keys, with alt sep", function() {
            return expect(_B.getValueAtPath(o, "$>bundle>dependencies>variableNames>notfound>stillNotFound>", {
                separator: ">"
            })).to.deep.equal(void 0);
        });
    });
    describe("retrieving value using *defaultKey*:", function() {
        it("non existent key, but a defaultKey in its place", function() {
            return expect(_B.getValueAtPath(o, "$/bundle/someNonFoundKey/")).to.deep.equal({
                IamA: "defaultValue"
            });
        });
        it("non existent key, but a defaultKey in its place, goin on", function() {
            return expect(_B.getValueAtPath(o, "$/bundle/someNonFoundKey/IamA")).to.deep.equal("defaultValue");
        });
        return it("non existent key, but a defaultKey in its palce, went too far", function() {
            return expect(_B.getValueAtPath(o, "$/bundle/someNonFoundKey/tooFar")).to.deep.equal(void 0);
        });
    });
    describe("retrieving value using *stopKey*:", function() {
        it("non existent key, but a stopKey key in its place - defaultKey is ignored", function() {
            return expect(_B.getValueAtPath(o, "$/bundle/someOtherKey/someNonFoundKey/")).to.deep.equal({
                IamA: {
                    Stop: "Value"
                }
            });
        });
        it("non existent key, a terminal in its place, going on dosn't matter", function() {
            return expect(_B.getValueAtPath(o, "$/bundle/someOtherKey/someNonFoundKey/notReached")).to.deep.equal({
                IamA: {
                    Stop: "Value"
                }
            });
        });
        return it("non existent key, a stopKey key in its place, going too far dosn't matter", function() {
            return expect(_B.getValueAtPath(o, "$/bundle/someOtherKey/someNonFoundKey/goingTooFar/IsIgnored/")).to.deep.equal({
                IamA: {
                    Stop: "Value"
                }
            });
        });
    });
    describe("retrieving value using *terminateKey*:", function() {
        it("non existent key, but a terminateKey in its place, returns {terminateKey:value}", function() {
            return expect(_B.getValueAtPath(o, "$/bundle/leadingToTerminate/someNonFoundKey/", {
                terminateKey: "|"
            })).to.deep.equal({
                "|": {
                    terminated: "terminated value"
                }
            });
        });
        return it("existent key path, but found a terminateKey while walking, returns {terminateKey:value}", function() {
            return expect(_B.getValueAtPath(o, "$/bundle/leadingToTerminate/someKey/someOtherKey", {
                terminateKey: "|"
            })).to.deep.equal({
                "|": {
                    terminated: "terminated value"
                }
            });
        });
    });
    return describe("retrieving value using *isReturnLast*, returns last value found:", function() {
        return it("non existent key, returns last value", function() {
            return expect(_B.getValueAtPath(o, "$/bundle/dependencies/someNonFoundKey/", {
                isReturnLast: true
            })).to.deep.equal({
                variableNames: "Bingo"
            });
        });
    });
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('objects/isDisjoint-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var assert, expect;

assert = chai.assert;

expect = chai.expect;

describe("isDisjoint:", function() {
    describe("with primitives:", function() {
        describe("arrays:", function() {
            it("recognises disjoint:", function() {
                expect(_B.isDisjoint([ 1, 2, 3 ], [ 4, 5, 6, "1" ])).to.be["true"];
                return expect(_.intersection([ 1, 2, 3 ], [ 4, 5, 6, "1" ])).to.be.an("array").and.is.empty;
            });
            return it("recognises non disjoint:", function() {
                expect(_B.isDisjoint([ 1, 2, 3 ], [ 4, 2, 5 ])).to.be["false"];
                return expect(_.intersection([ 1, 2, 3 ], [ 4, 2, 5 ])).to.deep.equal([ 2 ]);
            });
        });
        return describe("arrays & objects:", function() {
            it("recognises disjoint in [] & {}:", function() {
                return expect(_B.isDisjoint([ 4, 5, 6 ], {
                    a: 1,
                    b: 7,
                    c: 8
                })).to.be["true"];
            });
            return it("recognises non disjoint in [] & {}:", function() {
                return expect(_B.isDisjoint([ 1, 2, 3 ], {
                    a: 1,
                    b: 7,
                    c: 8
                })).to.be["false"];
            });
        });
    });
    return describe("with references:", function() {
        var o1, o2, o3, o4;
        o1 = {
            p1: 1
        };
        o2 = {
            p2: 2
        };
        o3 = {
            p3: 3
        };
        o4 = {
            p4: 4
        };
        describe("arrays:", function() {
            it("recognises disjoint:", function() {
                expect(_B.isDisjoint([ o1, o2 ], [ {
                    p1: 1
                }, o3, o4 ])).to.be["true"];
                return expect(_.intersection([ o1, o2 ], [ {
                    p1: 1
                }, o3, o4 ])).to.deep.equal([]);
            });
            return it("recognises non disjoint:", function() {
                expect(_B.isDisjoint([ o1, o2 ], [ {
                    p1: 1
                }, o3, o4, o2 ])).to.be["false"];
                return expect(_.intersection([ o1, o2 ], [ {
                    p1: 1
                }, o3, o4, o2 ])).to.deep.equal([ o2 ]);
            });
        });
        describe("arrays & objects:", function() {
            it("recognises disjoint in [] & {}", function() {
                return expect(_B.isDisjoint([ o1, o2 ], {
                    p1: 1,
                    o3: o3,
                    o4: o4
                })).to.be["true"];
            });
            return it("recognises non disjoint in [] & {}:", function() {
                return expect(_B.isDisjoint([ o1, o2 ], {
                    p1: 1,
                    o3: o3,
                    o4: o4,
                    o2: o2
                })).to.be["false"];
            });
        });
        return describe("equality using _.isEqual :", function() {
            it("recognises disjoint in [] & {}, without _.isEqual", function() {
                return expect(_B.isDisjoint([ o1, o2 ], {
                    someP: {
                        p1: 1
                    },
                    o3: o3
                })).to.be["true"];
            });
            return it("recognises non disjoint in [] & {}, when using _.isEqual", function() {
                return expect(_B.isDisjoint([ o1, o2 ], {
                    someP: {
                        p1: 1
                    },
                    o3: o3
                }, _.isEqual)).to.be["false"];
            });
        });
    });
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('objects/isEqual-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var Class3, assert, c3, c3Clone, expect, expectedPropertyValues, inheritedDeepClone, inheritedShallowClone, oClone, object, objectDeepClone1, objectDeepClone2, objectShallowClone1, objectShallowClone2, objectWithProtoInheritedProps;

assert = chai.assert;

expect = chai.expect;

objectWithProtoInheritedProps = data.objectWithProtoInheritedProps, Class3 = data.Class3, c3 = data.c3, expectedPropertyValues = data.expectedPropertyValues, object = data.object, objectShallowClone1 = data.objectShallowClone1, objectShallowClone2 = data.objectShallowClone2, objectDeepClone1 = data.objectDeepClone1, objectDeepClone2 = data.objectDeepClone2, inheritedShallowClone = data.inheritedShallowClone, inheritedDeepClone = data.inheritedDeepClone;

oClone = _.clone(objectWithProtoInheritedProps);

c3Clone = _.clone(c3);

describe("isEqual:", function() {
    describe("lodash _.isEqual tests on _B.isEqual:", function() {
        it("should work with `arguments` objects (test in IE < 9)", function() {
            var args1, args2, args3;
            args1 = function() {
                return arguments;
            }(1, 2, 3);
            args2 = function() {
                return arguments;
            }(1, 2, 3);
            args3 = function() {
                return arguments;
            }(1, 2);
            expect(_B.isEqual(args1, args2)).to.be["true"];
            return expect(_B.isEqual(args1, args3)).to.be["false"];
        });
        it("should return `false` when comparing values with circular references to unlike values", function() {
            var array1, array2, object1, object2;
            array1 = [ "a", null, "c" ];
            array2 = [ "a", [], "c" ];
            object1 = {
                a: 1,
                b: null,
                c: 3
            };
            object2 = {
                a: 1,
                b: {},
                c: 3
            };
            array1[1] = array1;
            expect(_B.isEqual(array1, array2)).to.be["false"];
            object1.b = object1;
            return expect(_B.isEqual(object1, object2)).to.be["false"];
        });
        it("should pass the correct `callback` arguments", function() {
            var args;
            args = void 0;
            _B.isEqual("a", "b", function() {
                return args || (args = [].slice.call(arguments));
            });
            return expect(args).to.be.deep.equal([ "a", "b" ]);
        });
        it("should correct set the `this` binding", function() {
            var actual;
            actual = _B.isEqual("a", "b", function(a, b) {
                return this[a] === this[b];
            }, {
                a: 1,
                b: 1
            });
            return expect(actual).to.be["true"];
        });
        it("should handle comparisons if `callback` returns `undefined`", function() {
            var actual;
            actual = _B.isEqual("a", "a", function() {});
            return expect(actual).to.be["true"];
        });
        return it("should return a boolean value even if `callback` does not", function() {
            var actual;
            actual = _B.isEqual("a", "a", function() {
                return "a";
            });
            expect(actual).to.be["true"];
            return _.each([ "", 0, false, NaN, null, void 0 ], function(value) {
                actual = _B.isEqual("a", "b", function() {
                    return value;
                });
                return expect(actual).to.be["false"];
            });
        });
    });
    describe("rudimentary checks:", function() {
        describe("primitives:", function() {
            it("one undefined", function() {
                expect(_B.isEqual(void 0, objectWithProtoInheritedProps)).to.be["false"];
                return expect(_B.isEqual(objectWithProtoInheritedProps, void 0)).to.be["false"];
            });
            it("one null", function() {
                expect(_B.isEqual(null, objectWithProtoInheritedProps)).to.be["false"];
                return expect(_B.isEqual(objectWithProtoInheritedProps, null)).to.be["false"];
            });
            it("both undefined/null", function() {
                expect(_B.isEqual(void 0, void 0)).to.be["true"];
                return expect(_B.isEqual(null, null)).to.be["true"];
            });
            it("one undefined, other null", function() {
                expect(_B.isEqual(null, void 0)).to.be["false"];
                return expect(_B.isEqual(void 0, null)).to.be["false"];
            });
            it("Number", function() {
                expect(_B.isEqual(111, 111)).to.be["true"];
                expect(_B.isEqual(111.002, 111.002)).to.be["true"];
                expect(_B.isEqual(112, 111)).to.be["false"];
                return expect(_B.isEqual(111.002, 111.003)).to.be["false"];
            });
            describe("String", function() {
                it('as primitive ""', function() {
                    expect(_B.isEqual("AAA 111", "AAA 111")).to.be["true"];
                    return expect(_B.isEqual("AAA 112", "AAA 111")).to.be["false"];
                });
                return it("as String Object", function() {
                    expect(_B.isEqual(new String("AAA 111"), "AAA 111")).to.be["true"];
                    expect(_B.isEqual("AAA 111", new String("AAA 111"))).to.be["true"];
                    expect(_B.isEqual(new String("AAA 111"), new String("AAA 111"))).to.be["true"];
                    expect(_B.isEqual("AAA 112", new String("AAA 111"))).to.be["false"];
                    expect(_B.isEqual(new String("AAA 112"), "AAA 111")).to.be["false"];
                    return expect(_B.isEqual(new String("AAA 112"), new String("AAA 111"))).to.be["false"];
                });
            });
            it("Date", function() {
                expect(_B.isEqual(new Date("2012-12-12"), new Date("2012-12-12"))).to.be["true"];
                return expect(_B.isEqual(new Date("2012-12-13"), new Date("2012-12-12"))).to.be["false"];
            });
            it("RegExp", function() {
                expect(_B.isEqual(/abc/, /abc/)).to.be["true"];
                return expect(_B.isEqual(/abcd/, /abc/)).to.be["false"];
            });
            describe("Boolean", function() {
                it("as primitive", function() {
                    expect(_B.isEqual(true, true)).to.be["true"];
                    return expect(_B.isEqual(true, false)).to.be["false"];
                });
                return it("as Boolean {}", function() {
                    expect(_B.isEqual(new Boolean(true), true)).to.be["true"];
                    expect(_B.isEqual(new Boolean(true), false)).to.be["false"];
                    return expect(_B.isEqual(false, new Boolean(false))).to.be["true"];
                });
            });
            return describe("Mixed primitives", function() {
                it("boolean truthys", function() {
                    expect(_B.isEqual(true, 1)).to.be["false"];
                    return expect(_B.isEqual(true, "a string")).to.be["false"];
                });
                return it("boolean falsys", function() {
                    expect(_B.isEqual(false, 0)).to.be["false"];
                    return expect(_B.isEqual(false, "")).to.be["false"];
                });
            });
        });
        describe("Simple Objects & all functions", function() {
            it("empty objects & arrays", function() {
                expect(_B.isEqual([], [])).to.be["true"];
                expect(_B.isEqual({}, {})).to.be["true"];
                return expect(_B.isEqual({}, [])).to.be["false"];
            });
            return it("functions, with/without props", function() {
                var f1, f2;
                f1 = function() {};
                f2 = function() {};
                expect(_B.isEqual(f1, f2)).to.be["false"];
                expect(_B.isExact(f1, f2)).to.be["false"];
                expect(_B.isIqual(f1, f2)).to.be["false"];
                f1.p = "a";
                f2.p = "a";
                expect(_B.isEqual(f1, f2)).to.be["false"];
                expect(_B.isExact(f1, f2)).to.be["false"];
                return expect(_B.isIqual(f1, f2)).to.be["false"];
            });
        });
        return describe("callback:", function() {
            return it("returns true", function() {
                return expect(_B.isEqual(111, "111", function(a, b) {
                    return a + "" === b + "";
                })).to.be["true"];
            });
        });
    });
    describe("options.inherited - Objects with inherited properties:", function() {
        describe("object with __proro__ inherited properties:", function() {
            it("_B.isEqual is true", function() {
                expect(_B.isEqual(objectWithProtoInheritedProps, expectedPropertyValues, void 0, void 0, {
                    inherited: true
                })).to.be["true"];
                return expect(_B.isEqual(expectedPropertyValues, objectWithProtoInheritedProps, void 0, void 0, {
                    inherited: true
                })).to.be["true"];
            });
            it("_.isEqual fails", function() {
                expect(_.isEqual(objectWithProtoInheritedProps, expectedPropertyValues)).to.be["false"];
                return expect(_.isEqual(expectedPropertyValues, objectWithProtoInheritedProps)).to.be["false"];
            });
            describe("with _.clone: ", function() {
                it("_B.isIqual fails (imperfect _.clone)", function() {
                    expect(_B.isIqual(oClone, expectedPropertyValues)).to.be["false"];
                    return expect(_B.isIqual(expectedPropertyValues, oClone)).to.be["false"];
                });
                return it("_.isEqual fails", function() {
                    expect(_.isEqual(oClone, expectedPropertyValues)).to.be["false"];
                    return expect(_.isEqual(expectedPropertyValues, oClone)).to.be["false"];
                });
            });
            return describe("with _B.clone proto: ", function() {
                var oCloneProto;
                oCloneProto = _.clone(objectWithProtoInheritedProps);
                oCloneProto.__proto__ = objectWithProtoInheritedProps.__proto__;
                it("_B.isIqual succeeds (a perfect clone:-)", function() {
                    expect(_B.isIqual(oCloneProto, expectedPropertyValues)).to.be["true"];
                    return expect(_B.isIqual(expectedPropertyValues, oCloneProto)).to.be["true"];
                });
                return it("_.isEqual still fails", function() {
                    expect(_.isEqual(oCloneProto, expectedPropertyValues)).to.be["false"];
                    return expect(_.isEqual(expectedPropertyValues, oCloneProto)).to.be["false"];
                });
            });
        });
        return describe("coffeescript object with inherited properties:", function() {
            it("_B.isEqual is true", function() {
                expect(_B.isEqual(c3, expectedPropertyValues, {
                    inherited: true
                })).to.be["true"];
                return expect(_B.isIqual(expectedPropertyValues, c3)).to.be["true"];
            });
            it("_.isEqual fails", function() {
                expect(_.isEqual(c3, expectedPropertyValues)).to.be["false"];
                return expect(_.isEqual(expectedPropertyValues, c3)).to.be["false"];
            });
            describe("with _.clone:", function() {
                it("_B.isIqual fails (imperfect _.clone)", function() {
                    expect(_B.isEqual(c3Clone, expectedPropertyValues, void 0, void 0, {
                        inherited: true
                    })).to.be["false"];
                    return expect(_B.isIqual(expectedPropertyValues, c3Clone)).to.be["false"];
                });
                return it("_.isEqual fails", function() {
                    expect(_.isEqual(c3Clone, expectedPropertyValues)).to.be["false"];
                    return expect(_.isEqual(expectedPropertyValues, c3Clone)).to.be["false"];
                });
            });
            return describe("with _.clone proto: ", function() {
                var c3CloneProto;
                c3CloneProto = _.clone(c3);
                c3CloneProto.__proto__ = c3.__proto__;
                it("_B.isIqual is true", function() {
                    expect(_B.isEqual(c3CloneProto, expectedPropertyValues, void 0, void 0, {
                        inherited: true
                    })).to.be["true"];
                    return expect(_B.isIqual(expectedPropertyValues, c3CloneProto)).to.be["true"];
                });
                return it("_.isEqual fails", function() {
                    expect(_.isEqual(c3CloneProto, expectedPropertyValues)).to.be["false"];
                    return expect(_.isEqual(expectedPropertyValues, c3CloneProto)).to.be["false"];
                });
            });
        });
    });
    return describe("options.exact (Objects need to have exact refs) :", function() {
        describe("shallow cloned objects :", function() {
            it("_B.isExact(object, objectShallowClone1) is true", function() {
                expect(_B.isEqual(object, objectShallowClone1, void 0, void 0, {
                    exact: true
                })).to.be["true"];
                return expect(_B.isExact(objectShallowClone1, object)).to.be["true"];
            });
            it("_B.isExact(object, objectShallowClone2) with _.clone(object) is true", function() {
                expect(_B.isEqual(object, objectShallowClone2, {
                    exact: true
                })).to.be["true"];
                return expect(_B.isExact(objectShallowClone2, object)).to.be["true"];
            });
            return it("_.isEqual(object, shallowClone1 & 2) gives true", function() {
                expect(_.isEqual(object, objectShallowClone1)).to.be["true"];
                return expect(_.isEqual(object, objectShallowClone2)).to.be["true"];
            });
        });
        describe("deeply cloned objects:", function() {
            describe("objectDeepClone1 with hand configured __proto__:", function() {
                it("_B.isExact is false", function() {
                    expect(_B.isEqual(object, objectDeepClone1, {
                        exact: true
                    })).to.be["false"];
                    return expect(_B.isExact(objectDeepClone1, object)).to.be["false"];
                });
                return it("_B.isEqual is true", function() {
                    expect(_B.isEqual(object, objectDeepClone1)).to.be["true"];
                    return expect(_B.isEqual(objectDeepClone1, object)).to.be["true"];
                });
            });
            describe("objectDeepClone2 = _.clone(object):", function() {
                it("_B.isExact is false", function() {
                    expect(_B.isEqual(object, objectDeepClone2, void 0, void 0, {
                        exact: true
                    })).to.be["false"];
                    return expect(_B.isExact(objectDeepClone2, object)).to.be["false"];
                });
                return it("_B.isEqual is true", function() {
                    expect(_B.isEqual(object, objectDeepClone2)).to.be["true"];
                    return expect(_B.isEqual(objectDeepClone2, object)).to.be["true"];
                });
            });
            return it("_.isEqual(object, objectDeepClone1 & 2) gives true", function() {
                expect(_.isEqual(object, objectDeepClone1)).to.be["true"];
                return expect(_.isEqual(object, objectDeepClone2)).to.be["true"];
            });
        });
        return describe("isIxact : isEqual with inherited & exact :", function() {
            describe("shallow inherited clone: inheritedShallowClone:", function() {
                it("isIxact is true:", function() {
                    return expect(_B.isIxact(inheritedShallowClone, object)).to.be["true"];
                });
                return it("isIqual is true:", function() {
                    return expect(_B.isIqual(object, inheritedShallowClone)).to.be["true"];
                });
            });
            return describe("deep inherited clone : inheritedDeepClone:", function() {
                it("isIxact is true:", function() {
                    return expect(_B.isIxact(inheritedDeepClone, object)).to.be["false"];
                });
                return it("isIqual is true:", function() {
                    return expect(_B.isIqual(object, inheritedDeepClone)).to.be["true"];
                });
            });
        });
    });
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('objects/isRefDisjoint-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var O1, a1_2, a3_4, a3_4_2, a3_4_a1_2, a3_4_nested_a1_2, a3_4_nested_o2, assert, expect, inheritedDeepClone, inheritedShallowClone, o1, o1_2, o2, o3, o3_4, o3_4_2, o3_4_nested_o1_2, o3_4_nested_o2, o3_4_o1_2, o4, object, objectDeepClone1, objectDeepClone2, objectShallowClone1, objectShallowClone2;

assert = chai.assert;

expect = chai.expect;

O1 = o1 = {
    p1: 1
};

o2 = {
    p2: 2
};

o3 = {
    p3: 3
};

o4 = {
    p4: 4
};

a1_2 = [ o1, o2 ];

o1_2 = {
    p1: o1,
    p2: o2
};

a3_4 = [ o3, o4 ];

o3_4 = {
    p3: o3,
    p4: o4
};

a3_4_2 = [ o3, o4, o2 ];

o3_4_2 = {
    p3: o3,
    p4: o4,
    p5: o2
};

a3_4_a1_2 = [ o3, o4, a1_2 ];

o3_4_o1_2 = {
    p3: o3,
    p4: o4,
    p5: o1_2
};

a3_4_nested_o2 = [ o3, o4, {
    a: {
        b: o2
    }
} ];

o3_4_nested_o2 = {
    p3: o3,
    p4: o4,
    p5: {
        a: {
            b: o2
        }
    }
};

a3_4_nested_a1_2 = [ o3, o4, {
    a: {
        b: a1_2
    }
} ];

o3_4_nested_o1_2 = {
    p3: o3,
    p4: o4,
    p5: {
        a: {
            b: o1_2
        }
    }
};

object = data.object, objectShallowClone1 = data.objectShallowClone1, objectShallowClone2 = data.objectShallowClone2, objectDeepClone1 = data.objectDeepClone1, objectDeepClone2 = data.objectDeepClone2, inheritedShallowClone = data.inheritedShallowClone, inheritedDeepClone = data.inheritedDeepClone;

describe("isRefDisjoint:", function() {
    it("recognises self as non disjoint:", function() {
        return expect(_B.isRefDisjoint(o1, O1)).to.be["false"];
    });
    describe("Arrays:", function() {
        describe("with deep=false (shallow):", function() {
            it("recognises disjoint:", function() {
                expect(_B.isRefDisjoint(a1_2, a3_4)).to.be["true"];
                return expect(_B.isRefDisjoint(a3_4, a1_2)).to.be["true"];
            });
            it("recognises non-disjoint", function() {
                expect(_B.isRefDisjoint(a1_2, a3_4_2)).to.be["false"];
                return expect(_B.isRefDisjoint(a3_4_2, a1_2)).to.be["false"];
            });
            return describe("recognises disjoint:", function() {
                it("with nested shared reference", function() {
                    expect(_B.isRefDisjoint(a1_2, a3_4_nested_o2, {
                        deep: false
                    })).to.be["true"];
                    return expect(_B.isRefDisjoint(a3_4_nested_o2, a1_2, {
                        deep: false
                    })).to.be["true"];
                });
                return it("with one side being a shared reference", function() {
                    expect(_B.isRefDisjoint(a1_2, a3_4_nested_a1_2, {
                        deep: false
                    })).to.be["true"];
                    return expect(_B.isRefDisjoint(a3_4_nested_a1_2, a1_2, {
                        deep: false
                    })).to.be["true"];
                });
            });
        });
        return describe("with deep=true:", function() {
            it("recognises disjoint:", function() {
                expect(_B.isRefDisjoint(a1_2, a3_4, {
                    deep: true
                })).to.be["true"];
                return expect(_B.isRefDisjoint(a3_4, a1_2, {
                    deep: true
                })).to.be["true"];
            });
            return describe("recognises non-disjoint:", function() {
                it("with nested shared reference", function() {
                    expect(_B.isRefDisjoint(a1_2, a3_4_nested_o2, {
                        deep: true
                    })).to.be["false"];
                    return expect(_B.isRefDisjoint(a3_4_nested_o2, a1_2, {
                        deep: true
                    })).to.be["false"];
                });
                return it("with one side being a shared reference", function() {
                    expect(_B.isRefDisjoint(a1_2, a3_4_nested_a1_2, {
                        deep: true
                    })).to.be["false"];
                    return expect(_B.isRefDisjoint(a3_4_nested_a1_2, a1_2, {
                        deep: true
                    })).to.be["false"];
                });
            });
        });
    });
    describe("Objects:", function() {
        describe("with deep=false (shallow):", function() {
            it("recognises disjoint:", function() {
                expect(_B.isRefDisjoint(o1_2, o3_4)).to.be["true"];
                return expect(_B.isRefDisjoint(o3_4, o1_2)).to.be["true"];
            });
            it("recognises non-disjoint", function() {
                expect(_B.isRefDisjoint(o1_2, o3_4_2)).to.be["false"];
                return expect(_B.isRefDisjoint(o3_4_2, o1_2)).to.be["false"];
            });
            return describe("recognises disjoint:", function() {
                it("with nested shared reference", function() {
                    expect(_B.isRefDisjoint(o1_2, o3_4_nested_o2, {
                        deep: false
                    })).to.be["true"];
                    return expect(_B.isRefDisjoint(o3_4_nested_o2, o1_2, {
                        deep: false
                    })).to.be["true"];
                });
                return it("with one side being a shared reference", function() {
                    expect(_B.isRefDisjoint(o1_2, o3_4_nested_o1_2, {
                        deep: false
                    })).to.be["true"];
                    return expect(_B.isRefDisjoint(o3_4_nested_o1_2, o1_2, {
                        deep: false
                    })).to.be["true"];
                });
            });
        });
        return describe("with deep=true:", function() {
            it("recognises disjoint:", function() {
                expect(_B.isRefDisjoint(o1_2, o3_4, {
                    deep: true
                })).to.be["true"];
                return expect(_B.isRefDisjoint(o3_4, o1_2, {
                    deep: true
                })).to.be["true"];
            });
            return describe("recognises non-disjoint:", function() {
                it("with nested shared reference", function() {
                    expect(_B.isRefDisjoint(o1_2, o3_4_nested_o2, {
                        deep: true
                    })).to.be["false"];
                    return expect(_B.isRefDisjoint(o3_4_nested_o2, o1_2, {
                        deep: true
                    })).to.be["false"];
                });
                return it("with one side being a shared reference", function() {
                    expect(_B.isRefDisjoint(o1_2, o3_4_nested_o1_2, {
                        deep: true
                    })).to.be["false"];
                    return expect(_B.isRefDisjoint(o3_4_nested_o1_2, o1_2, {
                        deep: true
                    })).to.be["false"];
                });
            });
        });
    });
    describe("Mixed Arrays & Objects:", function() {
        describe("with deep=false (shallow):", function() {
            it("recognises disjoint:", function() {
                expect(_B.isRefDisjoint(o1_2, a3_4)).to.be["true"];
                return expect(_B.isRefDisjoint(o3_4, a1_2)).to.be["true"];
            });
            it("recognises non-disjoint", function() {
                expect(_B.isRefDisjoint(o1_2, a3_4_2)).to.be["false"];
                return expect(_B.isRefDisjoint(o3_4_2, a1_2)).to.be["false"];
            });
            return describe("recognises disjoint:", function() {
                it("with nested shared reference", function() {
                    expect(_B.isRefDisjoint(o1_2, a3_4_nested_o2, {
                        deep: false
                    })).to.be["true"];
                    return expect(_B.isRefDisjoint(o3_4_nested_o2, a1_2, {
                        deep: false
                    })).to.be["true"];
                });
                return it("with one side being a shared reference", function() {
                    expect(_B.isRefDisjoint([ o1_2 ], o3_4_nested_o1_2, {
                        deep: false
                    })).to.be["true"];
                    return expect(_B.isRefDisjoint([ o3_4_nested_o1_2 ], o1_2, {
                        deep: false
                    })).to.be["true"];
                });
            });
        });
        return describe("with deep=true:", function() {
            it("recognises disjoint:", function() {
                expect(_B.isRefDisjoint(o1_2, a3_4, {
                    deep: true
                })).to.be["true"];
                return expect(_B.isRefDisjoint(o3_4, a1_2, {
                    deep: true
                })).to.be["true"];
            });
            return describe("recognises non-disjoint:", function() {
                it("with nested shared reference", function() {
                    expect(_B.isRefDisjoint(o1_2, a3_4_nested_o2, {
                        deep: true
                    })).to.be["false"];
                    return expect(_B.isRefDisjoint(o3_4_nested_o2, a1_2, {
                        deep: true
                    })).to.be["false"];
                });
                return it("with one side being a shared reference", function() {
                    expect(_B.isRefDisjoint([ o1_2 ], o3_4_nested_o1_2, {
                        deep: true
                    })).to.be["false"];
                    return expect(_B.isRefDisjoint([ o3_4_nested_o1_2 ], o1_2, {
                        deep: true
                    })).to.be["false"];
                });
            });
        });
    });
    return describe("Cloned objects :", function() {
        describe("Without inherited properties:", function() {
            it("recognises non-disjoint (shallow clones):", function() {
                expect(_B.isRefDisjoint(objectShallowClone1, object, {
                    deep: true,
                    inherited: true
                })).to.be["false"];
                expect(_B.isRefDisjoint(object, objectShallowClone1, {
                    deep: true,
                    inherited: true
                })).to.be["false"];
                expect(_B.isRefDisjoint(objectShallowClone2, object, {
                    deep: true,
                    inherited: true
                })).to.be["false"];
                return expect(_B.isRefDisjoint(object, objectShallowClone2, {
                    deep: true,
                    inherited: true
                })).to.be["false"];
            });
            return it("recognises disjoint (deep clones):", function() {
                expect(_B.isRefDisjoint(objectDeepClone1, object, {
                    deep: true,
                    inherited: true
                })).to.be["true"];
                expect(_B.isRefDisjoint(object, objectDeepClone1, {
                    deep: true,
                    inherited: true
                })).to.be["true"];
                expect(_B.isRefDisjoint(objectDeepClone1, object, {
                    deep: true,
                    inherited: true
                })).to.be["true"];
                return expect(_B.isRefDisjoint(object, objectDeepClone1, {
                    deep: true,
                    inherited: true
                })).to.be["true"];
            });
        });
        return describe("With inherited properties:", function() {
            it("recognises non-disjoint (shallow clones):", function() {
                expect(_B.isRefDisjoint(inheritedShallowClone, object, {
                    deep: true,
                    inherited: true
                })).to.be["false"];
                return expect(_B.isRefDisjoint(object, inheritedShallowClone, {
                    deep: true,
                    inherited: true
                })).to.be["false"];
            });
            return it("recognises disjoint (deep clones):", function() {
                expect(_B.isRefDisjoint(inheritedDeepClone, object, {
                    deep: true,
                    inherited: true
                })).to.be["true"];
                return expect(_B.isRefDisjoint(object, inheritedDeepClone, {
                    deep: true,
                    inherited: true
                })).to.be["true"];
            });
        });
    });
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('objects/mutate-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var assert, expect;

assert = chai.assert;

expect = chai.expect;

describe("mutate :", function() {
    var simpleCalc;
    simpleCalc = function(v) {
        if (v < 0) {
            return v + 10;
        } else {
            return v + 20;
        }
    };
    it("mutate Object values", function() {
        var o;
        o = {
            a: 1,
            b: 2,
            c: -1
        };
        return expect(_B.mutate(o, simpleCalc)).to.deep.equal({
            a: 21,
            b: 22,
            c: 9
        });
    });
    it("arrayize if string", function() {
        var o;
        o = {
            key1: "lalakis",
            key2: [ "ok", "yes" ]
        };
        return expect(_B.mutate(o, _B.arrayize, _.isString)).to.deep.equal({
            key1: [ "lalakis" ],
            key2: [ "ok", "yes" ]
        });
    });
    return describe("mutate arrays :", function() {
        var a;
        a = [ 1, 2, -1 ];
        it("mutate array with simplecalc ", function() {
            return expect(_B.mutate(a, simpleCalc)).to.deep.equal([ 21, 22, 9 ]);
        });
        return it("mutate array again with fltr", function() {
            return expect(_B.mutate(a, simpleCalc, function(v) {
                return v > 10;
            })).to.deep.equal([ 41, 42, 9 ]);
        });
    });
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('objects/okv-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var arrInt, arrInt2, arrStr, assert, bundle, expect, global, obj, project, _ref;

assert = chai.assert;

expect = chai.expect;

_ref = _.clone(data, true), project = _ref.project, global = _ref.global, bundle = _ref.bundle, obj = _ref.obj, arrInt = _ref.arrInt, arrInt2 = _ref.arrInt2, arrStr = _ref.arrStr;

describe("okv :", function() {
    var weirdKeyName;
    weirdKeyName = " $#%!@&";
    it("builds a simple object, with weird keyName", function() {
        return expect(_B.okv({}, "foo_" + weirdKeyName, 8, "bar" + weirdKeyName, "some bar")).to.deep.equal({
            "foo_ $#%!@&": 8,
            "bar $#%!@&": "some bar"
        });
    });
    return describe("build a more invloved object", function() {
        var bar, o;
        o = {};
        _B.okv(o, "foo_" + weirdKeyName, 8, bar = "bar" + weirdKeyName, "some bar");
        o[bar] = _B.okv({}, "nestedBar" + weirdKeyName, "This is a secret bar", "anotherBar" + weirdKeyName, "Many bars, no foo");
        it("o is build, then part of it augmented", function() {
            return expect(o).to.deep.equal({
                "foo_ $#%!@&": 8,
                "bar $#%!@&": {
                    "nestedBar $#%!@&": "This is a secret bar",
                    "anotherBar $#%!@&": "Many bars, no foo"
                }
            });
        });
        return it("add nested weird keyd bars on existing key", function() {
            var i;
            _B.okv(o[bar], "newbar" + weirdKeyName, "a new bar!", "bar" + function() {
                var _i, _len, _ref1, _results;
                _ref1 = [ 1, 2, 3 ];
                _results = [];
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                    i = _ref1[_i];
                    _results.push("" + i);
                }
                return _results;
            }().join("-"), "ther weirest bar!");
            return expect(o).to.deep.equal({
                "foo_ $#%!@&": 8,
                "bar $#%!@&": {
                    "nestedBar $#%!@&": "This is a secret bar",
                    "anotherBar $#%!@&": "Many bars, no foo",
                    "newbar $#%!@&": "a new bar!",
                    "bar1-2-3": "ther weirest bar!"
                }
            });
        });
    });
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('objects/setValueAtPath-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var assert, expect;

assert = chai.assert;

expect = chai.expect;

describe("objects/setValueAtPath:", function() {
    var o;
    o = {
        $: {
            bundle: {
                anArray: [ "arrayItem1", 2, {
                    arrayItem3: 3
                } ],
                dependencies: {
                    variableNames: "Bingo"
                }
            }
        }
    };
    describe("existent paths", function() {
        it("primitive", function() {
            var isSet, oClone;
            oClone = _.clone(o, true);
            isSet = _B.setValueAtPath(oClone, "$/bundle/dependencies/variableNames", "just_a_String");
            expect(oClone).to.deep.equal({
                $: {
                    bundle: {
                        anArray: [ "arrayItem1", 2, {
                            arrayItem3: 3
                        } ],
                        dependencies: {
                            variableNames: "just_a_String"
                        }
                    }
                }
            });
            return expect(isSet).to.be["true"];
        });
        it("object, with sep at end & alt sep", function() {
            var isSet, oClone;
            oClone = _.clone(o, true);
            isSet = _B.setValueAtPath(oClone, "$.bundle.dependencies.variableNames.", {
                property: "just_a_String"
            }, void 0, ".");
            expect(oClone).to.deep.equal({
                $: {
                    bundle: {
                        anArray: [ "arrayItem1", 2, {
                            arrayItem3: 3
                        } ],
                        dependencies: {
                            variableNames: {
                                property: "just_a_String"
                            }
                        }
                    }
                }
            });
            return expect(isSet).to.be["true"];
        });
        it("object, overwriting object property", function() {
            var isSet, oClone;
            oClone = _.clone(o, true);
            isSet = _B.setValueAtPath(oClone, "$.bundle.dependencies.", {
                property: "just_a_String"
            }, void 0, ".");
            expect(oClone).to.deep.equal({
                $: {
                    bundle: {
                        anArray: [ "arrayItem1", 2, {
                            arrayItem3: 3
                        } ],
                        dependencies: {
                            property: "just_a_String"
                        }
                    }
                }
            });
            return expect(isSet).to.be["true"];
        });
        return it("array item, overwriting object property", function() {
            var isSet, oClone;
            oClone = _.clone(o, true);
            isSet = _B.setValueAtPath(oClone, "$.bundle.anArray.2.arrayItem3", {
                "3_is_now": 33
            }, void 0, ".");
            expect(oClone).to.deep.equal({
                $: {
                    bundle: {
                        anArray: [ "arrayItem1", 2, {
                            arrayItem3: {
                                "3_is_now": 33
                            }
                        } ],
                        dependencies: {
                            variableNames: "Bingo"
                        }
                    }
                }
            });
            return expect(isSet).to.be["true"];
        });
    });
    return describe("inexistent key paths:", function() {
        it("not setting by default", function() {
            var isSet, oClone;
            oClone = _.clone(o, true);
            isSet = _B.setValueAtPath(oClone, "$/bundle/dependencies/variableNames/hi", {
                joke: {
                    joke2: "JOKER"
                }
            });
            expect(oClone).to.deep.equal(o);
            return expect(isSet).to.be["false"];
        });
        return describe("forceCreate:", function() {
            it("create new objects for inexistent paths, adding object properties", function() {
                var isSet, oClone;
                oClone = _.clone(o, true);
                isSet = _B.setValueAtPath(oClone, "$.bundle.dependencies.moreDeps.evenMoreDeps.", {
                    property: "just_a_String"
                }, true, ".");
                expect(oClone).to.deep.equal({
                    $: {
                        bundle: {
                            anArray: [ "arrayItem1", 2, {
                                arrayItem3: 3
                            } ],
                            dependencies: {
                                variableNames: "Bingo",
                                moreDeps: {
                                    evenMoreDeps: {
                                        property: "just_a_String"
                                    }
                                }
                            }
                        }
                    }
                });
                return expect(isSet).to.be["true"];
            });
            it("create new objects, overwritting primitives", function() {
                var isSet, oClone;
                oClone = _.clone(o, true);
                isSet = _B.setValueAtPath(oClone, "$/bundle/dependencies/variableNames/newKey", {
                    joke: {
                        joke2: "JOKER"
                    }
                }, true);
                expect(oClone).to.deep.equal({
                    $: {
                        bundle: {
                            anArray: [ "arrayItem1", 2, {
                                arrayItem3: 3
                            } ],
                            dependencies: {
                                variableNames: {
                                    newKey: {
                                        joke: {
                                            joke2: "JOKER"
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
                return expect(isSet).to.be["true"];
            });
            return it("create new objects, preserving `oldValue`", function() {
                var isSet, oClone;
                oClone = _.clone(o, true);
                isSet = _B.setValueAtPath(oClone, "$/bundle/dependencies/variableNames/newKey/anotherNewKey", {
                    joke: {
                        joke2: "JOKER"
                    }
                }, "_oldValue");
                expect(oClone).to.deep.equal({
                    $: {
                        bundle: {
                            anArray: [ "arrayItem1", 2, {
                                arrayItem3: 3
                            } ],
                            dependencies: {
                                variableNames: {
                                    _oldValue: "Bingo",
                                    newKey: {
                                        anotherNewKey: {
                                            joke: {
                                                joke2: "JOKER"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
                return expect(isSet).to.be["true"];
            });
        });
    });
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('collections/go-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var arrInt, arrInt2, arrStr, assert, bundle, expect, global, obj, project, _ref, __indexOf = [].indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++) {
        if (i in this && this[i] === item) return i;
    }
    return -1;
};

assert = chai.assert;

expect = chai.expect;

_ref = _.clone(data, true), project = _ref.project, global = _ref.global, bundle = _ref.bundle, obj = _ref.obj, arrInt = _ref.arrInt, arrInt2 = _ref.arrInt2, arrStr = _ref.arrStr;

describe("go: version 0.0.3", function() {
    describe("go: Object passed, no params, ", function() {
        var result;
        result = _B.go(obj);
        it("should be a same looking object", function() {
            return expect(result).to.deep.equal(obj);
        });
        return it("but should NOT be the *identical* object, but a clone of it", function() {
            expect(result).to.not.equal(obj);
            return expect(result !== obj).to.be["true"];
        });
    });
    describe("go: Array<int> passed, no params, ", function() {
        var result;
        result = _B.go(arrInt);
        it("equal's contents array returned", function() {
            return expect(result).to.deep.equal(arrInt);
        });
        return it("but should NOT be the *identical* array, but a clone of it", function() {
            return expect(result).to.not.equal(arrInt);
        });
    });
    describe("go: Array<String> passed, no params, ", function() {
        var result;
        result = _B.go(_B.go(arrStr));
        it("equal's contents array returned", function() {
            return expect(result).to.deep.equal(arrStr);
        });
        return it("but should NOT be the *identical* array, but a clone of it", function() {
            return expect(result).to.not.equal(arrStr);
        });
    });
    describe("go: Filter : Object ", function() {
        it("keys named b", function() {
            return expect(_B.go(obj, {
                fltr: function(val, key) {
                    return key !== "b";
                }
            })).to.deep.equal({
                ciba: 4,
                aaa: 7,
                c: -1
            });
        });
        return it("values < 5", function() {
            return expect(_B.go(obj, {
                fltr: function(val, key) {
                    return val < 5;
                }
            })).to.deep.equal({
                ciba: 4,
                b: 2,
                c: -1
            });
        });
    });
    describe("Object: filter values < 5 and sortBy key, ", function() {
        var result;
        result = _B.go(obj, {
            fltr: function(val, key) {
                return val < 5;
            },
            sort: function(val, key) {
                return key;
            }
        });
        it("deeply equals {b: 2, ciba: 4, c: -1}", function() {
            return expect(result).to.deep.equal({
                b: 2,
                ciba: 4,
                c: -1
            });
        });
        it("keys 'appear' sorted - WARNING: might not work with some runtimes!", function() {
            return expect(_.map(result, function(v, k) {
                return k;
            })).to.deep.equal([ "b", "c", "ciba" ]);
        });
        return it("iter respects sorted order", function() {
            return expect(_.map(_B.go(result), function(v, k) {
                return k;
            })).to.deep.equal([ "b", "c", "ciba" ]);
        });
    });
    describe("Object: filter large key-names & sortBy value descenting", function() {
        var result;
        result = _B.go(obj, {
            fltr: function(val, key) {
                return key.length < 4;
            },
            sort: function(val) {
                return -val;
            }
        });
        it("deeply equals {aaa: 7, b: 2, c: -1}", function() {
            return expect(result).to.deep.equal({
                aaa: 7,
                b: 2,
                c: -1
            });
        });
        it("keys 'appear' sorted - WARNING: might not work with some runtimes!", function() {
            return expect(_.map(result, function(v, k) {
                return k;
            })).to.deep.equal([ "aaa", "b", "c" ]);
        });
        return it("iter respects sorted order", function() {
            return expect(_.map(_B.go(result), function(v, k) {
                return k;
            })).to.deep.equal([ "aaa", "b", "c" ]);
        });
    });
    describe("Object: filter values < 5 and sortBy value", function() {
        var result;
        result = _B.go(arrInt, {
            fltr: function(val) {
                return val < 5;
            },
            sort: function(val) {
                return val;
            }
        });
        return it("deeply equals [-1, 2, 4] ", function() {
            return expect(result).to.deep.equal([ -1, 2, 4 ]);
        });
    });
    describe("Object: filter historical names and sortBy value", function() {
        var result;
        result = _B.go(arrStr, {
            fltr: function(val) {
                return val !== "Babylon" && val !== "Sparta";
            },
            sort: function(val) {
                return val;
            }
        });
        return it("deeply equals ['Agelos', 'Anodynos', 'Pikoulas' ] ", function() {
            return expect(result).to.deep.equal([ "Agelos", "Anodynos", "Pikoulas" ]);
        });
    });
    describe("Collecting types & objects", function() {
        describe("Object: collects to Array & Object!", function() {
            it("collect values as Array ", function() {
                return expect(_B.go(obj, {
                    sort: function(v, k) {
                        return k;
                    },
                    grab: "[]"
                })).to.deep.equal([ 7, 2, -1, 4 ]);
            });
            it("declaratively collect on another object, but also returns Obj!", function() {
                var newObj, result;
                newObj = {
                    oldKey: "oldValue"
                };
                result = _B.go(obj, {
                    sort: function(v, k) {
                        return k;
                    },
                    grab: newObj
                });
                expect(newObj).to.deep.equal({
                    oldKey: "oldValue",
                    aaa: 7,
                    b: 2,
                    c: -1,
                    ciba: 4
                });
                return expect(result).to.deep.equal({
                    aaa: 7,
                    b: 2,
                    c: -1,
                    ciba: 4
                });
            });
            return it("using grab:-> collects keys as Array (in reverse -unsihft!), but returns sorted proper sorted Obj!", function() {
                var newArr, result;
                newArr = [];
                result = _B.go(obj, {
                    sort: function(v, k) {
                        return k;
                    },
                    grab: function(v, k) {
                        return newArr.unshift(k);
                    }
                });
                expect(newArr).to.deep.equal([ "ciba", "c", "b", "aaa" ]);
                return expect(result).to.deep.equal({
                    aaa: 7,
                    b: 2,
                    c: -1,
                    ciba: 4
                });
            });
        });
        return describe("Array: collects to Object (& Array)!", function() {
            it("returns an Object when grab instructs it", function() {
                return expect(_B.go(arrInt, {
                    sort: function(v, k) {
                        return v;
                    },
                    fltr: function(v) {
                        return v < 7;
                    },
                    grab: "{}"
                })).to.deep.equal({
                    "0": -1,
                    "1": 2,
                    "2": 4
                });
            });
            it("'grab' declaratively collects array values as object values, with idx as key", function() {
                var newObj, result;
                newObj = {
                    oldKey: "oldValue"
                };
                result = _B.go(arrInt, {
                    sort: function(v) {
                        return v;
                    },
                    grab: newObj
                });
                expect(newObj).to.deep.equal({
                    "0": -1,
                    "1": 2,
                    "2": 4,
                    "3": 7,
                    oldKey: "oldValue"
                });
                return expect(result).to.deep.equal({
                    "0": -1,
                    "1": 2,
                    "2": 4,
                    "3": 7
                });
            });
            return it("using a function, it collects keys/values newObj, but returns sorted Array!", function() {
                var newObj, result;
                newObj = {
                    oldKey: "oldValue"
                };
                result = _B.go(arrInt, {
                    sort: function(v, k) {
                        return v;
                    },
                    grab: function(v, k) {
                        return newObj[k] = v;
                    }
                });
                expect(newObj).to.deep.equal({
                    "0": -1,
                    "1": 2,
                    "2": 4,
                    "3": 7,
                    oldKey: "oldValue"
                });
                return expect(result).to.deep.equal([ -1, 2, 4, 7 ]);
            });
        });
    });
    describe("Object: mimicking various _ functions!", function() {
        it("resembles _.pick with single string name", function() {
            return expect(_B.go(obj, {
                fltr: "ciba"
            })).to.deep.equal(_.pick(obj, "ciba"));
        });
        it("resembles _.pick with array of String (or string evaluated objects)", function() {
            var aaa;
            aaa = {};
            aaa.toString = function() {
                return "aaa";
            };
            return expect(_B.go(obj, {
                fltr: [ "ciba", aaa ]
            })).to.deep.equal(_.pick(obj, "ciba", aaa));
        });
        it("resembles _.omit ", function() {
            return expect(_B.go(obj, {
                fltr: function(v, k) {
                    return k !== "ciba" && k !== "aaa";
                }
            })).to.deep.equal(_.omit(obj, "ciba", "aaa"));
        });
        it("resembles _.difference", function() {
            return expect(_B.go(arrInt, {
                fltr: function(v) {
                    return __indexOf.call(arrInt2, v) < 0;
                }
            })).to.deep.equal(_.difference(arrInt, arrInt2));
        });
        it("resembles _.map", function() {
            var ar;
            ar = [];
            _B.go(obj, {
                grab: function(v) {
                    return ar.push(v);
                }
            });
            return expect(ar).to.deep.equal(_.map(obj, function(v) {
                return v;
            }));
        });
        it("resembles _.map, with a difference: not restricted to collect in array!", function() {
            var ob;
            ob = {};
            _B.go(obj, {
                grab: function(v, k) {
                    return ob[v] = k;
                }
            });
            return expect(ob).to.deep.equal({
                "4": "ciba",
                "7": "aaa",
                "2": "b",
                "-1": "c"
            });
        });
        it("resembles _.keys (with order guaranteed!)", function() {
            var keys, result;
            keys = [];
            result = _B.go(obj, {
                sort: function(v, k) {
                    return k;
                },
                grab: function(v, k) {
                    return keys.push(k);
                }
            });
            expect(keys).to.deep.equal(_.keys(obj).sort());
            return expect(result).to.deep.equal({
                aaa: 7,
                b: 2,
                c: -1,
                ciba: 4
            });
        });
        return it("resembles _.pluck", function() {
            var agedNames, names, stooges;
            stooges = [ {
                name: "moe",
                age: 40
            }, {
                name: "larry",
                age: 50
            }, {
                name: "curly",
                age: 60
            } ];
            names = [];
            _B.go(stooges, {
                grab: function(v) {
                    return names.push(v.name);
                }
            });
            expect(names).to.deep.equal(_.pluck(stooges, "name"));
            agedNames = [];
            _B.go(stooges, {
                grab: function(v) {
                    return agedNames.push(v.name + " (" + v.age + ")");
                }
            });
            return expect(agedNames).to.deep.equal([ "moe (40)", "larry (50)", "curly (60)" ]);
        });
    });
    return describe("Original objects not mutated", function() {
        expect(bundle).to.deep.equal(data.bundle);
        expect(project).to.deep.equal(data.project);
        expect(global).to.deep.equal(data.global);
        expect(obj).to.deep.equal(data.obj);
        expect(arrStr).to.deep.equal(data.arrStr);
        expect(arrInt).to.deep.equal(data.arrInt);
        return expect(arrInt2).to.deep.equal(data.arrInt2);
    });
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('collections/array/arrayize-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../../spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var arrInt, arrInt2, arrStr, assert, bundle, expect, global, obj, project, _ref;

assert = chai.assert;

expect = chai.expect;

_ref = _.clone(data, true), project = _ref.project, global = _ref.global, bundle = _ref.bundle, obj = _ref.obj, arrInt = _ref.arrInt, arrInt2 = _ref.arrInt2, arrStr = _ref.arrStr;

describe("arrayize :", function() {
    it("arrayize a String", function() {
        return expect(_B.arrayize("agelos")).to.deep.equal([ "agelos" ]);
    });
    it("arrayize a Number", function() {
        return expect(_B.arrayize(19)).to.deep.equal([ 19 ]);
    });
    it("arrayize an Object", function() {
        return expect(_B.arrayize({
            a: 1,
            b: 2
        })).to.deep.equal([ {
            a: 1,
            b: 2
        } ]);
    });
    it("arrayize an existing array", function() {
        var arr;
        arr = [ 1, "john" ];
        return expect(_B.arrayize(arr)).to.equal(arr);
    });
    return it("arrayize nothingness", function() {
        return expect(_B.arrayize(void 0)).to.deep.equal([]);
    });
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('collections/array/isEqualArraySet-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', '../../spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var arrInt, arrInt2, arrStr, assert, expect, obj, _ref;

assert = chai.assert;

expect = chai.expect;

_ref = _.clone(data, true), obj = _ref.obj, arrInt = _ref.arrInt, arrInt2 = _ref.arrInt2, arrStr = _ref.arrStr;

describe("isEqualArraySet :", function() {
    it("simple arrays with primitives", function() {
        return expect(_B.isEqualArraySet([ 1, 2, 3, "John", "Doe" ], [ "John", 3, "Doe", 2, 1 ])).to.be["true"];
    });
    return it("arrays with primitives & references", function() {
        return expect(_B.isEqualArraySet([ obj, arrInt, arrStr, 2, 3, "John", "Doe" ], [ obj, "John", arrInt, 3, arrStr, "Doe", 2 ])).to.be["true"];
    });
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('type-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', './spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var assert, chai, expect, oOs, _, _B;

chai = require("chai");

assert = chai.assert;

expect = chai.expect;

_ = require("lodash");

_B = require("uberscore");

oOs = {
    Array: [ "this", "is", 1, "array" ],
    Function: function(x) {
        return x;
    },
    String: "I am a String!",
    Number: 667,
    Date: new Date,
    RegExp: /./g,
    Boolean: true,
    Null: null,
    Undefined: void 0,
    Object: {
        a: 1,
        b: 2,
        toString: function() {
            return "I am not a String, I am an Object...";
        }
    }
};

describe("type :", function() {
    var typeName, value, _results;
    _results = [];
    for (typeName in oOs) {
        value = oOs[typeName];
        _results.push(function(typeName, value, longType, shortType) {
            return it("recognises type '" + typeName + "', both as long='" + longType + "' & short='" + shortType + "'", function() {
                expect(longType).to.equal(_B.type.toLong(typeName));
                expect(_B.type.isType(longType)).to.be["true"];
                expect(shortType).to.equal(_B.type.toShort(typeName));
                expect(_B.type.isType(shortType)).to.be["true"];
                return expect(_B.type.areEqual(longType, shortType)).to.be["true"];
            });
        }(typeName, value, _B.type(value), _B.type(value, true)));
    }
    return _results;
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('isPlain-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', './spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var arrInt, arrInt2, arrStr, assert, bundle, expect, global, obj, project, _ref;

assert = chai.assert;

expect = chai.expect;

_ref = _.clone(data, true), project = _ref.project, global = _ref.global, bundle = _ref.bundle, obj = _ref.obj, arrInt = _ref.arrInt, arrInt2 = _ref.arrInt2, arrStr = _ref.arrStr;

describe("isPlain :", function() {
    it("Strings", function() {
        return expect(_B.isPlain("I am a String")).to.be["true"];
    });
    it("Numbers", function() {
        return expect(_B.isPlain(123)).to.be["true"];
    });
    it("Boolean", function() {
        return expect(_B.isPlain(false)).to.be["true"];
    });
    it("not Objects", function() {
        return expect(_B.isPlain({
            a: "a"
        })).to.be["false"];
    });
    return it("not Arrays", function() {
        return expect(_B.isPlain([ 1, 2, 3 ])).to.be["false"];
    });
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('uberscore-spec',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', './spec-data'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
var assert, expect, _uB;

assert = chai.assert;

expect = chai.expect;

_uB = require("uberscore");

describe("uRequire's `rootExports` & `noConflict()`\n   (running on " + (__isNode ? "nodsjs" : "Web") + " via " + (__isAMD ? "AMD" : "noAMD/script") + ")", function() {
    if (__isWeb) {
        it("registers globals '_B' & 'uberscore'", function() {
            expect(window._B).to.equal(_uB);
            return expect(window.uberscore).to.equal(_uB);
        });
        return it("noConflict() returns module & sets old values to globals '_B' & 'uberscore'", function() {
            expect(window._B.noConflict()).to.equal(_uB);
            expect(window._B).to.equal("Old global `_B`");
            return expect(window.uberscore).to.equal("Old global `uberscore`");
        });
    } else {
        it("NOT TESTING `rootExports`, I am on node/" + (__isAMD ? "AMD" : "plain") + "!", function() {});
        return it("NOT TESTING `noConflict()`, I am on node/" + (__isAMD ? "AMD" : "plain") + "!", function() {});
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('index',['require', 'exports', 'module', 'chai', 'lodash', 'uberscore', './spec-data', './blending/Blender-spec', './blending/deepExtend-spec', './blending/lodash-merge-spec', './blending/Mergers_Blender-spec', './blending/DeepDefaultsBlender-spec', './objects/getInheritedPropertyNames-spec', './objects/getRefs-spec', './objects/getValueAtPath-spec', './objects/isDisjoint-spec', './objects/isEqual-spec', './objects/isRefDisjoint-spec', './objects/mutate-spec', './objects/okv-spec', './objects/setValueAtPath-spec', './collections/go-spec', './collections/array/arrayize-spec', './collections/array/isEqualArraySet-spec', './type-spec', './isPlain-spec', './uberscore-spec'], 
  function (require, exports, module, chai, _, _B, data) {
  // uRequire: start body of original nodejs module
require("./blending/Blender-spec");

require("./blending/deepExtend-spec");

require("./blending/lodash-merge-spec");

require("./blending/Mergers_Blender-spec");

require("./blending/DeepDefaultsBlender-spec");

require("./objects/getInheritedPropertyNames-spec");

require("./objects/getRefs-spec");

require("./objects/getValueAtPath-spec");

require("./objects/isDisjoint-spec");

require("./objects/isEqual-spec");

require("./objects/isRefDisjoint-spec");

require("./objects/mutate-spec");

require("./objects/okv-spec");

require("./objects/setValueAtPath-spec");

require("./collections/go-spec");

require("./collections/array/arrayize-spec");

require("./collections/array/isEqualArraySet-spec");

require("./type-spec");

require("./isPlain-spec");

require("./spec-data");

require("./uberscore-spec");
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);

      return require('index');
  };

  if (__isAMD) {
      define(['chai', 'lodash', 'uberscore'], factory);
  } else {
      if (__isNode) {
          module.exports = factory();
      } else {
          factory();
      }
  }
})();