// Generated by uRequire v0.7.0-beta.28 target: 'AMD' template: 'AMD'
(function () {
  
var __isAMD = !!(typeof define === 'function' && define.amd),
    __isNode = (typeof exports === 'object'),
    __isWeb = !__isNode;
define(['require', 'exports', 'module', 'lodash', './agreement/inAgreements', './objects/setp', './objects/getp'], function (require, exports, module, _) {
  

var ANSI_BLACK, ANSI_BLACK_BOLD, ANSI_BLUE, ANSI_BLUE_BOLD, ANSI_CYAN, ANSI_CYAN_BOLD, ANSI_GREEN, ANSI_GREEN_BOLD, ANSI_PURPLE, ANSI_PURPLE_BOLD, ANSI_RED, ANSI_RED_BOLD, ANSI_RESET, ANSI_WHITE, ANSI_WHITE_BOLD, ANSI_YELLOW, ANSI_YELLOW_BOLD, Logger, getp, inAgreements, setp, slice = [].slice;
inAgreements = require("./agreement/inAgreements");
setp = require("./objects/setp");
getp = require("./objects/getp");
ANSI_RESET = "[0m";
ANSI_BLACK = "[30m";
ANSI_RED = "[31m";
ANSI_GREEN = "[32m";
ANSI_YELLOW = "[33m";
ANSI_BLUE = "[34m";
ANSI_PURPLE = "[35m";
ANSI_CYAN = "[36m";
ANSI_WHITE = "[37m";
ANSI_BLACK_BOLD = "[30;1m";
ANSI_RED_BOLD = "[31;1m";
ANSI_GREEN_BOLD = "[32;1m";
ANSI_YELLOW_BOLD = "[33;1m";
ANSI_BLUE_BOLD = "[34;1m";
ANSI_PURPLE_BOLD = "[35;1m";
ANSI_CYAN_BOLD = "[36;1m";
ANSI_WHITE_BOLD = "[37;1m";
Logger = function () {
  var arrayizeDebugPath, countNewLines, getALog, key, ref, val;
  function Logger(debugPath, debugLevel1) {
    if (debugPath == null) {
      debugPath = [];
    }
    this.debugLevel = debugLevel1;
    this.setDebugPath(debugPath);
    Logger.loggerCount = (Logger.loggerCount || 0) + 1;
  }
  getALog = function (baseMsg, color, cons) {
    return function () {
      var arg, args, err, error, i, j, len, newLines, retString, title;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (_.isString(args[0])) {
        newLines = countNewLines(args[0]);
        args[0] = args[0].slice(newLines);
      }
      args = function () {
        var j, len, results;
        results = [];
        for (j = 0, len = args.length; j < len; j++) {
          arg = args[j];
          results.push(Logger.prettify(arg));
        }
        return results;
      }();
      title = "" + (_.isEmpty(typeof this !== "undefined" && this !== null ? this.debugPath : void 0) ? "Logger" + Logger.loggerCount + " " : "[" + this.debugPath.join("/") + "] ") + baseMsg;
      if (title) {
        title = title + ":";
      }
      args.unshift(title);
      if (!(typeof __isWeb !== "undefined" && __isWeb !== null && __isWeb)) {
        args.unshift("" + color);
      }
      args.unshift(function () {
        var j, ref, results;
        results = [];
        for (i = j = 1, ref = newLines; j <= ref; i = j += 1) {
          results.push("\n");
        }
        return results;
      }().join(""));
      if (!(typeof __isWeb !== "undefined" && __isWeb !== null && __isWeb)) {
        args.push(ANSI_RESET);
      }
      cons.apply(console, args);
      try {
        return args.join("");
      } catch (error) {
        err = error;
        retString = "";
        for (j = 0, len = args.length; j < len; j++) {
          arg = args[j];
          retString += Object.prototype.toString(arg);
        }
        return retString;
      }
    };
  };
  countNewLines = function (str) {
    var newLines;
    newLines = 0;
    while (str[newLines] === "\n") {
      newLines++;
    }
    return newLines;
  };
  arrayizeDebugPath = function (debugPath) {
    var j, len, path, ref, results;
    if (_.isString(debugPath)) {
      ref = debugPath.split("/");
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        path = ref[j];
        if (path) {
          results.push(path);
        }
      }
      return results;
    } else if (_.isUndefined(debugPath)) {
      return [];
    } else if (_.isArray(debugPath)) {
      return debugPath;
    } else {
      return [debugPath];
    }
  };
  Logger.prototype.setDebugPath = function (debugPath) {
    return this.debugPath = arrayizeDebugPath(debugPath);
  };
  Logger.addDebugPathLevel = function (debugPath, debugLevel) {
    if (!_.isNaN(debugLevel * 1)) {
      debugPath = _.clone(arrayizeDebugPath(debugPath));
      debugPath.unshift("debugPathsLevels");
      debugPath.push("_level");
      return setp(Logger, debugPath, debugLevel * 1, { create: true });
    } else {
      throw new Error("debugLevel '" + debugLevel + "' isNaN (Not a Number or not Number parsable)");
    }
  };
  Logger.prototype.getDebugPathLevel = function (levelPath) {
    var lastPath, levPaths, val;
    if (levelPath == null) {
      levelPath = this.debugPath;
    }
    levPaths = _.clone(levelPath);
    val = getp(Logger.debugPathsLevels, levPaths);
    lastPath = levPaths.pop();
    while (_.isUndefined(val != null ? val._level : void 0) && lastPath) {
      val = getp(Logger.debugPathsLevels, levPaths);
      lastPath = levPaths.pop();
    }
    return val != null ? val._level : void 0;
  };
  Logger.prototype.isDebug = function (level) {
    var pathLevel;
    if (_.isNumber(Logger.maxDebugLevel)) {
      if (level > Logger.maxDebugLevel) {
        return false;
      }
    }
    if (_.isNumber(this.debugLevel)) {
      if (level > this.debugLevel) {
        return false;
      }
    } else {
      if (_.isNumber(pathLevel = this.getDebugPathLevel())) {
        if (level > pathLevel) {
          return false;
        }
      } else {
        if (level > 1) {
          return false;
        }
      }
    }
    return true;
  };
  Logger.prototype.deb = function () {
    var debugLog;
    debugLog = getALog("DEBUG", "[35m", console.log);
    return function () {
      var i, level, msgs, newLines, ref;
      level = arguments[0], msgs = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (_.isEmpty(msgs) && _.isNumber(level)) {
        return this.isDebug(this.lastDebugLevelCheck = level);
      }
      if (!_.isNumber(level)) {
        msgs.unshift(level);
        level = (ref = this.lastDebugLevelCheck) != null ? ref : 1;
        msgs.unshift(this.lastDebugLevelCheck ? "(?" + this.lastDebugLevelCheck + ")" : "(!1)");
      } else {
        msgs.unshift("(" + level + ")");
      }
      if (_.isString(msgs[1])) {
        newLines = countNewLines(msgs[1]);
        msgs[1] = msgs[1].slice(newLines);
        msgs[0] = function () {
          var j, ref1, results;
          results = [];
          for (i = j = 1, ref1 = newLines; j <= ref1; i = j += 1) {
            results.push("\n");
          }
          return results;
        }().join("") + msgs[0];
      }
      delete this.lastDebugLevelCheck;
      if (this.isDebug(level)) {
        return debugLog.apply(this, msgs);
      }
    };
  }();
  Logger.prototype.debug = Logger.prototype.deb;
  Logger.prettify = typeof __isNode !== "undefined" && __isNode !== null && __isNode ? function (inspect) {
    var nodeVerLE_092;
    nodeVerLE_092 = function () {
      var i, j, len, ref, v, x;
      v = [];
      ref = process.version.slice(1).split(".");
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        x = ref[i];
        v[i] = x * 1;
      }
      if (v[0] > 0 || v[1] > 9) {
        return false;
      } else {
        if (v[1] === 9) {
          if (v[2] <= 2) {
            return true;
          } else {
            return false;
          }
        } else {
          return true;
        }
      }
    }();
    return function (o) {
      var pretty;
      pretty = nodeVerLE_092 ? "[0m" + inspect(o, false, null, true) : "[0m" + inspect(o, {
        showHidden: false,
        depth: null,
        colors: true
      });
      if (_.isArray(o)) {
        pretty.replace(/\n/g, "");
      }
      if (inAgreements(o, [
          _.isObject,
          _.isRegExp
        ])) {
        return pretty;
      } else {
        return o;
      }
    };
  }(require("util").inspect) : function (o) {
    return o;
  };
  Logger.prototype.prettify = Logger.prettify;
  Logger.prototype.err = getALog("ERROR", ANSI_RED_BOLD, console.error);
  Logger.prototype.er = getALog("ERRor", ANSI_RED, console.log);
  Logger.prototype.warn = getALog("WARNING", ANSI_YELLOW_BOLD, console.log);
  Logger.prototype.verbose = getALog("", ANSI_CYAN_BOLD, console.log);
  Logger.prototype.ver = Logger.prototype.verbose;
  Logger.prototype.ok = getALog("", ANSI_GREEN_BOLD, console.log);
  Logger.prototype.log = getALog("", ANSI_WHITE_BOLD, console.log);
  Logger.logger = new Logger("DefaultLogger");
  ref = Logger.prototype;
  for (key in ref) {
    val = ref[key];
    if (_.isFunction(val)) {
      Logger[key] = _.bind(val, Logger.logger);
    } else {
      Logger[key] = val;
    }
  }
  return Logger;
}();
module.exports = Logger;

return module.exports;

})
}).call(this);