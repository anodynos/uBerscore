/**
* uberscore https://github.com/anodynos/uBerscore
*
* uBerscore js is (still) an early experiment: a 'higher' level data manipulator for all kinds of js collections (objects+arrays); it offers functionality & shortcuts that underscore doesn't, wouldn't, shouldn't have.
* Version 0.0.19 - Compiled on 2016-05-25 01:09:34
* Repository git://github.com/anodynos/uBerscore
* Copyright(c) 2016 Agelos Pikoulas <agelos.pikoulas@gmail.com>
* License MIT http://www.opensource.org/licenses/mit-license.php
*/

// Generated by uRequire v0.7.0-beta.28 target: 'specDev' template: 'combined'
// Combined template optimized with RequireJS/r.js v2.2.0 & almond v0.3.2.
(function (global, window){
  
var __isAMD = !!(typeof define === 'function' && define.amd),
    __isNode = (typeof exports === 'object'),
    __isWeb = !__isNode;


  var __nodeRequire = (__isNode ? require : function(dep){
        throw new Error("uRequire: combined template 'specDev', trying to load `node` dep `" + dep + "` in non-nodejs runtime (browser).")
      }),
      __throwMissing = function(dep, vars) {
        throw new Error("uRequire: combined template 'specDev', detected missing dependency `" + dep + "` - all it's known binding variables `" + vars + "` were undefined")
      },
      __throwExcluded = function(dep, descr) {
        throw new Error("uRequire: combined template 'specDev', trying to access unbound / excluded `" + descr + "` dependency `" + dep + "` on browser");
      };

  var extend = function (child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
var bundleFactory = function(_B, _uB, _, chai) {
/**
 * @license almond 0.3.2 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/almond/LICENSE
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name) {
            name = name.split('/');
            lastIndex = name.length - 1;

            // If wanting node ID compatibility, strip .js from end
            // of IDs. Have to do this here, and not in nameToUrl
            // because node allows either .js or non .js to map
            // to same file.
            if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
            }

            // Starts with a '.' so need the baseName
            if (name[0].charAt(0) === '.' && baseParts) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that 'directory' and not name of the baseName's
                //module. For instance, baseName of 'one/two/three', maps to
                //'one/two/three.js', but we want the directory, 'one/two' for
                //this normalization.
                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                name = normalizedBaseParts.concat(name);
            }

            //start trimDots
            for (i = 0; i < name.length; i++) {
                part = name[i];
                if (part === '.') {
                    name.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        name.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
            //end trimDots

            name = name.join('/');
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("almond", function(){});

define('spec-data',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('spec-data.js');

var Class0, Class1, Class2, Class3, c3, earth, earth_laboratory_experiment, expectedPropertyValues, experiment, experiment_laboratory_earth, inheritedDeepClone, inheritedDeepCloneParent, inheritedShallowClone, inheritedShallowCloneParent, laboratory, laboratory_experiment, object, object1, object2, object3, objectDeepClone1, objectDeepClone2, objectShallowClone1, objectShallowClone2, objectWithProtoInheritedProps, prop1;
  prop1 = {
    "aProp1.1": "o1.aVal1.1",
    "aProp1.2": "o1.aVal1.2"
  };
  object1 = { aProp2: "o1.aVal2" };
  object1.aProp1 = Object.create(prop1);
  object2 = Object.create(object1);
  object2.aProp2 = "o2.aVal2-1";
  object3 = Object.create(object2);
  _.extend(object3, {
    aProp2: "o3.aVal2-2",
    aProp3: [
      1,
      "2",
      3,
      { aProp4: "o3.aVal3" }
    ]
  });
  objectWithProtoInheritedProps = Object.create(object3);
  objectWithProtoInheritedProps.aProp0 = "o0.aVal0";
  Class0 = function () {
    function Class0() {
      this.aProp0 = "o0.aVal0";
    }
    return Class0;
  }();
  Class1 = function (superClass) {
    extend(Class1, superClass);
    function Class1() {
      return Class1.__super__.constructor.apply(this, arguments);
    }
    Class1.prototype.aProp1 = prop1;
    Class1.prototype.aProp2 = "o1.aVal2";
    return Class1;
  }(Class0);
  Class2 = function (superClass) {
    extend(Class2, superClass);
    function Class2() {
      return Class2.__super__.constructor.apply(this, arguments);
    }
    Class2.prototype.aProp2 = "o2.aVal2-1";
    return Class2;
  }(Class1);
  Class3 = function (superClass) {
    extend(Class3, superClass);
    function Class3() {
      return Class3.__super__.constructor.apply(this, arguments);
    }
    Class3.prototype.aProp2 = "o3.aVal2-2";
    Class3.prototype.aProp3 = [
      1,
      "2",
      3,
      { aProp4: "o3.aVal3" }
    ];
    return Class3;
  }(Class2);
  c3 = new Class3();
  expectedPropertyValues = {
    aProp0: "o0.aVal0",
    aProp1: {
      "aProp1.1": "o1.aVal1.1",
      "aProp1.2": "o1.aVal1.2"
    },
    aProp2: "o3.aVal2-2",
    aProp3: [
      1,
      "2",
      3,
      { aProp4: "o3.aVal3" }
    ]
  };
  object = {
    p1: 1,
    p2: { p2_2: 3 }
  };
  objectShallowClone1 = {
    p1: 1,
    p2: object.p2
  };
  objectShallowClone2 = _.clone(object);
  objectDeepClone1 = {
    p1: 1,
    p2: { p2_2: 3 }
  };
  objectDeepClone2 = _.clone(object, true);
  inheritedShallowCloneParent = { p2: object.p2 };
  inheritedShallowClone = Object.create(inheritedShallowCloneParent);
  inheritedShallowClone.p1 = 1;
  inheritedDeepCloneParent = { p2: { p2_2: 3 } };
  inheritedDeepClone = Object.create(inheritedDeepCloneParent);
  inheritedDeepClone.p1 = 1;
  earth = {
    name: "earthDefaults",
    environment: {
      temperature: 20,
      gravity: 9.8,
      moisture: { min: 10 }
    },
    life: true
  };
  laboratory = {
    name: "laboratoryDefaults",
    environment: {
      temperature: 35,
      moisture: { max: 40 }
    },
    life: {
      races: [
        "Caucasian",
        "African",
        "Asian"
      ],
      people: [
        {
          "name": "moe",
          "age": 40
        },
        {
          "name": "larry",
          "age": 50
        }
      ]
    }
  };
  experiment = {
    name: "experimentDefaults",
    environment: {
      gravity: 1.5,
      temperature: null
    },
    life: {
      races: [
        "Kafkasian",
        "ApHriCan",
        "Azian",
        "Mutant"
      ],
      people: [
        {
          "name": "moe",
          "age": 400
        },
        {
          "name": "blanka",
          "age": 20
        },
        {
          "name": "ken",
          "age": 25
        },
        {
          "name": "ryu",
          "age": 28
        },
        {
          "name": "larry",
          "age": 500
        }
      ]
    },
    results: { success: false }
  };
  earth_laboratory_experiment = {
    name: "earthDefaults",
    environment: {
      temperature: 20,
      gravity: 9.8,
      moisture: {
        min: 10,
        max: 40
      }
    },
    life: true,
    results: { success: false }
  };
  experiment_laboratory_earth = {
    name: "experimentDefaults",
    environment: {
      gravity: 1.5,
      temperature: 35,
      moisture: {
        max: 40,
        min: 10
      }
    },
    life: {
      races: [
        "Kafkasian",
        "ApHriCan",
        "Azian",
        "Mutant"
      ],
      people: [
        {
          "name": "moe",
          "age": 400
        },
        {
          "name": "blanka",
          "age": 20
        },
        {
          "name": "ken",
          "age": 25
        },
        {
          "name": "ryu",
          "age": 28
        },
        {
          "name": "larry",
          "age": 500
        }
      ]
    },
    results: { success: false }
  };
  laboratory_experiment = {
    name: "laboratoryDefaults",
    environment: {
      gravity: 1.5,
      temperature: 35,
      moisture: { max: 40 }
    },
    life: {
      races: [
        "Caucasian",
        "African",
        "Asian",
        "Mutant"
      ],
      people: [
        {
          "name": "moe",
          "age": 40
        },
        {
          "name": "larry",
          "age": 50
        },
        {
          "name": "ken",
          "age": 25
        },
        {
          "name": "ryu",
          "age": 28
        },
        {
          "name": "larry",
          "age": 500
        }
      ]
    },
    results: { success: false }
  };
  return {
    objectWithProtoInheritedProps: objectWithProtoInheritedProps,
    Class3: Class3,
    c3: c3,
    expectedPropertyValues: expectedPropertyValues,
    object: object,
    objectShallowClone1: objectShallowClone1,
    objectShallowClone2: objectShallowClone2,
    objectDeepClone1: objectDeepClone1,
    objectDeepClone2: objectDeepClone2,
    inheritedShallowClone: inheritedShallowClone,
    inheritedDeepClone: inheritedDeepClone,
    obj: {
      ciba: 4,
      aaa: 7,
      b: 2,
      c: -1
    },
    arrInt: [
      4,
      7,
      2,
      -1
    ],
    arrInt2: [
      7,
      -1,
      3,
      5
    ],
    arrStr: [
      "Pikoulas",
      "Anodynos",
      "Babylon",
      "Agelos"
    ],
    earth: earth,
    laboratory: laboratory,
    experiment: experiment,
    earth_laboratory_experiment: earth_laboratory_experiment,
    experiment_laboratory_earth: experiment_laboratory_earth,
    laboratory_experiment: laboratory_experiment,
    team: {
      "enabled": true,
      "bundleRoot": "/team",
      "compilers": { "rjs-build": "team-rjs" }
    },
    project: {
      "bundleRoot": "/team/project",
      "compilers": { "rjs-build": "project-rjs-build" }
    },
    bundle: {
      "bundleRoot": "/team/project/bundle",
      "compilers": {
        "coffee-script": { "params": "w b" },
        "urequire": { "scanPrevent": true }
      }
    },
    bundle_project_team: {
      "enabled": true,
      "bundleRoot": "/team/project/bundle",
      "compilers": {
        "coffee-script": { "params": "w b" },
        "urequire": { "scanPrevent": true },
        "rjs-build": "project-rjs-build"
      }
    }
  };


});
define('specHelpers',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('specHelpers.js');

var are, createEqualSet, deepEqual, equal, equalSet, exact, fals, iqual, ixact, like, likeBA, notDeepEqual, notEqual, notEqualSet, notExact, notIqual, notIxact, notLike, notLikeBA, notOk, ok, tru;
equal = function (a, b) {
  return expect(a).to.equal(b);
};
notEqual = function (a, b) {
  return expect(a).to.not.equal(b);
};
ok = function (a) {
  return expect(a).to.be.ok;
};
notOk = function (a) {
  return expect(a).to.be.not.ok;
};
tru = function (a) {
  return expect(a).to.be["true"];
};
fals = function (a) {
  return expect(a).to.be["false"];
};
are = function (name, asEqual) {
  if (asEqual == null) {
    asEqual = true;
  }
  return function (a, b) {
    var isEq, path;
    isEq = _B[name](a, b, {
      path: path = [],
      allProps: true,
      exclude: ["inspect"]
    });
    if (asEqual) {
      if (!isEq) {
        l.warn("Discrepancy, expected `true` from _B." + name + " \n at path: ", path.join("."), " \n left value = ", _B.getp(a, path), "\n right value =", _B.getp(b, path), " \n left Object = \n", a, "\n right Object = \n", b);
      }
      return expect(isEq).to.be["true"];
    } else {
      if (isEq) {
        l.warn("Discrepancy, expected `false` from _B." + name + ", but its `true`.");
      }
      return expect(isEq).to.be["false"];
    }
  };
};
createEqualSet = function (asEqual) {
  return function (result, expected) {
    var isEq;
    isEq = _B.isEqualArraySet(result, expected);
    if (asEqual) {
      if (!isEq) {
        l.warn("\n _B.isEqualArraySet expected `true`", "\n result \\ expected \n", _.difference(result, expected), "\n expected \\ result \n", _.difference(expected, result));
      }
      return expect(isEq).to.be["true"];
    } else {
      if (isEq) {
        l.warn("\n _B.isEqualArraySet expected `false`, got `true`");
      }
      return expect(isEq).to.be["false"];
    }
  };
};
equalSet = createEqualSet(true);
notEqualSet = createEqualSet(false);
deepEqual = are("isEqual");
notDeepEqual = are("isEqual", false);
exact = are("isExact");
notExact = are("isExact", false);
iqual = are("isIqual");
notIqual = are("isIqual", false);
ixact = are("isIxact");
notIxact = are("isIxact", false);
like = are("isLike");
notLike = are("isLike", false);
likeBA = function (a, b) {
  return like(b, a);
};
notLikeBA = function (a, b) {
  return notLike(b, a);
};
module.exports = {
  equal: equal,
  notEqual: notEqual,
  tru: tru,
  fals: fals,
  ok: ok,
  notOk: notOk,
  deepEqual: deepEqual,
  notDeepEqual: notDeepEqual,
  exact: exact,
  notExact: notExact,
  iqual: iqual,
  notIqual: notIqual,
  ixact: ixact,
  notIxact: notIxact,
  like: like,
  notLike: notLike,
  likeBA: likeBA,
  notLikeBA: notLikeBA,
  equalSet: equalSet,
  notEqualSet: notEqualSet
};

return module.exports;

});
define('agreement/inAgreements-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('agreement/inAgreements-spec.js');

var compiledFiles, exclude, include, jsFiles, libs;
compiledFiles = /.*\.(coffee|iced|coco)$/i;
jsFiles = /.*\.(js|javascript)$/i;
include = [
  jsFiles,
  compiledFiles,
  "papari.txt"
];
exclude = [/.*lalakis.*/];
libs = [
  "file.coffee",
  "lalakis.coffee",
  "superlalakis.js",
  "papari.txt",
  "loulou.gif",
  "bla.js"
];
describe("inAgreements ", function () {
  it("a simple file inAgreements 'include'", function () {
    return expect(_B.inAgreements("file.coffee", include)).to.be["true"];
  });
  return it("a simple file inAgreements 'include'", function () {
    return expect(_B.inAgreements("papari.txt", include)).to.be["true"];
  });
});

return module.exports;

});
define('agreement/isAgree-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('agreement/isAgree-spec.js');

describe("isAgree ", function () {
  it("a String with another String", function () {
    return expect(_B.isAgree("agelos", "agelos")).to.be["true"];
  });
  it("a String with a RegExp", function () {
    return expect(_B.isAgree("agelos", /agelos/)).to.be["true"];
  });
  it("a String with undefined", function () {
    return expect(_B.isAgree("agelos", void 0)).to.be["true"];
  });
  return it("a String with another object", function () {
    return expect(_B.isAgree({
      x: "agelos",
      toString: function () {
        return this.x;
      }
    }, "agelos")).to.be["true"];
  });
});

return module.exports;

});
define('blending/ArrayizeBlender-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('blending/ArrayizeBlender-spec.js');

return describe("ArrayizeBlender:", function () {
    describe("arrayizeBlender:", function () {
      var arrayizeBlender;
      arrayizeBlender = new _B.ArrayizeBlender();
      it("pushes ALL source array items into destination array", function () {
        return deepEqual(arrayizeBlender.blend([
          1,
          2,
          3
        ], [
          1,
          2,
          4,
          5,
          6,
          "7"
        ]), [
          1,
          2,
          3,
          1,
          2,
          4,
          5,
          6,
          "7"
        ]);
      });
      describe("pushes source array items into non-array destination, arrayize'ing it first", function () {
        it("Number", function () {
          return deepEqual(arrayizeBlender.blend(123, [
            4,
            5,
            6
          ]), [
            123,
            4,
            5,
            6
          ]);
        });
        it("String", function () {
          return deepEqual(arrayizeBlender.blend("123", [
            4,
            5,
            void 0,
            6
          ]), [
            "123",
            4,
            5,
            void 0,
            6
          ]);
        });
        it("RegExp", function () {
          return deepEqual(arrayizeBlender.blend(/./, [
            4,
            5,
            null,
            6
          ]), [
            /./,
            4,
            5,
            null,
            6
          ]);
        });
        it("`undefined` pushes nothing", function () {
          return deepEqual(arrayizeBlender.blend(void 0, [
            "1",
            "2",
            "3"
          ]), [
            "1",
            "2",
            "3"
          ]);
        });
        return it("`null` pushes nothing", function () {
          return deepEqual(arrayizeBlender.blend(null, [
            "1",
            "2",
            "3"
          ]), [
            "1",
            "2",
            "3"
          ]);
        });
      });
      describe("pushes source non-array item into array destination:", function () {
        it("String", function () {
          return deepEqual(arrayizeBlender.blend([
            "1",
            "2",
            "3"
          ], "456"), [
            "1",
            "2",
            "3",
            "456"
          ]);
        });
        it("RegExp", function () {
          var regExp;
          regExp = /./;
          return deepEqual(arrayizeBlender.blend([
            "1",
            "2",
            "3"
          ], regExp), [
            "1",
            "2",
            "3",
            regExp
          ]);
        });
        return it("Source of `undefined` or `null` push nothing", function () {
          deepEqual(arrayizeBlender.blend([
            "1",
            "2",
            "3"
          ], void 0), [
            "1",
            "2",
            "3"
          ]);
          return deepEqual(arrayizeBlender.blend([
            "1",
            "2",
            "3"
          ], null), [
            "1",
            "2",
            "3"
          ]);
        });
      });
      describe("pushes non-array items onto each other", function () {
        it("String->String", function () {
          return deepEqual(arrayizeBlender.blend("123", "456"), [
            "123",
            "456"
          ]);
        });
        it("String->RegExp", function () {
          var regExp;
          regExp = /./;
          return deepEqual(arrayizeBlender.blend("123", regExp), [
            "123",
            regExp
          ]);
        });
        return it("RegExp->String", function () {
          return deepEqual(arrayizeBlender.blend(/./, "123"), [
            /./,
            "123"
          ]);
        });
      });
      describe("Reseting the destination array with signpost `[null]` as 1st src item", function () {
        var dstArray, result;
        dstArray = [
          "items",
          "to be",
          "removed"
        ];
        result = arrayizeBlender.blend(dstArray, [
          [null],
          11,
          22,
          33
        ]);
        it("resets destination array to a new one ", function () {
          return notEqual(result, dstArray);
        });
        return it("resets destination array & then pushes - ", function () {
          return deepEqual(result, [
            11,
            22,
            33
          ]);
        });
      });
      return describe("Arrays with reference values:", function () {
        var dstArray, result, srcArray;
        dstArray = [
          { a: 1 },
          { b: 2 },
          { c: 3 }
        ];
        srcArray = [
          { d: 4 },
          { e: 5 },
          { f: 6 }
        ];
        result = arrayizeBlender.blend(dstArray, srcArray);
        it("All refs are pushed to destination & result is dstArray", function () {
          deepEqual(result, dstArray);
          return deepEqual(result, [
            dstArray[0],
            dstArray[1],
            dstArray[2],
            srcArray[0],
            srcArray[1],
            srcArray[2]
          ]);
        });
        it("leaves dst items untouched", function () {
          var i, j, results;
          results = [];
          for (i = j = 0; j <= 2; i = ++j) {
            results.push(equal(result[i], dstArray[i]));
          }
          return results;
        });
        return it("leaves source items untouched, pushed as exact refs to destination", function () {
          var i, j, results;
          results = [];
          for (i = j = 0; j <= 2; i = ++j) {
            results.push(equal(result[i + 3], srcArray[i]));
          }
          return results;
        });
      });
    });
    describe("arrayizeUniqueBlender:", function () {
      var arrayizeUniqueBlender;
      arrayizeUniqueBlender = new _B.ArrayizeBlender([], { unique: true });
      it("has unique:true", function () {
        return tru(arrayizeUniqueBlender.unique);
      });
      return it("pushes only === unique items", function () {
        return deepEqual(arrayizeUniqueBlender.blend([
          1,
          4,
          2,
          3
        ], [
          1,
          2,
          4,
          5,
          6,
          "7"
        ]), [
          1,
          4,
          2,
          3,
          5,
          6,
          "7"
        ]);
      });
    });
    describe("arrayizeUnshiftingBlender:", function () {
      var arrayizeUnshiftingBlender;
      arrayizeUnshiftingBlender = new _B.ArrayizeBlender([], { addMethod: "unshift" });
      it("has addMethod:unshift", function () {
        return equal(arrayizeUnshiftingBlender.addMethod, "unshift");
      });
      return it("unshifts (instead of pushing) items", function () {
        return deepEqual(arrayizeUnshiftingBlender.blend([
          1,
          2,
          3,
          4
        ], [
          5,
          6,
          "7",
          8
        ], 9, [
          10,
          11
        ], 12), [
          12,
          11,
          10,
          9,
          8,
          "7",
          6,
          5,
          1,
          2,
          3,
          4
        ]);
      });
    });
    return describe("arrayizeUnshiftingReverseBlender:", function () {
      var arrayizeUnshiftingBlender;
      arrayizeUnshiftingBlender = new _B.ArrayizeBlender([], {
        addMethod: "unshift",
        reverse: true
      });
      it("has right flags", function () {
        equal(arrayizeUnshiftingBlender.addMethod, "unshift");
        return equal(arrayizeUnshiftingBlender.reverse, true);
      });
      return it("unshifts (instead of pushing) items, in reverse order (hence source arrays remain in right order)", function () {
        return deepEqual(arrayizeUnshiftingBlender.blend([
          1,
          2,
          3,
          4
        ], [
          5,
          6,
          "7",
          8
        ], 9, [
          10,
          11
        ], 12), [
          12,
          10,
          11,
          9,
          5,
          6,
          "7",
          8,
          1,
          2,
          3,
          4
        ]);
      });
    });
  });


});
define('blending/Blender-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('blending/Blender-spec.js');

return describe("Blender & DeepCloneBlender:", function () {
    describe("Internals: blender.adjustBlenderBehavior:", function () {
      return describe("corectly transforms nested types of srcDstSpecs to short format", function () {
        it("works with simple 'src' and 'dst'", function () {
          var blender, expectedAdjustedBb, longTypeNamesBb;
          longTypeNamesBb = {
            order: [
              "src",
              "dst"
            ],
            Array: { String: "someAction" },
            Object: {
              "Array": "doSomeAction",
              "Null": function () {
              }
            },
            doSomeAction: function () {
            }
          };
          expectedAdjustedBb = {
            order: [
              "src",
              "dst"
            ],
            doSomeAction: longTypeNamesBb.doSomeAction,
            "[]": { "''": "someAction" },
            "{}": {
              "[]": "doSomeAction",
              "null": longTypeNamesBb["Object"].Null
            }
          };
          blender = new _B.Blender(longTypeNamesBb);
          return expect(_.isEqual(blender.blenderBehaviors[0], expectedAdjustedBb)).to.be["true"];
        });
        return it("works with bbOrder specs ['src', 'path', 'dst']", function () {
          var expectedAdjustededBb, longTypePathBb;
          longTypePathBb = {
            order: [
              "src",
              "path",
              "dst"
            ],
            Function: function () {
            },
            String: {
              "bundle:dependencies:depsVars:*": {
                basics: {
                  "|": {
                    Object: function () {
                      return "Iam a someObjectAction";
                    },
                    Array: "someArrayAction, found on a preceding blenderBehavior or blender",
                    String: function (prop, src, dst, blender) {
                      return B.Blender.SKIP;
                    }
                  }
                }
              },
              "bundle:dependencies:_knownDepsVars": {
                String: {
                  Array: {
                    Function: {
                      "|": {
                        Function: function () {
                          return _B.Blender.SKIP;
                        },
                        Array: "someArrayAction"
                      }
                    }
                  }
                }
              }
            },
            someAction: function () {
            }
          };
          expectedAdjustededBb = {
            order: [
              "src",
              "path",
              "dst"
            ],
            "->": longTypePathBb.Function,
            "''": {
              bundle: {
                dependencies: {
                  depsVars: {
                    "*": {
                      basics: {
                        "|": {
                          "{}": longTypePathBb["String"]["bundle:dependencies:depsVars:*"].basics["|"]["Object"],
                          "[]": longTypePathBb["String"]["bundle:dependencies:depsVars:*"].basics["|"]["Array"],
                          "''": longTypePathBb["String"]["bundle:dependencies:depsVars:*"].basics["|"]["String"]
                        }
                      }
                    }
                  },
                  _knownDepsVars: {
                    String: {
                      Array: {
                        Function: {
                          "|": {
                            "->": longTypePathBb["String"]["bundle:dependencies:_knownDepsVars"].String.Array.Function["|"]["Function"],
                            "[]": "someArrayAction"
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            someAction: longTypePathBb.someAction
          };
          return expect(new _B.DeepCloneBlender(longTypePathBb).blenderBehaviors[0]).to.deep.equal(expectedAdjustededBb);
        });
      });
    });
    describe("Handles primitives:", function () {
      var blender;
      blender = new _B.Blender();
      it("overwrites undefined / null:", function () {
        expect(blender.blend(void 0, 6, 18)).to.equal(18);
        expect(blender.blend(void 0, "a string")).to.equal("a string");
        expect(blender.blend(null, 16.7)).to.equal(16.7);
        expect(blender.blend(null, "a string")).to.equal("a string");
        return expect(blender.blend(void 0, 18, { prop: "someValue" })).to.deep.equal({ prop: "someValue" });
      });
      return it("overwrites primitives", function () {
        expect(blender.blend(6, 18)).to.equal(18);
        expect(blender.blend("a string", 18, "another string")).to.equal("another string");
        return expect(blender.blend("a string", 18, { prop: "someValue" })).to.deep.equal({ prop: "someValue" });
      });
    });
    describe("Options passing:", function () {
      it("deepCloneBlender.anOption is someOptions.anOption", function () {
        var deepCloneBlender, someOptions;
        someOptions = {
          anOption: function () {
            return "I am a function";
          }
        };
        deepCloneBlender = new _B.DeepCloneBlender([], someOptions);
        return expect(deepCloneBlender.anOption).to.equal(someOptions.anOption);
      });
      it("real options: ", function () {
        var deepCloneBlender, myCopyProto, myInherited;
        deepCloneBlender = new _B.DeepCloneBlender();
        expect(deepCloneBlender.inherited).to.be["false"];
        expect(deepCloneBlender.copyProto).to.be["false"];
        myCopyProto = function () {
        };
        myInherited = function () {
        };
        deepCloneBlender = new _B.DeepCloneBlender([], {
          inherited: myInherited,
          copyProto: myCopyProto
        });
        expect(deepCloneBlender.inherited).to.equal(myInherited);
        return expect(deepCloneBlender.copyProto).to.equal(myCopyProto);
      });
      return describe("Options go up the inheritance:", function () {
        var SomeBlender, SomeOtherBlender;
        SomeBlender = function (superClass) {
          extend(SomeBlender, superClass);
          function SomeBlender() {
            return SomeBlender.__super__.constructor.apply(this, arguments);
          }
          SomeBlender.prototype.someOption = "someOptionValue";
          return SomeBlender;
        }(_B.Blender);
        SomeOtherBlender = function (superClass) {
          extend(SomeOtherBlender, superClass);
          function SomeOtherBlender() {
            return SomeOtherBlender.__super__.constructor.apply(this, arguments);
          }
          SomeOtherBlender.prototype.someOtherOption = "someOtherOptionValue";
          SomeOtherBlender.prototype.someOption = "someOptionValue of SomeOtherBlender";
          return SomeOtherBlender;
        }(_B.Blender);
        it("respecting subclassed options #1", function () {
          var someBlender;
          someBlender = new SomeBlender();
          expect(someBlender.someOption).to.equal("someOptionValue");
          someBlender = new SomeBlender([], { someOption: "someRedefinedOptionValue" });
          return expect(someBlender.someOption).to.equal("someRedefinedOptionValue");
        });
        return it("respecting subclassed options #2", function () {
          var someOtherBlender;
          someOtherBlender = new SomeOtherBlender();
          expect(someOtherBlender.someOption).to.equal("someOptionValue of SomeOtherBlender");
          someOtherBlender = new SomeOtherBlender([], { someOption: "someRedefinedOptionValue" });
          expect(someOtherBlender.someOption).to.equal("someRedefinedOptionValue");
          return expect(someOtherBlender.someOtherOption).to.equal === "someOtherOptionValue";
        });
      });
    });
    return describe("Blender behaviors:", function () {
      describe("Simple examples:", function () {
        var o1, o2;
        o1 = {
          p1: 5,
          p2: {
            p21: "A String",
            p22: [
              5,
              6,
              "String in array"
            ]
          },
          p3: "Some string"
        };
        o2 = {
          p1: 10,
          p2: {
            p21: "Another String",
            p22: [
              20,
              40
            ]
          }
        };
        it("Numbers dont just overwrite each other: the source is doubled and then added up to destination", function () {
          var deepCloneBlenderAddingNumbers;
          deepCloneBlenderAddingNumbers = new _B.DeepCloneBlender({
            "Number": {
              "Number": function (prop, src, dst) {
                return dst[prop] + src[prop] * 2;
              }
            }
          });
          return expect(deepCloneBlenderAddingNumbers.blend({}, o1, o2)).to.deep.equal({
            p1: 25,
            p2: {
              p21: "Another String",
              p22: [
                45,
                86,
                "String in array"
              ]
            },
            p3: "Some string"
          });
        });
        it("src Array items dont just overwrite the destination Array ones: they are doubled (if numbers) & then pushed to dst.", function () {
          var deepCloneBlenderAddingNumbers;
          deepCloneBlenderAddingNumbers = new _B.DeepCloneBlender({
            "Array": {
              "Array": function (prop, src, dst, bldr) {
                var i, item, len, ref;
                ref = src[prop];
                for (i = 0, len = ref.length; i < len; i++) {
                  item = ref[i];
                  item = bldr.blend({}, { hack: item }).hack;
                  dst[prop].push(_.isNumber(item) ? item * 2 : item);
                }
                return _B.Blender.SKIP;
              }
            }
          });
          return expect(deepCloneBlenderAddingNumbers.blend({}, o1, o2)).to.deep.equal({
            p1: 10,
            p2: {
              p21: "Another String",
              p22: [
                5,
                6,
                "String in array",
                40,
                80
              ]
            },
            p3: "Some string"
          });
        });
        return it("filters objects - Strings are banned:", function () {
          var deepCloneBlenderOmmitingStrings, result;
          deepCloneBlenderOmmitingStrings = new _B.DeepCloneBlender({
            order: ["src"],
            "String": function (prop, src, dst, bldr) {
              return _B.Blender.SKIP;
            }
          });
          return result = expect(deepCloneBlenderOmmitingStrings.blend({}, o1, o2)).to.deep.equal({
            p1: 10,
            p2: {
              p22: [
                20,
                40
              ]
            }
          });
        });
      });
      return describe("Advanced examples:", function () {
        var o1, o2;
        o1 = {
          p1: 5,
          p2: {
            p21: function (num) {
              return num * 4;
            },
            p22: [
              5,
              "String"
            ]
          },
          p3: "Some string"
        };
        o2 = {
          p1: 10,
          p2: {
            p21: 128,
            p22: [
              20,
              40
            ]
          }
        };
        return describe("Chained BlenderBehaviors & Subclassed Blenders (are the same stuff): ", function () {
          var FunctionOverWriterBlender, UselessBlender, WeirdBlender, addingNumbersAndConcatEmToStringBlender, bi, blender, funcOverwrite, i, len, ref, results, weirdBB, weirdBlender;
          addingNumbersAndConcatEmToStringBlender = new _B.DeepCloneBlender(funcOverwrite = { "Function": "overwrite" }, weirdBB = {
            "order": [
              "dst",
              "src"
            ],
            "Function": {
              "Number": function (prop, src, dst) {
                return dst[prop](src[prop]);
              }
            },
            "Number": {
              "Number": function (prop, src, dst) {
                return dst[prop] + src[prop] * 2;
              },
              "String": function (prop, src, dst) {
                return dst[prop] + "--got a String-->:" + src[prop];
              }
            },
            "String": {
              "Number": function (prop, src, dst) {
                return dst[prop] + "--got a Numba * 3-->:" + src[prop] * 3;
              }
            }
          });
          FunctionOverWriterBlender = function (superClass) {
            extend(FunctionOverWriterBlender, superClass);
            function FunctionOverWriterBlender() {
              return FunctionOverWriterBlender.__super__.constructor.apply(this, arguments);
            }
            FunctionOverWriterBlender.behavior = funcOverwrite;
            return FunctionOverWriterBlender;
          }(_B.DeepCloneBlender);
          UselessBlender = function (superClass) {
            extend(UselessBlender, superClass);
            function UselessBlender() {
              return UselessBlender.__super__.constructor.apply(this, arguments);
            }
            return UselessBlender;
          }(FunctionOverWriterBlender);
          WeirdBlender = function (superClass) {
            extend(WeirdBlender, superClass);
            function WeirdBlender() {
              return WeirdBlender.__super__.constructor.apply(this, arguments);
            }
            WeirdBlender.behavior = weirdBB;
            return WeirdBlender;
          }(UselessBlender);
          weirdBlender = new WeirdBlender();
          ref = [
            addingNumbersAndConcatEmToStringBlender,
            weirdBlender
          ];
          results = [];
          for (bi = i = 0, len = ref.length; i < len; bi = ++i) {
            blender = ref[bi];
            it("works {}<--o1<--o2 with blender #" + bi, function () {
              return expect(blender.blend({}, o1, o2)).to.deep.equal({
                p1: 25,
                p2: {
                  p21: 128 * 4,
                  p22: [
                    45,
                    "String--got a Numba * 3-->:120"
                  ]
                },
                p3: "Some string"
              });
            });
            results.push(it("works {}<--o2<--o1 with blender #" + bi, function () {
              var result;
              return result = expect(blender.blend({}, o2, o1)).to.deep.equal({
                p1: 20,
                p2: {
                  p21: o1.p2.p21,
                  p22: [
                    30,
                    "40--got a String-->:String"
                  ]
                },
                p3: "Some string"
              });
            }));
          }
          return results;
        });
      });
    });
  });


});
define('blending/clone-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('blending/clone-spec.js');

return describe("_B.clone:", function () {
    var checkDeep, checkShallow;
    checkShallow = function (o1, o2) {
      expect(o1, o2).not.same;
      expect(o1, o2).deep.equal;
      expect(_B.isExact(o1, o2)).to.be["true"];
      expect(_B.isRefDisjoint(o1, o2)).to.be["false"];
      return _.each(o1, function (v, key) {
        return expect(o1[key]).equals(o2[key]);
      });
    };
    checkDeep = function (o1, o2) {
      expect(o1, o2).not.same;
      expect(o1, o2).deep.equal;
      expect(_B.isExact(o1, o2)).to.be["false"];
      expect(_B.isRefDisjoint(o1, o2)).to.be["true"];
      return _.each(o1, function (v, key) {
        if (!_B.isPlain(o1[key])) {
          return expect(o1[key]).not.equals(o2[key]);
        }
      });
    };
    describe("simple clonning:", function () {
      var obj;
      obj = [
        { a: 1 },
        { b: { b2: 2 } }
      ];
      it("defaults to shallow copy", function () {
        return checkShallow(obj, _B.clone(obj));
      });
      return describe("copies deep with option deep:", function () {
        it("as boolean", function () {
          return checkDeep(obj, _B.clone(obj, true));
        });
        return it("as options `deep` key", function () {
          return checkDeep(obj, _B.clone(obj, { deep: true }));
        });
      });
    });
    return describe("with copyProto:", function () {
      var Creator, creatorPrototype, obj;
      Creator = function () {
        this.a = 1;
        this.b = { b2: 2 };
        return this;
      };
      creatorPrototype = { creatorPrototype: "hereIam" };
      Creator.prototype.creatorPrototype = creatorPrototype;
      obj = new Creator();
      it("defaults to shallow copy", function () {
        var cloned;
        cloned = _B.clone(obj, { copyProto: true });
        checkShallow(obj, cloned);
        return expect(Object.getPrototypeOf(obj), Object.getPrototypeOf(cloned)).to.be.equal;
      });
      return it("with option deep", function () {
        var cloned;
        cloned = _B.clone(obj, { deep: true });
        checkDeep(obj, cloned);
        return expect(Object.getPrototypeOf(obj), Object.getPrototypeOf(cloned)).to.be.equal;
      });
    });
  });


});
define('blending/DeepDefaultsBlender-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('blending/DeepDefaultsBlender-spec.js');

var Class3, bundle, bundle_project_team, c3, earth, earth_laboratory_experiment, expectedPropertyValues, experiment, experiment_laboratory_earth, laboratory, laboratory_experiment, objectWithProtoInheritedProps, project, team;
objectWithProtoInheritedProps = data.objectWithProtoInheritedProps, Class3 = data.Class3, c3 = data.c3, expectedPropertyValues = data.expectedPropertyValues, project = data.project, team = data.team, bundle = data.bundle, bundle_project_team = data.bundle_project_team, earth = data.earth, laboratory = data.laboratory, experiment = data.experiment, earth_laboratory_experiment = data.earth_laboratory_experiment, experiment_laboratory_earth = data.experiment_laboratory_earth, laboratory_experiment = data.laboratory_experiment;
describe("Defaults: The DeepDefaultsBlender, overwritting only null/undefined & merging all nested types", function () {
  describe("Default settings:", function () {
    var deepDefaultsBlender;
    deepDefaultsBlender = new _B.DeepDefaultsBlender();
    describe("bundle, project, team:", function () {
      var result;
      result = deepDefaultsBlender.blend({}, bundle, project, team);
      it("_.isEqual result, bundle_project_team", function () {
        return expect(result).to.be.deep.equal(bundle_project_team);
      });
      return it("_.isRefDisjoint result with each of bundle, project, team", function () {
        var i, len, o, ref, results;
        ref = [
          bundle,
          project,
          team
        ];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          o = ref[i];
          results.push(expect(_B.isRefDisjoint(result, o)).to.be["true"]);
        }
        return results;
      });
    });
    describe("earth, laboratory, experiment", function () {
      var result;
      result = deepDefaultsBlender.blend({}, earth, laboratory, experiment);
      it("_.isEqual result, earth_laboratory_experiment", function () {
        return expect(result).to.be.deep.equal(earth_laboratory_experiment);
      });
      return it("_.isRefDisjoint result with each of earth, laboratory, experiment", function () {
        var i, len, o, ref, results;
        ref = [
          bundle,
          project,
          team
        ];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          o = ref[i];
          results.push(expect(_B.isRefDisjoint(result, o)).to.be["true"]);
        }
        return results;
      });
    });
    describe("experiment, laboratory, earth", function () {
      var result;
      result = deepDefaultsBlender.blend({}, experiment, laboratory, earth);
      it("_.isEqual result, experiment_laboratory_earth", function () {
        return expect(result).to.be.deep.equal(experiment_laboratory_earth);
      });
      return it("_.isRefDisjoint result with each of experiment, laboratory, earth", function () {
        var i, len, o, ref, results;
        ref = [
          experiment,
          laboratory,
          earth
        ];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          o = ref[i];
          results.push(expect(_B.isRefDisjoint(result, o)).to.be["true"]);
        }
        return results;
      });
    });
    return describe("laboratory, experiment", function () {
      var result;
      result = deepDefaultsBlender.blend({}, laboratory, experiment);
      it("_.isEqual result, laboratory_experiment", function () {
        return expect(result).to.be.deep.equal(laboratory_experiment);
      });
      return it("_.isRefDisjoint result with each of laboratory, experiment", function () {
        var i, len, o, ref, results;
        ref = [
          laboratory,
          experiment
        ];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          o = ref[i];
          results.push(expect(_B.isRefDisjoint(result, o)).to.be["true"]);
        }
        return results;
      });
    });
  });
  return describe("Using path in BlenderBehavior.order: ", function () {
    var peopleUniqueBlender, result;
    peopleUniqueBlender = new _B.DeepDefaultsBlender({
      "order": [
        "src",
        "path"
      ],
      Array: {
        life: {
          people: {
            "|": function (prop, src, dst) {
              var foundPerson, i, len, person, ref;
              ref = src[prop];
              for (i = 0, len = ref.length; i < len; i++) {
                person = ref[i];
                if (!_.isArray(dst[prop])) {
                  dst[prop] = [];
                } else {
                  foundPerson = _.find(dst[prop], function (v) {
                    return v.name === person.name;
                  });
                }
                if (!foundPerson) {
                  dst[prop].push(person);
                } else {
                  _.extend(foundPerson, person);
                }
              }
              return dst[prop];
            }
          }
        }
      }
    });
    result = peopleUniqueBlender.blend(laboratory, experiment);
    return it("_.isEqual result, laboratory_experiment", function () {
      return expect(_.isEqual(result, {
        name: "laboratoryDefaults",
        environment: {
          temperature: 35,
          moisture: { max: 40 },
          gravity: 1.5
        },
        life: {
          races: [
            "Caucasian",
            "African",
            "Asian",
            "Mutant"
          ],
          people: [
            {
              name: "moe",
              age: 400
            },
            {
              name: "larry",
              age: 500
            },
            {
              name: "blanka",
              age: 20
            },
            {
              name: "ken",
              age: 25
            },
            {
              name: "ryu",
              age: 28
            }
          ]
        },
        results: { success: false }
      })).to.be["true"];
    });
  });
});

return module.exports;

});
define('blending/shared/deepExtendExamples-specs',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('blending/shared/deepExtendExamples-specs.js');

var arrInt, arrInt2, arrStr, bundle, global, obj, project, ref;
ref = _.clone(data, true), project = ref.project, global = ref.global, bundle = ref.bundle, obj = ref.obj, arrInt = ref.arrInt, arrInt2 = ref.arrInt2, arrStr = ref.arrStr;
module.exports = function (deepExtendMergeBlend) {
  describe("deepExtend source code examples : ", function () {
    it("replaceRE allows you to concatenate strings.", function () {
      return expect(deepExtendMergeBlend({ url: "www.example.com" }, { url: "http://${_}/path/to/file.html" })).to.deep.equal({ url: "http://www.example.com/path/to/file.html" });
    });
    it("replaceRE also acts as a placeholder, which can be useful when you need to change one value in an array,\nwhile leaving the others untouched.", function () {
      return expect(deepExtendMergeBlend([
        100,
        { id: 1234 },
        true,
        "foo",
        [
          250,
          500
        ]
      ], [
        "${_}",
        "${_}",
        false,
        "${_}",
        "${_}"
      ])).to.deep.equal([
        100,
        { id: 1234 },
        false,
        "foo",
        [
          250,
          500
        ]
      ]);
    });
    it("replaceRE also acts as a placeholder, #2 ", function () {
      return expect(deepExtendMergeBlend([
        100,
        { id: 1234 },
        true,
        "foo",
        [
          250,
          500
        ]
      ], [
        "${_}",
        {},
        false,
        "${_}",
        []
      ])).to.deep.equal([
        100,
        { id: 1234 },
        false,
        "foo",
        [
          250,
          500
        ]
      ]);
    });
    it("replaceRE also acts as a placeholder, #3", function () {
      return expect(deepExtendMergeBlend([
        100,
        { id: 1234 },
        true,
        "foo",
        [
          250,
          500
        ]
      ], [
        "${_}",
        {},
        false
      ])).to.deep.equal([
        100,
        { id: 1234 },
        false,
        "foo",
        [
          250,
          500
        ]
      ]);
    });
    it("Array order is important.", function () {
      return expect(deepExtendMergeBlend([
        1,
        2,
        3,
        4
      ], [
        1,
        4,
        3,
        2
      ])).to.deep.equal([
        1,
        4,
        3,
        2
      ]);
    });
    return it("Remove Array element in destination object, by setting same index to null in a source object.", function () {
      return expect(deepExtendMergeBlend({
        arr: [
          1,
          2,
          3,
          4
        ]
      }, {
        arr: [
          "${_}",
          null,
          void 0
        ]
      })).to.deep.equal({
        arr: [
          1,
          4
        ]
      });
    });
  });
  return describe("more deepExtend examples: ", function () {
    return it("Remove Object key in destination object, by setting same key to undefined in a source object, similar to null in Array!", function () {
      return expect(deepExtendMergeBlend({
        foo: "foo",
        bar: {
          name: "bar",
          price: 20
        }
      }, {
        foo: void 0,
        bar: { price: null }
      })).to.deep.equal({ bar: { name: "bar" } });
    });
  });
};

return module.exports;

});
define('blending/shared/lodashMerge-specs',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('blending/shared/lodashMerge-specs.js');

var arrInt, arrInt2, arrStr, bundle, global, obj, project, ref;
ref = _.clone(data, true), project = ref.project, global = ref.global, bundle = ref.bundle, obj = ref.obj, arrInt = ref.arrInt, arrInt2 = ref.arrInt2, arrStr = ref.arrStr;
module.exports = function (deepExtendMergeBlend) {
  return describe("lodash.merge specs", function () {
    it("should merge `source` into the destination object", function () {
      var ages, expected, heights, names;
      names = {
        stooges: [
          { name: "moe" },
          { name: "larry" }
        ]
      };
      ages = {
        stooges: [
          { age: 40 },
          { age: 50 }
        ]
      };
      heights = {
        stooges: [
          { height: "5'4\"" },
          { height: "5'5\"" }
        ]
      };
      expected = {
        stooges: [
          {
            name: "moe",
            age: 40,
            height: "5'4\""
          },
          {
            name: "larry",
            age: 50,
            height: "5'5\""
          }
        ]
      };
      return expect(deepExtendMergeBlend(names, ages, heights)).to.deep.equal(expected);
    });
    it("should merge sources containing circular references", function () {
      var actual, object, source;
      object = {
        foo: { a: 1 },
        bar: { a: 2 }
      };
      source = {
        foo: { b: { foo: { c: {} } } },
        bar: {}
      };
      source.foo.b.foo.c = source;
      source.bar.b = source.foo.b;
      actual = deepExtendMergeBlend(object, source);
      return expect(actual.bar.b === actual.foo.b && actual.foo.b.foo.c === actual.foo.b.foo.c.foo.b.foo.c).to.be["true"];
    });
    return it("should merge problem JScript properties (test in IE < 9)", function () {
      var blended, object, source;
      object = {
        constructor: 1,
        hasOwnProperty: 2,
        isPrototypeOf: 3
      };
      source = {
        propertyIsEnumerable: 4,
        toLocaleString: 5,
        toString: 6,
        valueOf: 7
      };
      blended = deepExtendMergeBlend(object, source);
      return expect(blended).to.deep.equal({
        constructor: 1,
        hasOwnProperty: 2,
        isPrototypeOf: 3,
        propertyIsEnumerable: 4,
        toLocaleString: 5,
        toString: 6,
        valueOf: 7
      });
    });
  });
};

return module.exports;

});
define('blending/deepExtend-spec',['require', 'exports', 'module', './shared/deepExtendExamples-specs', './shared/lodashMerge-specs'], function (require, exports, module) {
  

var l = new _B.Logger('blending/deepExtend-spec.js');

if (_B.deepExtend) {
    describe("deepExtend :", function () {
      require("./shared/deepExtendExamples-specs")(_B.deepExtend);
      return require("./shared/lodashMerge-specs")(_B.deepExtend);
    });
  }
  return describe("DeepExtendBlender", function () {
    var deepExtendblender;
    deepExtendblender = new _B.DeepExtendBlender();
    return require("./shared/deepExtendExamples-specs")(deepExtendblender.blend);
  });


});
define('blending/shared/lodashMerge_Blender-specs',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('blending/shared/lodashMerge_Blender-specs.js');

var arrInt, arrInt2, arrStr, bundle, global, obj, personDetails, personDetails2, persons, project, ref;
ref = _.clone(data, true), project = ref.project, global = ref.global, bundle = ref.bundle, obj = ref.obj, arrInt = ref.arrInt, arrInt2 = ref.arrInt2, arrStr = ref.arrStr;
persons = [
  {
    name: "agelos",
    male: true
  },
  { name: "AnoDyNoS" }
];
personDetails = [
  {
    age: 37,
    address: "1 Peak Str, Earth",
    familyState: null
  },
  {
    age: 33,
    familyState: { married: false }
  }
];
personDetails2 = [
  {
    surname: "Peakoulas",
    name: "Agelos",
    age: void 0,
    address: {
      street: "1 Peak Str",
      country: "Earth"
    },
    familyState: {
      married: true,
      children: 3
    }
  },
  { job: "Dreamer, developer, doer" }
];
module.exports = function (deepExtendMergeBlend) {
  return describe("lodashMerge_Blender-specs (shared): ", function () {
    var blended;
    blended = deepExtendMergeBlend(persons, personDetails, personDetails2);
    it("'Persons' are deeply extended, overwriting from right to left.", function () {
      return expect(blended).to.deep.equal([
        {
          surname: "Peakoulas",
          name: "Agelos",
          age: 37,
          male: true,
          address: {
            street: "1 Peak Str",
            country: "Earth"
          },
          familyState: {
            married: true,
            children: 3
          }
        },
        {
          name: "AnoDyNoS",
          age: 33,
          job: "Dreamer, developer, doer",
          familyState: { married: false }
        }
      ]);
    });
    it("'Persons' === the destination/target/extended object: ", function () {
      return expect(blended).to.equal(persons);
    });
    it("merges/blends 'Object <-- Array", function () {
      var result;
      result = deepExtendMergeBlend({ property: "I am an Object" }, [
        "I am",
        "an",
        "Array"
      ]);
      return expect(result).to.deep.equal({
        property: "I am an Object",
        0: "I am",
        1: "an",
        2: "Array"
      });
    });
    it("Array <-- Object", function () {
      var expected, result;
      result = deepExtendMergeBlend([
        "I am",
        "an",
        "Array"
      ], { property: "I am an Object" });
      expected = [
        "I am",
        "an",
        "Array"
      ];
      expected.property = "I am an Object";
      return expect(result).to.deep.equal(expected);
    });
    it("'Undefined' as source is ignored", function () {
      var result;
      result = deepExtendMergeBlend([
        "I am",
        "an",
        {
          objProp: "Object property",
          anotherProp: "Another Object Property"
        }
      ], [
        void 0,
        "another",
        {
          objProp: "Object Property2",
          anotherProp: void 0
        }
      ], [
        "You are",
        void 0,
        { objProp: void 0 }
      ]);
      return expect(result).to.deep.equal([
        "You are",
        "another",
        {
          objProp: "Object Property2",
          anotherProp: "Another Object Property"
        }
      ]);
    });
    it("'Null' as source IS NOT ignored, it overwrites", function () {
      var result;
      result = deepExtendMergeBlend([
        "I am",
        "an",
        {
          objProp: "Object property",
          anotherProp: "Another Object Property"
        }
      ], [
        null,
        void 0,
        {
          objProp: "Object property",
          anotherProp: null
        }
      ]);
      return expect(result).to.deep.equal([
        null,
        "an",
        {
          objProp: "Object property",
          anotherProp: null
        }
      ]);
    });
    return it("Null / Undefined as overwritten destination", function () {
      var result;
      result = deepExtendMergeBlend([
        null,
        void 0,
        null,
        {
          objProp: "Undefined doesn't hurt me!",
          anotherProp: "null kills me!"
        }
      ], [
        111,
        null,
        void 0,
        void 0
      ], [
        null,
        "I am",
        "an",
        {
          objProp: void 0,
          anotherProp: null
        }
      ]);
      return expect(result).to.deep.equal([
        null,
        "I am",
        "an",
        {
          objProp: "Undefined doesn't hurt me!",
          anotherProp: null
        }
      ]);
    });
  });
};

return module.exports;

});
define('blending/lodash-merge-spec',['require', 'exports', 'module', './shared/lodashMerge-specs', './shared/lodashMerge_Blender-specs'], function (require, exports, module) {
  

var l = new _B.Logger('blending/lodash-merge-spec.js');

if (_B.isLodash()) {
    describe("lodash's `merge` :", function () {
      require("./shared/lodashMerge-specs")(_.merge);
      return require("./shared/lodashMerge_Blender-specs")(_.merge);
    });
  }
  return describe("lodash.merge-like blender", function () {
    var lodashMerge_like_blender;
    lodashMerge_like_blender = new _B.Blender({
      order: ["src"],
      "Undefined": function () {
        return _B.Blender.SKIP;
      }
    });
    require("./shared/lodashMerge-specs")(lodashMerge_like_blender.blend);
    return require("./shared/lodashMerge_Blender-specs")(lodashMerge_like_blender.blend);
  });


});
define('blending/Mergers_Blender-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('blending/Mergers_Blender-spec.js');

var Class3, c3, expectedPropertyValues, objectWithProtoInheritedProps;
objectWithProtoInheritedProps = data.objectWithProtoInheritedProps, Class3 = data.Class3, c3 = data.c3, expectedPropertyValues = data.expectedPropertyValues;
describe("Mergers_Blender-spec", function () {
  describe("'Blender.blend' Default settings: {inherited:false, copyProto:false}", function () {
    var defaultBlender;
    defaultBlender = new _B.Blender();
    describe("clones POJSO Object (no inheritance)", function () {
      return describe("(shallowClone = defaultBlender.blend {}, expectedPropertyValues)", function () {
        var shallowClone;
        shallowClone = defaultBlender.blend(expectedPropertyValues);
        return describe("is a shallow clone and compared to source: ", function () {
          it("is not RefDisjoint - (there is at least one common reference))", function () {
            return expect(_B.isRefDisjoint(shallowClone, expectedPropertyValues, {
              deep: true,
              inherited: true
            })).to.be["false"];
          });
          it("has common references of all nested objects", function () {
            var cRefs, sRefs;
            sRefs = _B.getRefs(expectedPropertyValues, {
              deep: true,
              inherited: true
            });
            cRefs = _B.getRefs(shallowClone, {
              deep: true,
              inherited: true
            });
            return equalSet(sRefs, cRefs);
          });
          it("has a nested object copied by reference", function () {
            equal(shallowClone.aProp1, expectedPropertyValues.aProp1);
            return expect(shallowClone.aProp1).to.not.be.an("undefined");
          });
          it("_.isEqual true (soft equality, same values/JSON)", function () {
            return expect(_.isEqual(shallowClone, expectedPropertyValues)).to.be["true"];
          });
          it("_B.isEqual true (soft equality, same values/JSON)", function () {
            return deepEqual(shallowClone, expectedPropertyValues);
          });
          return it("_B.isExact true (strict references equality)", function () {
            return exact(shallowClone, expectedPropertyValues);
          });
        });
      });
    });
    return describe("clones objectWithProtoInheritedProps (with inheritance)", function () {
      return describe("(shallowClone = defaultBlender.blend {}, objectWithProtoInheritedProps)", function () {
        var shallowIncompleteClone;
        shallowIncompleteClone = defaultBlender.blend({}, objectWithProtoInheritedProps);
        return describe("is an incomplete shallow clone, not copied inherited props: ", function () {
          it("has NOT common references of all nested objects", function () {
            var cRefs, sRefs;
            sRefs = _B.getRefs(objectWithProtoInheritedProps, {
              deep: true,
              inherited: true
            });
            cRefs = _B.getRefs(shallowIncompleteClone, {
              deep: true,
              inherited: true
            });
            return expect(_B.isDisjoint(sRefs, cRefs)).to.be["true"];
          });
          it("has NOT copied inherited nested object", function () {
            return expect(shallowIncompleteClone.aProp1 === void 0).to.be["true"];
          });
          it("_.isEqual true (soft equality, same values/JSON)", function () {
            return expect(_.isEqual(shallowIncompleteClone, objectWithProtoInheritedProps)).to.be["true"];
          });
          it("_B.isEqual true (soft equality, same values/JSON)", function () {
            return deepEqual(shallowIncompleteClone, objectWithProtoInheritedProps);
          });
          it("_B.isExact true (strict references equality, no inherited props)", function () {
            return exact(shallowIncompleteClone, objectWithProtoInheritedProps);
          });
          it("_B.isIqual false (inherited props, soft object equality)", function () {
            return notIqual(shallowIncompleteClone, objectWithProtoInheritedProps);
          });
          return it("_B.isIxact false (inherited props equality + strict references equality)", function () {
            return notIxact(shallowIncompleteClone, objectWithProtoInheritedProps);
          });
        });
      });
    });
  });
  describe("Default 'Blender.blend' with inherited:true", function () {
    var defaultBlenderInheritedCopier;
    defaultBlenderInheritedCopier = new _B.Blender([], { inherited: true });
    return describe("clones objectWithProtoInheritedProps (with inheritance)", function () {
      return describe("(shallowCloneInheritedCopied = defaultBlenderInheritedCopier.blend {}, objectWithProtoInheritedProps)", function () {
        var shallowCloneInheritedCopied;
        shallowCloneInheritedCopied = defaultBlenderInheritedCopier.blend(objectWithProtoInheritedProps);
        return describe("is a complete shallow clone, having shallow copied all inherited props: ", function () {
          it("has common references of all nested objects", function () {
            var cRefs, sRefs;
            sRefs = _B.getRefs(objectWithProtoInheritedProps, {
              deep: true,
              inherited: true
            });
            cRefs = _B.getRefs(shallowCloneInheritedCopied, {
              deep: true,
              inherited: true
            });
            return equalSet(sRefs, cRefs);
          });
          it("has copied inherited nested object", function () {
            equal(shallowCloneInheritedCopied.aProp1, objectWithProtoInheritedProps.aProp1);
            return expect(shallowCloneInheritedCopied.aProp1).to.not.be.an("undefined");
          });
          it("_.isEqual is false (soft equality, not looking at inherited props of source)", function () {
            return expect(_.isEqual(shallowCloneInheritedCopied, objectWithProtoInheritedProps)).to.be["false"];
          });
          it("_B.isEqual is false (soft equality, not looking at inherited props of source)", function () {
            return notDeepEqual(shallowCloneInheritedCopied, objectWithProtoInheritedProps);
          });
          it("_B.isExact is false (strict references equality, no inherited props of source)", function () {
            return notExact(shallowCloneInheritedCopied, objectWithProtoInheritedProps);
          });
          it("_B.isIqual is true (inherited props, soft object equality)", function () {
            return iqual(shallowCloneInheritedCopied, objectWithProtoInheritedProps);
          });
          return it("_B.isIxact true (inherited props, strict references equality)", function () {
            return ixact(shallowCloneInheritedCopied, objectWithProtoInheritedProps);
          });
        });
      });
    });
  });
  return describe("Default 'Blender.blend' with copyProto:true", function () {
    var defaultBlenderProtoCopier;
    defaultBlenderProtoCopier = new _B.Blender([], { copyProto: true });
    return describe("clones objectWithProtoInheritedProps (with inheritance)", function () {
      return describe("(shallowClone = defaultBlenderProtoCopier.blend {}, objectWithProtoInheritedProps)", function () {
        var shallowCloneProtoCopied;
        shallowCloneProtoCopied = defaultBlenderProtoCopier.blend({}, objectWithProtoInheritedProps);
        return describe("is a complete shallow clone, having shallow copied only own props & __proto__: ", function () {
          it("has ALL common references of all nested objects", function () {
            var cRefs, sRefs;
            sRefs = _B.getRefs(objectWithProtoInheritedProps, {
              deep: true,
              inherited: true
            });
            cRefs = _B.getRefs(shallowCloneProtoCopied, {
              deep: true,
              inherited: true
            });
            return equalSet(sRefs, cRefs);
          });
          it("has not copied inherited nested object, but can access it through __proto__ inheritance", function () {
            equal(shallowCloneProtoCopied.aProp1, objectWithProtoInheritedProps.aProp1);
            expect(shallowCloneProtoCopied.aProp1).to.not.be.an("undefined");
            expect(objectWithProtoInheritedProps.hasOwnProperty("aProp1")).to.be["false"];
            return expect(shallowCloneProtoCopied.hasOwnProperty("aProp1")).to.be["false"];
          });
          it("_.isEqual is true (soft equality, not looking at inherited props of either)", function () {
            return expect(_.isEqual(shallowCloneProtoCopied, objectWithProtoInheritedProps)).to.be["true"];
          });
          it("_B.isEqual is true (soft equality, not looking at inherited props of either)", function () {
            return deepEqual(shallowCloneProtoCopied, objectWithProtoInheritedProps);
          });
          it("_B.isExact is true (strict references equality, no inherited props of either)", function () {
            return exact(shallowCloneProtoCopied, objectWithProtoInheritedProps);
          });
          it("_B.isIqual is true (inherited props, soft object equality)", function () {
            return iqual(shallowCloneProtoCopied, objectWithProtoInheritedProps);
          });
          return it("_B.isIxact true (inherited props, strict references equality)", function () {
            return ixact(shallowCloneProtoCopied, objectWithProtoInheritedProps);
          });
        });
      });
    });
  });
});
describe("DeepCloneBlender .blend:", function () {
  describe("Default settings: with inherited:false, copyProto:false", function () {
    var deepCloneBlender;
    deepCloneBlender = new _B.DeepCloneBlender();
    describe("clones POJSO Object (no inheritance)", function () {
      return describe("(deepClone = deepCloneBlender.blend {}, expectedPropertyValues)", function () {
        var deepClone;
        deepClone = deepCloneBlender.blend(expectedPropertyValues);
        return describe("is a deep clone", function () {
          it("_B.isDisjoint true, NO common references in objects", function () {
            return expect(_B.isRefDisjoint(deepClone, expectedPropertyValues, {
              deep: true,
              inherited: true
            })).to.be["true"];
          });
          it("nested object is a clone it self - NOT the same reference", function () {
            return notEqual(deepClone.aProp1, expectedPropertyValues.aProp1);
          });
          it("_.isEqual true (soft equality, same values/JSON)", function () {
            return expect(_.isEqual(deepClone, expectedPropertyValues)).to.be["true"];
          });
          it("_B.isEqual true (soft equality, same values/JSON)", function () {
            return deepEqual(deepClone, expectedPropertyValues);
          });
          return it("_B.isExact is false (strict references equality)", function () {
            return notExact(deepClone, expectedPropertyValues);
          });
        });
      });
    });
    return describe("clones objectWithProtoInheritedProps (with inheritance)", function () {
      return describe("(deepIncompleteClone = deepCloneBlender.blend {}, objectWithProtoInheritedProps)", function () {
        var deepIncompleteClone;
        deepIncompleteClone = deepCloneBlender.blend({}, objectWithProtoInheritedProps);
        return describe("is an incomplete deep clone, not copied inherited props: ", function () {
          it("_B.isDisjoint true, has NO common references of all nested objects", function () {
            return expect(_B.isRefDisjoint(objectWithProtoInheritedProps, deepIncompleteClone, {
              deep: true,
              inherited: true
            })).to.be["true"];
          });
          it("has NOT copied inherited nested object", function () {
            return expect(deepIncompleteClone.aProp1 === void 0).to.be["true"];
          });
          describe("equality of deepIncompleteClone, objectWithProtoInheritedProps", function () {
            it("_.isEqual true (soft equality, same values/JSON)", function () {
              return expect(_.isEqual(deepIncompleteClone, objectWithProtoInheritedProps)).to.be["true"];
            });
            it("_B.isEqual true (soft equality, same values/JSON)", function () {
              return deepEqual(deepIncompleteClone, objectWithProtoInheritedProps);
            });
            it("_B.isIqual false (inherited props)", function () {
              return notIqual(deepIncompleteClone, objectWithProtoInheritedProps);
            });
            it("_B.isExact true (strict references equality)", function () {
              return exact(deepIncompleteClone, objectWithProtoInheritedProps);
            });
            return it("_B.isIxact false (inherited props, scrict references equality)", function () {
              return notIxact(deepIncompleteClone, objectWithProtoInheritedProps);
            });
          });
          return describe("equality of deepInheritedClone, expectedPropertyValues", function () {
            it("_.isEqual false (soft equality, same values/JSON)", function () {
              return expect(_.isEqual(deepIncompleteClone, expectedPropertyValues)).to.be["false"];
            });
            it("_B.isEqual false (soft equality, same values/JSON)", function () {
              return notDeepEqual(deepIncompleteClone, expectedPropertyValues);
            });
            it("_B.isIqual false (inherited props)", function () {
              return notIqual(deepIncompleteClone, expectedPropertyValues);
            });
            it("_B.isExact false (strict references equality)", function () {
              return notExact(deepIncompleteClone, expectedPropertyValues);
            });
            return it("_B.isIxact false (inherited props, scrict references equality)", function () {
              return notIxact(deepIncompleteClone, expectedPropertyValues);
            });
          });
        });
      });
    });
  });
  return describe("with inherited:true :", function () {
    var deepCloneInheritedBlender;
    deepCloneInheritedBlender = new _B.DeepCloneBlender([], { inherited: true });
    describe("clones objectWithProtoInheritedProps (with inheritance)", function () {
      return describe("(deepInheritedClone = deepCloneInheritedBlender .blend {}, objectWithProtoInheritedProps)", function () {
        var deepInheritedClone;
        deepInheritedClone = deepCloneInheritedBlender.blend(objectWithProtoInheritedProps);
        return describe("is a complete deep clone, having deep cloned all inherited props as its own: ", function () {
          it("_B.isDisjoint true, has NO common references of all nested objects", function () {
            return expect(_B.isRefDisjoint(objectWithProtoInheritedProps, deepInheritedClone, {
              deep: true,
              inherited: true
            })).to.be["true"];
          });
          describe("equality of deepInheritedClone, objectWithProtoInheritedProps", function () {
            it("_.isEqual false (soft equality, not looking at inherited props of either)", function () {
              return expect(_.isEqual(deepInheritedClone, objectWithProtoInheritedProps)).to.be["false"];
            });
            it("_B.isEqual false (soft equality, not looking at inherited props of either)", function () {
              return notDeepEqual(deepInheritedClone, objectWithProtoInheritedProps);
            });
            it("_B.isIqual true (soft equality, inherited props)", function () {
              return iqual(deepInheritedClone, objectWithProtoInheritedProps);
            });
            it("_B.isExact false (strict references equality)", function () {
              return notExact(deepInheritedClone, objectWithProtoInheritedProps);
            });
            return it("_B.isIxact false (inherited props, scrict references equality)", function () {
              return notIxact(deepInheritedClone, objectWithProtoInheritedProps);
            });
          });
          return describe("equality of deepInheritedClone, expectedPropertyValues", function () {
            it("_.isEqual true (soft equality, all props are equal )", function () {
              return deepEqual(deepInheritedClone, expectedPropertyValues);
            });
            it("_B.isEqual true (soft equality, all props are equal)", function () {
              return deepEqual(deepInheritedClone, expectedPropertyValues);
            });
            it("_B.isIqual true (soft equality, inherited props, all props are equal)", function () {
              return iqual(deepInheritedClone, expectedPropertyValues);
            });
            it("_B.isExact false (strict references equality)", function () {
              return notExact(deepInheritedClone, expectedPropertyValues);
            });
            return it("_B.isIxact false (inherited props, scrict references equality)", function () {
              return notIxact(deepInheritedClone, expectedPropertyValues);
            });
          });
        });
      });
    });
    return describe("Using ['path'] orders in BlenderBehavior:", function () {
      var bi, blender, blenders, expected, i, len, o1, o2, results;
      blenders = [];
      blenders.push(new _B.DeepCloneBlender([{
          order: [
            "dst",
            "path",
            "src"
          ],
          String: {
            bundle: {
              basics: {
                "|": {
                  String: function (prop, src, dst, blender) {
                    return _B.Blender.SKIP;
                  }
                }
              }
            }
          }
        }], { isExactPath: false }));
      blenders.push(new _B.DeepCloneBlender([{
          order: [
            "path",
            "src",
            "dst"
          ],
          bundle: {
            basics: {
              "|": {
                String: {
                  String: function (prop, src, dst, blender) {
                    return _B.Blender.SKIP;
                  }
                }
              }
            }
          }
        }], { isExactPath: false }));
      blenders.push(new _B.DeepCloneBlender([{
          order: [
            "path",
            "src",
            "dst"
          ],
          "bundle : basics": {
            "|": {
              String: {
                String: function (prop, src, dst, blender) {
                  return _B.Blender.SKIP;
                }
              }
            }
          }
        }], { isExactPath: false }));
      blenders.push(new _B.DeepCloneBlender([{
          order: [
            "src",
            "dst",
            "path"
          ],
          String: {
            String: {
              " bundle: basics": {
                "|": function (prop, src, dst, blender) {
                  return _B.Blender.SKIP;
                }
              }
            }
          }
        }], { isExactPath: false }));
      blenders.push(new _B.DeepCloneBlender([{
          order: [
            "src",
            "dst",
            "path"
          ],
          String: {
            String: {
              bundle: {
                basics: {
                  "|": function (prop, src, dst, blender) {
                    return _B.Blender.SKIP;
                  }
                }
              }
            }
          }
        }], { isExactPath: false }));
      o1 = {
        bundle: {
          someOkString: "OLD String#1",
          someOkStrings: [
            "OLD [String]#1",
            "OLD [String]#2"
          ],
          basics: {
            newString2: 665,
            someObject: { skippedString: "OLD string #2" },
            skippedString: "OLD string #3",
            skippedStrings: [
              "OLD [String]#3",
              "OLD [String]#4"
            ],
            anIntAsString: "665",
            anInt: 8
          }
        }
      };
      o2 = {
        bundle: {
          someOkString: "OVERWRITTEN String#1",
          someOkStrings: [
            "OVERWRITTEN [String]#1",
            "OVERWRITTEN [String]#2"
          ],
          basics: {
            newString: "I am a OVERWRITTEN String, but on `undefined <-- String`, so I am ok!",
            newString2: "I am a OVERWRITTEN String, but on `Number <-- String`, so I am ok!",
            someObject: { skippedString: "SKIPed string #2" },
            skippedString: "SKIPed string #3",
            skippedStrings: [
              "SKIPed [String]#3",
              "SKIPed [String]#4"
            ],
            anIntAsString: 77,
            anInt: "18"
          }
        }
      };
      expected = {
        bundle: {
          someOkString: "OVERWRITTEN String#1",
          someOkStrings: [
            "OVERWRITTEN [String]#1",
            "OVERWRITTEN [String]#2"
          ],
          basics: {
            newString: "I am a OVERWRITTEN String, but on `undefined <-- String`, so I am ok!",
            newString2: "I am a OVERWRITTEN String, but on `Number <-- String`, so I am ok!",
            someObject: { skippedString: "OLD string #2" },
            skippedString: "OLD string #3",
            skippedStrings: [
              "OLD [String]#3",
              "OLD [String]#4"
            ],
            anIntAsString: 77,
            anInt: "18"
          }
        }
      };
      results = [];
      for (bi = i = 0, len = blenders.length; i < len; bi = ++i) {
        blender = blenders[bi];
        results.push(it("_.isEqual is true for blender #" + bi, function () {
          var result;
          result = blender.blend({}, o1, o2);
          return expect(_.isEqual(result, expected)).to.be["true"];
        }));
      }
      return results;
    });
  });
});

return module.exports;

});
define('blending/traverse-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('blending/traverse-spec.js');

describe("traverse:", function () {
  var o;
  o = {
    a: {
      a1: { a1_1: { a1_1_1: 111 } },
      a2: {
        bingo: true,
        a2_1: { a2_1_1: 211 }
      }
    },
    b: 2
  };
  it("traverses nested objects", function () {
    var props;
    props = [];
    _B.traverse(o, function (prop, src, blender) {
      return props.push(prop);
    });
    return expect(props).to.be.deep.equal([
      "a",
      "a1",
      "a1_1",
      "a2",
      "a2_1"
    ]);
  });
  return it("quits branch if callback returns false", function () {
    var props;
    props = [];
    _B.traverse(o, function (prop, src, blender) {
      props.push(prop);
      if (src[prop].bingo === true) {
        return false;
      }
    });
    return expect(props).to.be.deep.equal([
      "a",
      "a1",
      "a1_1",
      "a2"
    ]);
  });
});

return module.exports;

});
define('collections/array/arrayize-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('collections/array/arrayize-spec.js');

var arrInt, arrInt2, arrStr, bundle, global, obj, project, ref;
ref = _.clone(data, true), project = ref.project, global = ref.global, bundle = ref.bundle, obj = ref.obj, arrInt = ref.arrInt, arrInt2 = ref.arrInt2, arrStr = ref.arrStr;
describe("arrayize :", function () {
  it("arrayize a String", function () {
    return expect(_B.arrayize("agelos")).to.deep.equal(["agelos"]);
  });
  it("arrayize a Number", function () {
    return expect(_B.arrayize(19)).to.deep.equal([19]);
  });
  it("arrayize an Object", function () {
    return expect(_B.arrayize({
      a: 1,
      b: 2
    })).to.deep.equal([{
        a: 1,
        b: 2
      }]);
  });
  it("arrayize an existing array", function () {
    var arr;
    arr = [
      1,
      "john"
    ];
    return expect(_B.arrayize(arr)).to.equal(arr);
  });
  return it("arrayize nothingness", function () {
    return expect(_B.arrayize(void 0)).to.deep.equal([]);
  });
});

return module.exports;

});
define('collections/array/isEqualArraySet-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('collections/array/isEqualArraySet-spec.js');

var arrInt, arrInt2, arrStr, obj, ref;
ref = _.clone(data, true), obj = ref.obj, arrInt = ref.arrInt, arrInt2 = ref.arrInt2, arrStr = ref.arrStr;
describe("isEqualArraySet :", function () {
  it("simple arrays with primitives", function () {
    return expect(_B.isEqualArraySet([
      1,
      2,
      3,
      "John",
      "Doe"
    ], [
      "John",
      3,
      "Doe",
      2,
      1
    ])).to.be["true"];
  });
  return it("arrays with primitives & references", function () {
    return expect(_B.isEqualArraySet([
      obj,
      arrInt,
      arrStr,
      2,
      3,
      "John",
      "Doe"
    ], [
      obj,
      "John",
      arrInt,
      3,
      arrStr,
      "Doe",
      2
    ])).to.be["true"];
  });
});

return module.exports;

});
define('Logger-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('Logger-spec.js');

describe("Logger debug():", function () {
  describe("simple cases, no maxDebugLevel or pathLevels", function () {
    before(function () {
      delete _B.Logger.debugPathsLevels;
      return delete _B.Logger.maxDebugLevel;
    });
    describe("default instance debugLevel = 1:", function () {
      var l;
      l = new _B.Logger();
      describe("test debug() :", function () {
        it("default debug() level is also 1:", function () {
          return expect(l.deb("something")).to.be.not.undefined;
        });
        it("does debug() for level 0 or 1:", function () {
          expect(l.deb(0, "something")).to.be.not.undefined;
          return expect(l.deb(1, "something")).to.be.not.undefined;
        });
        return it("not debug() for level > 1:", function () {
          return expect(l.deb(2, "something")).to.be.undefined;
        });
      });
      return describe("test deb(level) on default debugLevel :", function () {
        it("is true for ded(0) or deb(1):", function () {
          expect(l.deb(0)).to.be["true"];
          expect(l.deb("something")).to.be.not.undefined;
          expect(l.deb(1)).to.be["true"];
          return expect(l.deb("something")).to.be.not.undefined;
        });
        return it("not debug() for level > 1:", function () {
          expect(l.deb(2)).to.be["false"];
          return expect(l.deb("something")).to.be.undefined;
        });
      });
    });
    describe("set debugLevel instance level = 0:", function () {
      var l;
      l = new _B.Logger("title", 0);
      it("not debug() for default level = 1 :", function () {
        return expect(l.deb("something")).to.be.undefined;
      });
      it("does debug() for explicit level = 0 :", function () {
        return expect(l.deb(0, "something")).to.be.not.undefined;
      });
      return it("not debug() for default level >= 1 :", function () {
        expect(l.deb(1, "something")).to.be.undefined;
        return expect(l.deb(2, "something")).to.be.undefined;
      });
    });
    return describe("test deb(level) on user set debugLevel = 30:", function () {
      var l;
      l = new _B.Logger("title", 30);
      it("is true for ded(0) or deb(1):", function () {
        expect(l.deb(0)).to.be["true"];
        expect(l.deb("something")).to.be.not.undefined;
        expect(l.deb(30)).to.be["true"];
        return expect(l.deb("something")).to.be.not.undefined;
      });
      return it("not debug() for level > 30:", function () {
        expect(l.deb(31)).to.be["false"];
        return expect(l.deb("something")).to.be.undefined;
      });
    });
  });
  return describe("With debug Path Levels, even as Number parsable strings:", function () {
    before(function () {
      delete _B.Logger.debugPathsLevels;
      _B.Logger.addDebugPathLevel("foo/bar/froo", "60");
      _B.Logger.addDebugPathLevel("foo/bar", "40");
      _B.Logger.addDebugPathLevel("foo/", 10);
      return _B.Logger.addDebugPathLevel("baz/faux", 12);
    });
    it("correctly sets _B.Logger.debugPathsLevels, as Numbers", function () {
      return expect(_B.Logger.debugPathsLevels).to.be.deep.equal({
        foo: {
          _level: 10,
          bar: {
            _level: 40,
            froo: { _level: 60 }
          }
        },
        baz: { faux: { _level: 12 } }
      });
    });
    it("throws Error if debugLevel is not parsable Number", function () {
      return expect(function () {
        return _B.Logger.addDebugPathLevel("baz/faux", "blah012");
      }).to["throw"](Error, /debugLevel 'blah012' isNaN (Not a Number or not Number parsable)*/);
    });
    describe("without Logger.maxDebugLevel  ", function () {
      describe("getDebugPathLevel() gets the closest _level:", function () {
        it("level of last common path", function () {
          var l;
          l = new _B.Logger("foo/bar/joe/doe");
          return expect(l.getDebugPathLevel()).to.equal(40);
        });
        it("level of exact common path #1", function () {
          var l;
          l = new _B.Logger("/foo");
          return expect(l.getDebugPathLevel()).to.equal(10);
        });
        it("level of exact common path #2", function () {
          var l;
          l = new _B.Logger("baz/faux/");
          return expect(l.getDebugPathLevel()).to.equal(12);
        });
        it("level of inexistent path", function () {
          var l;
          l = new _B.Logger("blah/blah/");
          return expect(l.getDebugPathLevel()).to.be.undefined;
        });
        return it("matching any path on root", function () {
          var l;
          _B.Logger.addDebugPathLevel("/", 5);
          l = new _B.Logger("blah/blah/");
          return expect(l.getDebugPathLevel()).to.be.equal(5);
        });
      });
      describe("logger instance without debugLevel", function () {
        var l;
        l = new _B.Logger("foo/bar/joe/doe");
        it("is true for ded(<=30) :", function () {
          expect(l.deb(0)).to.be["true"];
          expect(l.deb("something")).to.be.not.undefined;
          expect(l.deb(1)).to.be["true"];
          expect(l.deb("something")).to.be.not.undefined;
          expect(l.deb(30)).to.be["true"];
          return expect(l.deb("something")).to.be.not.undefined;
        });
        return it("not debug() for level > 40:", function () {
          expect(l.deb(41)).to.be["false"];
          return expect(l.deb("something")).to.be.undefined;
        });
      });
      describe("logger instance debugLevel = 50 is respected", function () {
        var l;
        l = new _B.Logger("foo/bar/joe/doe", 50);
        it("is true for ded(<=50) :", function () {
          expect(l.deb(0)).to.be["true"];
          expect(l.deb("something")).to.be.not.undefined;
          expect(l.deb(1)).to.be["true"];
          expect(l.deb("something")).to.be.not.undefined;
          expect(l.deb(50)).to.be["true"];
          return expect(l.deb("something")).to.be.not.undefined;
        });
        return it("not debug() for level > 40:", function () {
          expect(l.deb(51)).to.be["false"];
          return expect(l.deb("something")).to.be.undefined;
        });
      });
      return describe("logger instance debugLevel = 0 is respected:", function () {
        var l;
        l = new _B.Logger("foo/bar/joe/doe", 0);
        it("is true for ded(=0) :", function () {
          expect(l.deb(0)).to.be["true"];
          return expect(l.deb("something")).to.be.not.undefined;
        });
        return it("is false for ded(>0) :", function () {
          expect(l.deb(1)).to.be["false"];
          expect(l.deb("something")).to.be.undefined;
          expect(l.deb(50)).to.be["false"];
          expect(l.deb("something")).to.be.undefined;
          expect(l.deb(51)).to.be["false"];
          return expect(l.deb("something")).to.be.undefined;
        });
      });
    });
    return describe("with Logger.maxDebugLevel = 20 always respected as upper limit :", function () {
      before(function () {
        return _B.Logger.maxDebugLevel = 20;
      });
      describe("logger instance without debugLevel", function () {
        var l;
        l = new _B.Logger("foo/bar/joe/doe");
        it("l.getDebugPathLevel()", function () {
          return expect(l.getDebugPathLevel()).to.equal(40);
        });
        it("is true for ded( <= Logger.maxDebugLevel = 20) :", function () {
          expect(l.deb(0)).to.be["true"];
          expect(l.deb("something")).to.be.not.undefined;
          expect(l.deb(1)).to.be["true"];
          expect(l.deb("something")).to.be.not.undefined;
          expect(l.deb(20)).to.be["true"];
          return expect(l.deb("something")).to.be.not.undefined;
        });
        return it("not debug() for level > Logger.maxDebugLevel  = 20:", function () {
          expect(l.deb(21)).to.be["false"];
          return expect(l.deb("something")).to.be.undefined;
        });
      });
      return describe("logger instance with debugLevel = 50", function () {
        var l;
        l = new _B.Logger("foo/bar/joe/doe", 50);
        it("l.getDebugPathLevel()", function () {
          return expect(l.getDebugPathLevel()).to.equal(40);
        });
        it("is true for ded(<=20) :", function () {
          expect(l.deb(0)).to.be["true"];
          expect(l.deb("something")).to.be.not.undefined;
          expect(l.deb(1)).to.be["true"];
          expect(l.deb("something")).to.be.not.undefined;
          expect(l.deb(20)).to.be["true"];
          return expect(l.deb("something")).to.be.not.undefined;
        });
        return it("not debug() for level > 20:", function () {
          expect(l.deb(21)).to.be["false"];
          return expect(l.deb("something")).to.be.undefined;
        });
      });
    });
  });
});

return module.exports;

});
define('objects/getInheritedPropertyNames-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('objects/getInheritedPropertyNames-spec.js');

var Class3, objectWithProtoInheritedProps;
objectWithProtoInheritedProps = data.objectWithProtoInheritedProps, Class3 = data.Class3;
describe("getInheritedPropertyNames: ", function () {
  it("reads property names of __proro__ linked object hierarchy", function () {
    var inheritedProps;
    inheritedProps = _B.getInheritedPropertyNames(objectWithProtoInheritedProps);
    return equalSet(inheritedProps, [
      "aProp1",
      "aProp2",
      "aProp3"
    ]);
  });
  return it("reads property names of coffeescript class-inherited objects", function () {
    return equalSet(_B.getInheritedPropertyNames(new Class3()), [
      "aProp3",
      "aProp2",
      "aProp1"
    ]);
  });
});

return module.exports;

});
define('objects/getp-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('objects/getp-spec.js');

describe("objects/getp ", function () {
  var o;
  o = {
    "$": {
      bundle: {
        anArray: [
          "arrayItem1",
          2,
          { "arrayItem3": 3 }
        ],
        "*": { IamA: "defaultValue" },
        dependencies: { depsVars: "Bingo" },
        someOtherKey: {
          "*": { notReached: "defaultValue" },
          "#": { IamA: { Stop: "Value" } }
        },
        leadingToTerminate: {
          "|": { terminated: "terminated value" },
          someKey: { someOtherKey: "someValue" }
        }
      }
    }
  };
  describe("basic tests - retrieving value: ", function () {
    it("primitive", function () {
      return expect(_B.getp(o, "$/bundle/dependencies/depsVars")).to.deep.equal("Bingo");
    });
    it("object", function () {
      return expect(_B.getp(o, "$/bundle/dependencies")).to.deep.equal({ depsVars: "Bingo" });
    });
    it("object, with sep at end", function () {
      return expect(_B.getp(o, "$/bundle/dependencies/")).to.deep.equal({ depsVars: "Bingo" });
    });
    it("array item (3rd)", function () {
      return expect(_B.getp(o, "$/bundle/anArray/2/")).to.deep.equal({ "arrayItem3": 3 });
    });
    it("property of (3rd) array item ", function () {
      return expect(_B.getp(o, "$/bundle/anArray/2/arrayItem3")).to.deep.equal(3);
    });
    it("object, with alternative sep", function () {
      return expect(_B.getp(o, "$.bundle.dependencies.", { separator: "." })).to.deep.equal({ depsVars: "Bingo" });
    });
    it("undefined, for non existent key", function () {
      return expect(_B.getp(o, "$/bundle/dependencies/depsVars/notfound")).to.deep.equal(void 0);
    });
    return it("undefined, for path of inexistent keys, with alt sep", function () {
      return expect(_B.getp(o, "$>bundle>dependencies>depsVars>notfound>stillNotFound>", { separator: ">" })).to.deep.equal(void 0);
    });
  });
  describe("retrieving value using *defaultKey*:", function () {
    it("non existent key, but a defaultKey in its place", function () {
      return expect(_B.getp(o, "$/bundle/someNonFoundKey/")).to.deep.equal({ IamA: "defaultValue" });
    });
    it("non existent key, but a defaultKey in its place, goin on", function () {
      return expect(_B.getp(o, "$/bundle/someNonFoundKey/IamA")).to.deep.equal("defaultValue");
    });
    return it("non existent key, but a defaultKey in its palce, went too far", function () {
      return expect(_B.getp(o, "$/bundle/someNonFoundKey/tooFar")).to.deep.equal(void 0);
    });
  });
  describe("retrieving value using *stopKey*:", function () {
    it("non existent key, but a stopKey key in its place - defaultKey is ignored", function () {
      return expect(_B.getp(o, "$/bundle/someOtherKey/someNonFoundKey/")).to.deep.equal({ IamA: { Stop: "Value" } });
    });
    it("non existent key, a terminal in its place, going on dosn't matter", function () {
      return expect(_B.getp(o, "$/bundle/someOtherKey/someNonFoundKey/notReached")).to.deep.equal({ IamA: { Stop: "Value" } });
    });
    return it("non existent key, a stopKey key in its place, going too far dosn't matter", function () {
      return expect(_B.getp(o, "$/bundle/someOtherKey/someNonFoundKey/goingTooFar/IsIgnored/")).to.deep.equal({ IamA: { Stop: "Value" } });
    });
  });
  describe("retrieving value using *terminateKey*:", function () {
    it("non existent key, but a terminateKey in its place, returns {terminateKey:value}", function () {
      return expect(_B.getp(o, "$/bundle/leadingToTerminate/someNonFoundKey/", { terminateKey: "|" })).to.deep.equal({ "|": { terminated: "terminated value" } });
    });
    return it("existent key path, but found a terminateKey while walking, returns {terminateKey:value}", function () {
      return expect(_B.getp(o, "$/bundle/leadingToTerminate/someKey/someOtherKey", { terminateKey: "|" })).to.deep.equal({ "|": { terminated: "terminated value" } });
    });
  });
  return describe("retrieving value using *isReturnLast*, returns last value found:", function () {
    return it("non existent key, returns last value", function () {
      return expect(_B.getp(o, "$/bundle/dependencies/someNonFoundKey/", { isReturnLast: true })).to.deep.equal({ depsVars: "Bingo" });
    });
  });
});

return module.exports;

});
define('objects/getRefs-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('objects/getRefs-spec.js');

describe("getRefs:", function () {
  it("from array, deep = false", function () {
    var oa;
    oa = [
      0,
      1,
      { p: [{ PP: 3 }] },
      {
        a: {
          b: function () {
          }
        }
      },
      4
    ];
    return equalSet(_B.getRefs(oa), [
      oa[3],
      oa[2]
    ]);
  });
  it("from array, deep = true:", function () {
    var oa;
    oa = [
      0,
      1,
      { p: [{ PP: 3 }] },
      {
        a: {
          b: function () {
          }
        }
      },
      4
    ];
    return equalSet(_B.getRefs(oa, { deep: true }), [
      oa[2],
      oa[2].p,
      oa[2].p[0],
      oa[3],
      oa[3].a,
      oa[3].a.b
    ]);
  });
  return it("from object, deep = true:", function () {
    var oa;
    oa = {
      p0: 0,
      p1: 1,
      p2: { p: [{ PP: 3 }] },
      p3: {
        a: {
          b: function () {
          }
        }
      },
      p4: 4
    };
    return equalSet(_B.getRefs(oa, { deep: true }), [
      oa.p2.p,
      oa.p2.p[0],
      oa.p2,
      oa.p3,
      oa.p3.a,
      oa.p3.a.b
    ]);
  });
});

return module.exports;

});
define('objects/isDisjoint-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('objects/isDisjoint-spec.js');

describe("isDisjoint:", function () {
  describe("with primitives:", function () {
    describe("arrays:", function () {
      it("recognises disjoint:", function () {
        expect(_B.isDisjoint([
          1,
          2,
          3
        ], [
          4,
          5,
          6,
          "1"
        ])).to.be["true"];
        return expect(_.intersection([
          1,
          2,
          3
        ], [
          4,
          5,
          6,
          "1"
        ])).to.be.an("array").and.is.empty;
      });
      return it("recognises non disjoint:", function () {
        expect(_B.isDisjoint([
          1,
          2,
          3
        ], [
          4,
          2,
          5
        ])).to.be["false"];
        return expect(_.intersection([
          1,
          2,
          3
        ], [
          4,
          2,
          5
        ])).to.deep.equal([2]);
      });
    });
    return describe("arrays & objects:", function () {
      it("recognises disjoint in [] & {}:", function () {
        return expect(_B.isDisjoint([
          4,
          5,
          6
        ], {
          a: 1,
          b: 7,
          c: 8
        })).to.be["true"];
      });
      return it("recognises non disjoint in [] & {}:", function () {
        return expect(_B.isDisjoint([
          1,
          2,
          3
        ], {
          a: 1,
          b: 7,
          c: 8
        })).to.be["false"];
      });
    });
  });
  return describe("with references:", function () {
    var o1, o2, o3, o4;
    o1 = { p1: 1 };
    o2 = { p2: 2 };
    o3 = { p3: 3 };
    o4 = { p4: 4 };
    describe("arrays:", function () {
      it("recognises disjoint:", function () {
        expect(_B.isDisjoint([
          o1,
          o2
        ], [
          { p1: 1 },
          o3,
          o4
        ])).to.be["true"];
        return expect(_.intersection([
          o1,
          o2
        ], [
          { p1: 1 },
          o3,
          o4
        ])).to.deep.equal([]);
      });
      return it("recognises non disjoint:", function () {
        expect(_B.isDisjoint([
          o1,
          o2
        ], [
          { p1: 1 },
          o3,
          o4,
          o2
        ])).to.be["false"];
        return expect(_.intersection([
          o1,
          o2
        ], [
          { p1: 1 },
          o3,
          o4,
          o2
        ])).to.deep.equal([o2]);
      });
    });
    describe("arrays & objects:", function () {
      it("recognises disjoint in [] & {}", function () {
        return expect(_B.isDisjoint([
          o1,
          o2
        ], {
          p1: 1,
          o3: o3,
          o4: o4
        })).to.be["true"];
      });
      return it("recognises non disjoint in [] & {}:", function () {
        return expect(_B.isDisjoint([
          o1,
          o2
        ], {
          p1: 1,
          o3: o3,
          o4: o4,
          o2: o2
        })).to.be["false"];
      });
    });
    return describe("equality using _.isEqual :", function () {
      it("recognises disjoint in [] & {}, without _.isEqual", function () {
        return expect(_B.isDisjoint([
          o1,
          o2
        ], {
          someP: { p1: 1 },
          o3: o3
        })).to.be["true"];
      });
      return it("recognises non disjoint in [] & {}, when using _.isEqual", function () {
        return expect(_B.isDisjoint([
          o1,
          o2
        ], {
          someP: { p1: 1 },
          o3: o3
        }, _.isEqual)).to.be["false"];
      });
    });
  });
});

return module.exports;

});
define('objects/isEqual-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('objects/isEqual-spec.js');

var Class3, c3, c3Clone, expectedPropertyValues, inheritedDeepClone, inheritedShallowClone, l, oClone, object, objectDeepClone1, objectDeepClone2, objectShallowClone1, objectShallowClone2, objectWithProtoInheritedProps;
objectWithProtoInheritedProps = data.objectWithProtoInheritedProps, Class3 = data.Class3, c3 = data.c3, expectedPropertyValues = data.expectedPropertyValues, object = data.object, objectShallowClone1 = data.objectShallowClone1, objectShallowClone2 = data.objectShallowClone2, objectDeepClone1 = data.objectDeepClone1, objectDeepClone2 = data.objectDeepClone2, inheritedShallowClone = data.inheritedShallowClone, inheritedDeepClone = data.inheritedDeepClone;
oClone = _.clone(objectWithProtoInheritedProps);
c3Clone = _.clone(c3);
l = new _B.Logger("spec/objects/isEqual");
describe("isEqual:", function () {
  describe("lodash _.isEqual tests on _B.isEqual:", function () {
    it("should work with `arguments` objects (test in IE < 9)", function () {
      var args1, args2, args3;
      args1 = function () {
        return arguments;
      }(1, 2, 3);
      args2 = function () {
        return arguments;
      }(1, 2, 3);
      args3 = function () {
        return arguments;
      }(1, 2);
      expect(_B.isEqual(args1, args2)).to.be["true"];
      if (!(window.PHANTOMJS || window.mochaPhantomJS)) {
        expect(_B.isEqual(args1, args3)).to.be["false"];
      }
      if (_B.isLodash()) {
        expect(_B.isEqual(args1, {
          "0": 1,
          "1": 2,
          "2": 3
        })).to.be["true"];
      }
      if (!(window.PHANTOMJS || window.mochaPhantomJS)) {
        return expect(_B.isEqual(args1, [
          1,
          2,
          3
        ])).to.be["false"];
      }
    });
    it("should return `false` when comparing values with circular references to unlike values", function () {
      var array1, array2, object1, object2;
      array1 = [
        "a",
        null,
        "c"
      ];
      array2 = [
        "a",
        [],
        "c"
      ];
      object1 = {
        a: 1,
        b: null,
        c: 3
      };
      object2 = {
        a: 1,
        b: {},
        c: 3
      };
      array1[1] = array1;
      expect(_B.isEqual(array1, array2)).to.be["false"];
      object1.b = object1;
      return expect(_B.isEqual(object1, object2)).to.be["false"];
    });
    if (_B.isLodash()) {
      return describe("callback (lodash only):", function () {
        it("respects returning true", function () {
          return expect(_B.isEqual(111, "111", function (a, b) {
            return a + "" === b + "";
          })).to.be["true"];
        });
        it("is undecided if callback returns undefined", function () {
          var a, b;
          a = {
            a: "a",
            b: "b",
            c: "EQUAL",
            d: 4
          };
          b = {
            a: "a",
            b: "b",
            c: { d: "Not really equal, but assumed as so" },
            d: 4
          };
          return expect(_B.isEqual(a, b, function (a, b) {
            if (a === "EQUAL") {
              return true;
            } else {
              return void 0;
            }
          })).to.be["true"];
        });
        it("options are passed to lodash's _.isEqual (called internally if no options)", function () {
          var a, b;
          a = {
            a: "a",
            b: "b",
            c: 4
          };
          b = {
            a: "a",
            b: "b",
            c: 4
          };
          return expect(_B.isEqual(a, b, function (a, b, options) {
            if (!_.isEqual(options, _B.isEqual.defaults)) {
              return false;
            }
          })).to.be["true"];
        });
        it("options with callback & ctx are passed to _B.isEqual (with options)", function () {
          var a, b, ctx, opts;
          a = {
            a: "a",
            b: "b",
            c: 4
          };
          b = {
            a: "a",
            b: "b",
            c: 4
          };
          ctx = {};
          return expect(_B.isEqual(a, b, opts = {
            path: [],
            callback: function (a, b, options) {
              if (options !== opts || this !== ctx) {
                return false;
              }
            }
          }, ctx)).to.be["true"];
        });
        it("should pass the correct arguments (ctx & options) to `callback`", function () {
          var args, cb, ctx;
          args = void 0;
          cb = function () {
          };
          ctx = {};
          expect(_B.isEqual("a", "b", function () {
            args = [].slice.call(arguments);
            return this === ctx;
          }, ctx)).to.be["true"];
          return expect(args).to.be.deep.equal([
            "a",
            "b",
            _B.isEqual.defaults
          ]);
        });
        it("should correct set the `this` binding", function () {
          return expect(_B.isEqual("a", "b", function (a, b) {
            return this[a] === this[b];
          }, {
            a: 1,
            b: 1
          })).to.be["true"];
        });
        it("should handle comparisons if `callback` returns `undefined`", function () {
          expect(_B.isEqual("a", "a", function () {
          })).to.be["true"];
          return expect(_B.isEqual("a", "b", function () {
          })).to.be["false"];
        });
        it("should treat all truthy as true ", function () {
          var i, len, ref, results, truthy;
          ref = [
            "hey",
            {},
            [],
            1,
            true
          ];
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            truthy = ref[i];
            results.push(function (truthy) {
              return expect(_B.isEqual("a", "b", function () {
                return truthy;
              })).to.be["true"];
            }(truthy));
          }
          return results;
        });
        return it("should treat all falsey (except undefined) as false ", function () {
          var falsey, i, len, ref, results;
          ref = [
            "",
            0,
            NaN,
            null
          ];
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            falsey = ref[i];
            results.push(function (falsey) {
              return expect(_B.isEqual("a", "a", function () {
                return falsey;
              })).to.be["false"];
            }(falsey));
          }
          return results;
        });
      });
    }
  });
  describe("rudimentary checks:", function () {
    describe("primitives:", function () {
      it("one undefined", function () {
        expect(_B.isEqual(void 0, objectWithProtoInheritedProps)).to.be["false"];
        return expect(_B.isEqual(objectWithProtoInheritedProps, void 0)).to.be["false"];
      });
      it("one null", function () {
        expect(_B.isEqual(null, objectWithProtoInheritedProps)).to.be["false"];
        return expect(_B.isEqual(objectWithProtoInheritedProps, null)).to.be["false"];
      });
      it("both undefined/null", function () {
        expect(_B.isEqual(void 0, void 0)).to.be["true"];
        expect(_B.isEqual([void 0], [void 0])).to.be["true"];
        expect(_B.isEqual(null, null)).to.be["true"];
        return expect(_B.isEqual([null], [null])).to.be["true"];
      });
      it("one undefined, other null", function () {
        expect(_B.isEqual(null, void 0)).to.be["false"];
        return expect(_B.isEqual(void 0, null)).to.be["false"];
      });
      it("Number", function () {
        expect(_B.isEqual(111, 111)).to.be["true"];
        expect(_B.isEqual(111.002, 111.002)).to.be["true"];
        expect(_B.isEqual(112, 111)).to.be["false"];
        return expect(_B.isEqual(111.002, 111.003)).to.be["false"];
      });
      describe("String", function () {
        it("as primitive \"\"", function () {
          expect(_B.isEqual("AAA 111", "AAA 111")).to.be["true"];
          return expect(_B.isEqual("AAA 112", "AAA 111")).to.be["false"];
        });
        return it("as String Object", function () {
          expect(_B.isEqual(new String("AAA 111"), "AAA 111")).to.be["true"];
          expect(_B.isEqual("AAA 111", new String("AAA 111"))).to.be["true"];
          expect(_B.isEqual(new String("AAA 111"), new String("AAA 111"))).to.be["true"];
          expect(_B.isEqual("AAA 112", new String("AAA 111"))).to.be["false"];
          expect(_B.isEqual(new String("AAA 112"), "AAA 111")).to.be["false"];
          return expect(_B.isEqual(new String("AAA 112"), new String("AAA 111"))).to.be["false"];
        });
      });
      it("Date", function () {
        expect(_B.isEqual(new Date("2012/12/12"), new Date("2012/12/12"))).to.be["true"];
        return expect(_B.isEqual(new Date("2012/12/13"), new Date("2012/12/12"))).to.be["false"];
      });
      it("RegExp", function () {
        expect(_B.isEqual(/abc/, /abc/)).to.be["true"];
        return expect(_B.isEqual(/abcd/, /abc/)).to.be["false"];
      });
      describe("Boolean", function () {
        it("as primitive", function () {
          expect(_B.isEqual(true, true)).to.be["true"];
          return expect(_B.isEqual(true, false)).to.be["false"];
        });
        return it("as Boolean Object", function () {
          expect(_B.isEqual(new Boolean(true), true)).to.be["true"];
          expect(_B.isEqual(new Boolean(true), false)).to.be["false"];
          return expect(_B.isEqual(false, new Boolean(false))).to.be["true"];
        });
      });
      return describe("Mixed primitives", function () {
        it("boolean truthys", function () {
          expect(_B.isEqual(true, 1)).to.be["false"];
          return expect(_B.isEqual(true, "a string")).to.be["false"];
        });
        return it("boolean falsys", function () {
          expect(_B.isEqual(false, 0)).to.be["false"];
          return expect(_B.isEqual(false, "")).to.be["false"];
        });
      });
    });
    describe("Simple Objects & functions:", function () {
      it("empty objects & arrays", function () {
        expect(_B.isEqual([], [])).to.be["true"];
        return expect(_B.isEqual({}, {})).to.be["true"];
      });
      it("empty different `_.isObject`s aren't equal", function () {
        expect(_B.isEqual({}, [])).to.be["false"];
        expect(_B.isEqual({}, function () {
        })).to.be["false"];
        return expect(_B.isEqual([], function () {
        })).to.be["false"];
      });
      it("present keys are important, even if undefined", function () {
        expect(_.isEqual({
          a: 1,
          b: void 0
        }, { a: 1 })).to.be["false"];
        return expect(_.isEqual({ a: 1 }, {
          a: 1,
          b: void 0
        })).to.be["false"];
      });
      return it("functions, with/without props", function () {
        var f1, f2;
        f1 = function () {
        };
        f2 = function () {
        };
        expect(_B.isEqual(f1, f2)).to.be["false"];
        expect(_B.isExact(f1, f2)).to.be["false"];
        expect(_B.isIqual(f1, f2)).to.be["false"];
        f1.p = "a";
        f2.p = "a";
        expect(_B.isEqual(f1, f2)).to.be["false"];
        expect(_B.isExact(f1, f2)).to.be["false"];
        return expect(_B.isIqual(f1, f2)).to.be["false"];
      });
    });
    return describe("Arrays & lookalikes :", function () {
      var arr1, arr2, arrLookalike;
      arr1 = [
        1,
        2,
        "3",
        [4],
        { a: 1 }
      ];
      arr2 = [
        1,
        2,
        "3",
        [4],
        { a: 1 }
      ];
      arrLookalike = {
        "0": 1,
        "1": 2,
        "2": "3",
        "3": [4],
        "4": { a: 1 }
      };
      it("simple Arrays", function () {
        return expect(_B.isEqual(arr1, arr2)).to.be["true"];
      });
      it("Arrays with missing items", function () {
        delete arr2[2];
        return expect(_B.isEqual(arr1, arr2)).to.be["false"];
      });
      return it("Array lookalikes arent equal", function () {
        return expect(_B.isEqual(arr1, arrLookalike)).to.be["false"];
      });
    });
  });
  describe("Argument's `isEqual` function:", function () {
    var A;
    A = function () {
      function A(val) {
        this.val = val;
      }
      A.prototype.isEqual = function (other) {
        return ((other != null ? other.val : void 0) || other) === "YEAH";
      };
      return A;
    }();
    return it("recognsises & uses isEqual function on either side", function () {
      var a, b;
      a = new A("whatever");
      b = new A("YEAH");
      expect(_B.isEqual(a, b)).to.be["true"];
      expect(_B.isEqual(a, "YEAH")).to.be["true"];
      expect(_B.isEqual(b, "YEAH")).to.be["true"];
      expect(_B.isEqual(b, a)).to.be["false"];
      expect(_B.isEqual(a, null)).to.be["false"];
      return expect(_B.isEqual(a, void 0)).to.be["false"];
    });
  });
  describe("options.exclude - excludes properties from test:", function () {
    describe("on Arrays:", function () {
      it("excludes index as Number or String", function () {
        var a, b;
        a = [
          1,
          2,
          3,
          99,
          5
        ];
        b = [
          1,
          2,
          3,
          44,
          5
        ];
        expect(_B.isEqual(a, b)).to.be["false"];
        expect(_B.isEqual(a, b, { exclude: [3] })).to.be["true"];
        return expect(_B.isEqual(a, b, { exclude: ["3"] })).to.be["true"];
      });
      return it("excludes index & property with options.allProps", function () {
        var a, b;
        a = [
          1,
          2,
          3,
          99,
          5
        ];
        a.prop = 1;
        a.badProp = 13;
        b = [
          1,
          2,
          3,
          44,
          5
        ];
        b.prop = 1;
        b.badProp = 13;
        expect(_B.isEqual(a, b)).to.be["false"];
        expect(_B.isEqual(a, b, {
          exclude: [3],
          allProps: true
        })).to.be["true"];
        b.badProp = 1113;
        expect(_B.isEqual(a, b, {
          exclude: [3],
          allProps: true
        })).to.be["false"];
        expect(_B.isEqual(a, b, {
          exclude: [
            3,
            "badProp"
          ],
          allProps: true
        })).to.be["true"];
        return expect(_B.isEqual(a, b, {
          exclude: [
            "badProp",
            "3"
          ],
          allProps: true
        })).to.be["true"];
      });
    });
    return it("excludes properties & number-like properties as numbers", function () {
      var a, b;
      a = {
        a: 1,
        b: 2,
        "3": 99,
        badProp: 5
      };
      b = {
        a: 1,
        b: 2,
        "3": 44,
        badProp: 15
      };
      expect(_B.isEqual(a, b)).to.be["false"];
      expect(_B.isEqual(a, b, {
        exclude: [
          3,
          "badProp"
        ]
      })).to.be["true"];
      return expect(_B.isEqual(a, b, {
        exclude: [
          "badProp",
          "3"
        ]
      })).to.be["true"];
    });
  });
  describe("options.allProps - considers all properties of Objects (i.e primitive imposters, functions, arrays etc):", function () {
    it("considers properties of primitive as Object:", function () {
      var a, b;
      a = new Number(111);
      b = new Number(111);
      a.prop = 1;
      b.prop = 2;
      expect(_B.isEqual(a, b)).to.be["true"];
      expect(_B.isEqual(a, b, { allProps: true })).to.be["false"];
      b.prop = 1;
      return expect(_B.isEqual(a, b, { allProps: true })).to.be["true"];
    });
    return it("considers properties (not just items) on Arrays", function () {
      var arr1, arr2;
      arr1 = [
        1,
        2,
        "3",
        [4],
        { a: 1 }
      ];
      arr2 = [
        1,
        2,
        "3",
        [4],
        { a: 1 }
      ];
      arr1.prop = [1];
      arr2.prop = [2];
      expect(_B.isEqual(arr1, arr2)).to.be["true"];
      expect(_B.isEqual(arr1, arr2, { allProps: true })).to.be["false"];
      arr2.prop = [1];
      return expect(_B.isEqual(arr1, arr2, { allProps: true })).to.be["true"];
    });
  });
  describe("options.onlyProps - ignores value & type of property containers (primitives as Object, functions etc):", function () {
    it("cares only about properties, on equal values", function () {
      var a, b;
      a = new Number(111);
      b = new Number(111);
      a.prop = 1;
      b.prop = 2;
      expect(_B.isEqual(a, b, { onlyProps: true })).to.be["false"];
      b.prop = 1;
      return expect(_B.isEqual(a, b, { onlyProps: true })).to.be["true"];
    });
    describe("cares only about properties, on NON-equal values:", function () {
      it("ignores Number Object value, only properties matter", function () {
        var a, b;
        a = new Number(111);
        b = new Number(112);
        a.prop = 1;
        b.prop = 2;
        expect(_B.isEqual(b, a, { onlyProps: true })).to.be["false"];
        b.prop = 1;
        return expect(_B.isEqual(b, a, { onlyProps: true })).to.be["true"];
      });
      it("ignores different Functions, only properties matter", function () {
        var a, b;
        a = function () {
          return "Hello";
        };
        b = function () {
          return "Goodbye";
        };
        a.prop = 1;
        b.prop = 2;
        expect(_B.isEqual(a, b, { onlyProps: true })).to.be["false"];
        b.prop = 1;
        return expect(_B.isEqual(a, b, { onlyProps: true })).to.be["true"];
      });
      return it("DOES NOT ignore String Object 'value', as each char is a property!", function () {
        var a, b;
        a = new String("111");
        b = new String("112");
        a.prop = 1;
        b.prop = 1;
        return expect(_B.isEqual(b, a, { onlyProps: true })).to.be["false"];
      });
    });
    describe("only properties matter, even on NON-equal types:", function () {
      it("ignores type of Objects, along with value", function () {
        var a, b;
        a = new RegExp(/./);
        b = new Boolean(false);
        a.prop = 1;
        b.prop = 2;
        expect(_B.isEqual(a, b, { onlyProps: true })).to.be["false"];
        b.prop = 1;
        return expect(_B.isEqual(a, b, { onlyProps: true })).to.be["true"];
      });
      return describe("works on different type of property containers like", function () {
        var A, args, arr, func, hash, instance;
        hash = {
          "0": 1,
          "1": 2,
          "2": 3
        };
        arr = [
          1,
          2,
          3
        ];
        args = function (a, b, c) {
          return arguments;
        }(1, 2, 3);
        func = function () {
          return "Hi";
        };
        func["0"] = 1;
        func["1"] = 2;
        func["2"] = 3;
        A = function () {
          function A() {
            this["0"] = 1;
            this["1"] = 2;
            this["2"] = 3;
          }
          return A;
        }();
        instance = new A();
        it("hash against array", function () {
          fals(_B.isEqual(hash, arr));
          return tru(_B.isEqual(hash, arr, { onlyProps: true }));
        });
        it("instance against array", function () {
          fals(_B.isEqual(instance, arr));
          return tru(_B.isEqual(instance, arr, { onlyProps: true }));
        });
        it.skip("arguments against array", function () {
          if (!(window.PHANTOMJS || window.mochaPhantomJS)) {
            fals(_B.isEqual(args, arr));
            return tru(_B.isEqual(args, arr, { onlyProps: true }));
          }
        });
        it("hash against function", function () {
          fals(_B.isEqual(hash, func));
          return tru(_B.isEqual(hash, func, { onlyProps: true }));
        });
        return it("instance against function", function () {
          fals(_B.isEqual(instance, func));
          return tru(_B.isEqual(instance, func, { onlyProps: true }));
        });
      });
    });
    return describe("works along with like:", function () {
      it("1st args as primitive", function () {
        var b;
        b = new Number(111);
        b.prop = 1;
        expect(_B.isEqual(1, b, { onlyProps: true })).to.be["false"];
        expect(_B.isEqual(1, b, {
          onlyProps: true,
          like: true
        })).to.be["true"];
        return expect(_B.isEqual(b, 1, {
          onlyProps: true,
          like: true
        })).to.be["false"];
      });
      return it("both as Object imporsters, 2nd has more props", function () {
        var a, b;
        a = new Number(111);
        b = new Boolean(false);
        a.prop = 1;
        b.prop = 1;
        b.prop2 = 2;
        expect(_B.isEqual(a, b, {
          onlyProps: true,
          like: true
        })).to.be["true"];
        expect(_B.isEqual(b, a, {
          onlyProps: true,
          like: true
        })).to.be["false"];
        a.prop2 = 2;
        return expect(_B.isEqual(b, a, {
          onlyProps: true,
          like: true
        })).to.be["true"];
      });
    });
  });
  describe("options.inherited - Objects with inherited properties:", function () {
    describe("object with inherited properties:", function () {
      it("_B.isEqual is true", function () {
        expect(_B.isEqual(objectWithProtoInheritedProps, expectedPropertyValues, void 0, void 0, { inherited: true })).to.be["true"];
        return expect(_B.isEqual(expectedPropertyValues, objectWithProtoInheritedProps, { inherited: true })).to.be["true"];
      });
      it("_.isEqual fails", function () {
        expect(_.isEqual(objectWithProtoInheritedProps, expectedPropertyValues)).to.be["false"];
        return expect(_.isEqual(expectedPropertyValues, objectWithProtoInheritedProps)).to.be["false"];
      });
      describe("with _.clone: ", function () {
        it("_B.isIqual fails (imperfect _.clone)", function () {
          expect(_B.isIqual(oClone, expectedPropertyValues)).to.be["false"];
          return expect(_B.isIqual(expectedPropertyValues, oClone)).to.be["false"];
        });
        return it("_.isEqual fails", function () {
          expect(_.isEqual(oClone, expectedPropertyValues)).to.be["false"];
          return expect(_.isEqual(expectedPropertyValues, oClone)).to.be["false"];
        });
      });
      return describe("with _B.clone proto: ", function () {
        var oCloneProto;
        oCloneProto = _B.clone(objectWithProtoInheritedProps, { copyProto: true });
        it("_B.isIqual succeeds (a perfect clone:-)", function () {
          expect(_B.isIqual(oCloneProto, expectedPropertyValues)).to.be["true"];
          return expect(_B.isIqual(expectedPropertyValues, oCloneProto)).to.be["true"];
        });
        return it("_.isEqual still fails", function () {
          expect(_.isEqual(oCloneProto, expectedPropertyValues)).to.be["false"];
          return expect(_.isEqual(expectedPropertyValues, oCloneProto)).to.be["false"];
        });
      });
    });
    return describe("coffeescript object with inherited properties:", function () {
      it("_B.isEqual is true", function () {
        expect(_B.isEqual(c3, expectedPropertyValues, {
          inherited: true,
          exclude: ["constructor"]
        })).to.be["true"];
        return expect(_B.isIqual(expectedPropertyValues, c3)).to.be["true"];
      });
      it("_.isEqual fails", function () {
        expect(_.isEqual(c3, expectedPropertyValues)).to.be["false"];
        return expect(_.isEqual(expectedPropertyValues, c3)).to.be["false"];
      });
      describe("with _.clone:", function () {
        it("_B.isIqual fails (imperfect _.clone)", function () {
          expect(_B.isEqual(c3Clone, expectedPropertyValues, void 0, void 0, { inherited: true })).to.be["false"];
          return expect(_B.isIqual(expectedPropertyValues, c3Clone)).to.be["false"];
        });
        return it("_.isEqual fails", function () {
          expect(_.isEqual(c3Clone, expectedPropertyValues)).to.be["false"];
          return expect(_.isEqual(expectedPropertyValues, c3Clone)).to.be["false"];
        });
      });
      return describe("with _B.clone: ", function () {
        var c3CloneProto;
        c3CloneProto = _B.clone(c3, { copyProto: true });
        it("_B.isIqual is true", function () {
          expect(_B.isEqual(c3CloneProto, expectedPropertyValues, {
            inherited: true,
            exclude: ["constructor"]
          })).to.be["true"];
          return expect(_B.isIqual([expectedPropertyValues], [c3CloneProto])).to.be["true"];
        });
        return it("_.isEqual fails", function () {
          expect(_.isEqual(c3CloneProto, expectedPropertyValues)).to.be["false"];
          return expect(_.isEqual(expectedPropertyValues, c3CloneProto)).to.be["false"];
        });
      });
    });
  });
  describe("options.exact (Objects need to have exact refs) :", function () {
    describe("shallow cloned objects :", function () {
      it("_B.isExact(object, objectShallowClone1) is true", function () {
        expect(_B.isEqual(object, objectShallowClone1, void 0, void 0, { exact: true })).to.be["true"];
        return expect(_B.isExact(objectShallowClone1, object)).to.be["true"];
      });
      it("_B.isExact(object, objectShallowClone2) with _.clone(object) is true", function () {
        expect(_B.isEqual(object, objectShallowClone2, { exact: true })).to.be["true"];
        return expect(_B.isExact(objectShallowClone2, object)).to.be["true"];
      });
      return it("_.isEqual(object, shallowClone1 & 2) gives true", function () {
        expect(_.isEqual(object, objectShallowClone1)).to.be["true"];
        return expect(_.isEqual(object, objectShallowClone2)).to.be["true"];
      });
    });
    describe("deeply cloned objects:", function () {
      describe("objectDeepClone1 with copied proto:", function () {
        it("_B.isExact is false", function () {
          expect(_B.isEqual(object, objectDeepClone1, { exact: true })).to.be["false"];
          return expect(_B.isExact(objectDeepClone1, object)).to.be["false"];
        });
        return it("_B.isEqual is true", function () {
          expect(_B.isEqual(object, objectDeepClone1)).to.be["true"];
          return expect(_B.isEqual(objectDeepClone1, object)).to.be["true"];
        });
      });
      describe("objectDeepClone2 = _.clone(object):", function () {
        it("_B.isExact is false", function () {
          expect(_B.isEqual(object, objectDeepClone2, void 0, void 0, { exact: true })).to.be["false"];
          return expect(_B.isExact(objectDeepClone2, object)).to.be["false"];
        });
        return it("_B.isEqual is true", function () {
          expect(_B.isEqual(object, objectDeepClone2)).to.be["true"];
          return expect(_B.isEqual(objectDeepClone2, object)).to.be["true"];
        });
      });
      return it("_.isEqual(object, objectDeepClone1 & 2) gives true", function () {
        expect(_.isEqual(object, objectDeepClone1)).to.be["true"];
        return expect(_.isEqual(object, objectDeepClone2)).to.be["true"];
      });
    });
    return describe("isIxact : isEqual with inherited & exact :", function () {
      describe("shallow inherited clone: inheritedShallowClone:", function () {
        it("isIxact is true:", function () {
          return expect(_B.isIxact(inheritedShallowClone, object)).to.be["true"];
        });
        return it("isIqual is true:", function () {
          return expect(_B.isIqual(object, inheritedShallowClone)).to.be["true"];
        });
      });
      return describe("deep inherited clone : inheritedDeepClone:", function () {
        it("isIxact is true:", function () {
          return expect(_B.isIxact(inheritedDeepClone, object)).to.be["false"];
        });
        return it("isIqual is true:", function () {
          return expect(_B.isIqual(object, inheritedDeepClone)).to.be["true"];
        });
      });
    });
  });
  describe("options.path:", function () {
    var a1, a2;
    a1 = {
      a: { a1: { a2: 1 } },
      b: {
        b1: 1,
        b2: { b3: 3 }
      }
    };
    a2 = {
      a: { a1: { a2: 1 } },
      b: {
        b1: 1,
        b2: { b3: 3333 }
      }
    };
    it("contains the keys as they are processed, 1st obj misses props", function () {
      var options;
      expect(_B.isEqual(a1, a2, options = { path: [] })).to.be["false"];
      return expect(options.path).to.be.deep.equal([
        "b",
        "b2",
        "b3"
      ]);
    });
    return it("contains the keys as they are processed, 2nd obj misses props", function () {
      var options;
      expect(_B.isEqual(a2, a1, null, null, options = { path: [] })).to.be["false"];
      return expect(options.path).to.be.deep.equal([
        "b",
        "b2",
        "b3"
      ]);
    });
  });
  describe("_B.isLike : _B.isEqual with like:true (1st arg can be a partial of 2nd arg)", function () {
    var a1, a2, b1, b2;
    a1 = {
      a: 1,
      b: { b1: 1 }
    };
    b1 = {
      a: 1,
      b: {
        b1: 1,
        b2: 2
      },
      c: 3
    };
    a2 = {
      a: 1,
      b: { bb: 2 },
      c: [
        1,
        { p2: 2 },
        4
      ]
    };
    b2 = {
      a: 1,
      b: {
        bb: 2,
        missingFrom: { a: "a" }
      },
      missingFrom: "a",
      c: [
        1,
        {
          p2: 2,
          p3: 3
        },
        4,
        { p: 5 },
        6
      ]
    };
    it("is true if 1st args's properties are _B.isLike to 2nd arg's", function () {
      expect(_B.isLike(a1, b1)).to.be["true"];
      expect(_B.isEqual(a1, b1)).to.be["false"];
      expect(_B.isLike(a2, b2)).to.be["true"];
      return expect(_B.isEqual(a2, b2)).to.be["false"];
    });
    return it("is false if 1st args's properties are not _B.isLike to 2nd arg's", function () {
      expect(_B.isLike(b1, a1)).to.be["false"];
      expect(_B.isEqual(b1, a1)).to.be["false"];
      expect(_B.isLike(b2, a2)).to.be["false"];
      return expect(_B.isEqual(b2, a2)).to.be["false"];
    });
  });
  return describe("aliases like _B.isLike : ", function () {
    var _b, a1, b1;
    a1 = {
      a: 1,
      b: { b1: 1 }
    };
    b1 = {
      a: 1,
      b: _b = {
        b1: 1,
        b2: 2
      },
      c: 3
    };
    it("pass options in place of the constructor", function () {
      var path;
      expect(_B.isLike(b1, a1, { path: path = [] })).to.be["false"];
      return expect(path).to.be.deep.equal([
        "b",
        "b2"
      ]);
    });
    it("pass options in its proper place", function () {
      var path;
      expect(_B.isLike(b1, a1, void 0, void 0, { path: path = [] })).to.be["false"];
      return expect(path).to.be.deep.equal([
        "b",
        "b2"
      ]);
    });
    it("passes callback & options in its proper place & as an option", function () {
      var callback, path;
      callback = function (val1, val2) {
        if (val1 === _b || path[0] === "c") {
          return true;
        }
      };
      expect(_B.isLike(b1, a1, callback, void 0, { path: path = [] })).to.be["true"];
      return expect(_B.isLike(b1, a1, null, void 0, {
        path: path = [],
        callback: callback
      })).to.be["true"];
    });
    return it("options in its proper place DOESN NOT has precedence over callback's place", function () {
      var path1, path2;
      expect(_B.isLike(b1, a1, { path: path1 = [] }, void 0, { path: path2 = [] })).to.be["false"];
      expect(path1).to.be.deep.equal([
        "b",
        "b2"
      ]);
      return expect(path2).to.be.empty;
    });
  });
});

return module.exports;

});
define('objects/isOK-True-False-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('objects/isOK-True-False-spec.js');

var falsies, truthies;
truthies = [
  {},
  [],
  "aa",
  1,
  /./
];
falsies = [
  "",
  0,
  null,
  void 0
];
describe("_B.isOk:", function () {
  var fn, i, j, len, len1, ref, ref1, results, v;
  ref = truthies.concat(new Boolean(false));
  fn = function (v) {
    return it("with truthy type:'" + _B.type(v) + "', value:'" + v + "'", function () {
      return ok(_B.isOk(v));
    });
  };
  for (i = 0, len = ref.length; i < len; i++) {
    v = ref[i];
    fn(v);
  }
  ref1 = falsies.concat(false);
  results = [];
  for (j = 0, len1 = ref1.length; j < len1; j++) {
    v = ref1[j];
    results.push(function (v) {
      return it("with falsey type:'" + _B.type(v) + "', value:'" + v + "'", function () {
        return notOk(_B.isOk(v));
      });
    }(v));
  }
  return results;
});
describe("_B.isTrue:", function () {
  describe("true only with boolean true:", function () {
    var i, len, ref, results, v;
    ref = [
      true,
      new Boolean(true)
    ];
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      v = ref[i];
      results.push(function (v) {
        return it("type:'" + _B.type(v) + "', value:'" + v + "'", function () {
          return tru(_B.isTrue(v));
        });
      }(v));
    }
    return results;
  });
  return describe("false with any truthy:", function () {
    var i, len, ref, results, v;
    ref = truthies.concat(new Boolean(false));
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      v = ref[i];
      results.push(function (v) {
        return it("type:'" + _B.type(v) + "', value:'" + v + "'", function () {
          return fals(_B.isTrue(v));
        });
      }(v));
    }
    return results;
  });
});
describe("_B.isFalse:", function () {
  describe("false *only with boolean false:", function () {
    var i, len, ref, results, v;
    ref = [
      false,
      new Boolean(false)
    ];
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      v = ref[i];
      results.push(function (v) {
        return it("type:'" + _B.type(v) + "', value:'" + v + "'", function () {
          return tru(_B.isFalse(v));
        });
      }(v));
    }
    return results;
  });
  return describe("false with any falsies:", function () {
    var i, len, results, v;
    results = [];
    for (i = 0, len = falsies.length; i < len; i++) {
      v = falsies[i];
      results.push(function (v) {
        return it("type: '" + _B.type(v) + "', value:'" + v + "'", function () {
          return fals(_B.isFalse(v));
        });
      }(v));
    }
    return results;
  });
});

return module.exports;

});
define('objects/isRefDisjoint-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('objects/isRefDisjoint-spec.js');

var O1, a1_2, a3_4, a3_4_2, a3_4_a1_2, a3_4_nested_a1_2, a3_4_nested_o2, inheritedDeepClone, inheritedShallowClone, o1, o1_2, o2, o3, o3_4, o3_4_2, o3_4_nested_o1_2, o3_4_nested_o2, o3_4_o1_2, o4, object, objectDeepClone1, objectDeepClone2, objectShallowClone1, objectShallowClone2;
O1 = o1 = { p1: 1 };
o2 = { p2: 2 };
o3 = { p3: 3 };
o4 = { p4: 4 };
a1_2 = [
  o1,
  o2
];
o1_2 = {
  p1: o1,
  p2: o2
};
a3_4 = [
  o3,
  o4
];
o3_4 = {
  p3: o3,
  p4: o4
};
a3_4_2 = [
  o3,
  o4,
  o2
];
o3_4_2 = {
  p3: o3,
  p4: o4,
  p5: o2
};
a3_4_a1_2 = [
  o3,
  o4,
  a1_2
];
o3_4_o1_2 = {
  p3: o3,
  p4: o4,
  p5: o1_2
};
a3_4_nested_o2 = [
  o3,
  o4,
  { a: { b: o2 } }
];
o3_4_nested_o2 = {
  p3: o3,
  p4: o4,
  p5: { a: { b: o2 } }
};
a3_4_nested_a1_2 = [
  o3,
  o4,
  { a: { b: a1_2 } }
];
o3_4_nested_o1_2 = {
  p3: o3,
  p4: o4,
  p5: { a: { b: o1_2 } }
};
object = data.object, objectShallowClone1 = data.objectShallowClone1, objectShallowClone2 = data.objectShallowClone2, objectDeepClone1 = data.objectDeepClone1, objectDeepClone2 = data.objectDeepClone2, inheritedShallowClone = data.inheritedShallowClone, inheritedDeepClone = data.inheritedDeepClone;
describe("isRefDisjoint:", function () {
  it("recognises self as non disjoint:", function () {
    return expect(_B.isRefDisjoint(o1, O1)).to.be["false"];
  });
  describe("Arrays:", function () {
    describe("with deep=false (shallow):", function () {
      it("recognises disjoint:", function () {
        expect(_B.isRefDisjoint(a1_2, a3_4)).to.be["true"];
        return expect(_B.isRefDisjoint(a3_4, a1_2)).to.be["true"];
      });
      it("recognises non-disjoint", function () {
        expect(_B.isRefDisjoint(a1_2, a3_4_2)).to.be["false"];
        return expect(_B.isRefDisjoint(a3_4_2, a1_2)).to.be["false"];
      });
      return describe("recognises disjoint:", function () {
        it("with nested shared reference", function () {
          expect(_B.isRefDisjoint(a1_2, a3_4_nested_o2, { deep: false })).to.be["true"];
          return expect(_B.isRefDisjoint(a3_4_nested_o2, a1_2, { deep: false })).to.be["true"];
        });
        return it("with one side being a shared reference", function () {
          expect(_B.isRefDisjoint(a1_2, a3_4_nested_a1_2, { deep: false })).to.be["true"];
          return expect(_B.isRefDisjoint(a3_4_nested_a1_2, a1_2, { deep: false })).to.be["true"];
        });
      });
    });
    return describe("with deep=true:", function () {
      it("recognises disjoint:", function () {
        expect(_B.isRefDisjoint(a1_2, a3_4, { deep: true })).to.be["true"];
        return expect(_B.isRefDisjoint(a3_4, a1_2, { deep: true })).to.be["true"];
      });
      return describe("recognises non-disjoint:", function () {
        it("with nested shared reference", function () {
          expect(_B.isRefDisjoint(a1_2, a3_4_nested_o2, { deep: true })).to.be["false"];
          return expect(_B.isRefDisjoint(a3_4_nested_o2, a1_2, { deep: true })).to.be["false"];
        });
        return it("with one side being a shared reference", function () {
          expect(_B.isRefDisjoint(a1_2, a3_4_nested_a1_2, { deep: true })).to.be["false"];
          return expect(_B.isRefDisjoint(a3_4_nested_a1_2, a1_2, { deep: true })).to.be["false"];
        });
      });
    });
  });
  describe("Objects:", function () {
    describe("with deep=false (shallow):", function () {
      it("recognises disjoint:", function () {
        expect(_B.isRefDisjoint(o1_2, o3_4)).to.be["true"];
        return expect(_B.isRefDisjoint(o3_4, o1_2)).to.be["true"];
      });
      it("recognises non-disjoint", function () {
        expect(_B.isRefDisjoint(o1_2, o3_4_2)).to.be["false"];
        return expect(_B.isRefDisjoint(o3_4_2, o1_2)).to.be["false"];
      });
      return describe("recognises disjoint:", function () {
        it("with nested shared reference", function () {
          expect(_B.isRefDisjoint(o1_2, o3_4_nested_o2, { deep: false })).to.be["true"];
          return expect(_B.isRefDisjoint(o3_4_nested_o2, o1_2, { deep: false })).to.be["true"];
        });
        return it("with one side being a shared reference", function () {
          expect(_B.isRefDisjoint(o1_2, o3_4_nested_o1_2, { deep: false })).to.be["true"];
          return expect(_B.isRefDisjoint(o3_4_nested_o1_2, o1_2, { deep: false })).to.be["true"];
        });
      });
    });
    return describe("with deep=true:", function () {
      it("recognises disjoint:", function () {
        expect(_B.isRefDisjoint(o1_2, o3_4, { deep: true })).to.be["true"];
        return expect(_B.isRefDisjoint(o3_4, o1_2, { deep: true })).to.be["true"];
      });
      return describe("recognises non-disjoint:", function () {
        it("with nested shared reference", function () {
          expect(_B.isRefDisjoint(o1_2, o3_4_nested_o2, { deep: true })).to.be["false"];
          return expect(_B.isRefDisjoint(o3_4_nested_o2, o1_2, { deep: true })).to.be["false"];
        });
        return it("with one side being a shared reference", function () {
          expect(_B.isRefDisjoint(o1_2, o3_4_nested_o1_2, { deep: true })).to.be["false"];
          return expect(_B.isRefDisjoint(o3_4_nested_o1_2, o1_2, { deep: true })).to.be["false"];
        });
      });
    });
  });
  describe("Mixed Arrays & Objects:", function () {
    describe("with deep=false (shallow):", function () {
      it("recognises disjoint:", function () {
        expect(_B.isRefDisjoint(o1_2, a3_4)).to.be["true"];
        return expect(_B.isRefDisjoint(o3_4, a1_2)).to.be["true"];
      });
      it("recognises non-disjoint", function () {
        expect(_B.isRefDisjoint(o1_2, a3_4_2)).to.be["false"];
        return expect(_B.isRefDisjoint(o3_4_2, a1_2)).to.be["false"];
      });
      return describe("recognises disjoint:", function () {
        it("with nested shared reference", function () {
          expect(_B.isRefDisjoint(o1_2, a3_4_nested_o2, { deep: false })).to.be["true"];
          return expect(_B.isRefDisjoint(o3_4_nested_o2, a1_2, { deep: false })).to.be["true"];
        });
        return it("with one side being a shared reference", function () {
          expect(_B.isRefDisjoint([o1_2], o3_4_nested_o1_2, { deep: false })).to.be["true"];
          return expect(_B.isRefDisjoint([o3_4_nested_o1_2], o1_2, { deep: false })).to.be["true"];
        });
      });
    });
    return describe("with deep=true:", function () {
      it("recognises disjoint:", function () {
        expect(_B.isRefDisjoint(o1_2, a3_4, { deep: true })).to.be["true"];
        return expect(_B.isRefDisjoint(o3_4, a1_2, { deep: true })).to.be["true"];
      });
      return describe("recognises non-disjoint:", function () {
        it("with nested shared reference", function () {
          expect(_B.isRefDisjoint(o1_2, a3_4_nested_o2, { deep: true })).to.be["false"];
          return expect(_B.isRefDisjoint(o3_4_nested_o2, a1_2, { deep: true })).to.be["false"];
        });
        return it("with one side being a shared reference", function () {
          expect(_B.isRefDisjoint([o1_2], o3_4_nested_o1_2, { deep: true })).to.be["false"];
          return expect(_B.isRefDisjoint([o3_4_nested_o1_2], o1_2, { deep: true })).to.be["false"];
        });
      });
    });
  });
  return describe("Cloned objects :", function () {
    describe("Without inherited properties:", function () {
      it("recognises non-disjoint (shallow clones):", function () {
        expect(_B.isRefDisjoint(objectShallowClone1, object, {
          deep: true,
          inherited: true
        })).to.be["false"];
        expect(_B.isRefDisjoint(object, objectShallowClone1, {
          deep: true,
          inherited: true
        })).to.be["false"];
        expect(_B.isRefDisjoint(objectShallowClone2, object, {
          deep: true,
          inherited: true
        })).to.be["false"];
        return expect(_B.isRefDisjoint(object, objectShallowClone2, {
          deep: true,
          inherited: true
        })).to.be["false"];
      });
      return it("recognises disjoint (deep clones):", function () {
        expect(_B.isRefDisjoint(objectDeepClone1, object, {
          deep: true,
          inherited: true
        })).to.be["true"];
        expect(_B.isRefDisjoint(object, objectDeepClone1, {
          deep: true,
          inherited: true
        })).to.be["true"];
        expect(_B.isRefDisjoint(objectDeepClone1, object, {
          deep: true,
          inherited: true
        })).to.be["true"];
        return expect(_B.isRefDisjoint(object, objectDeepClone1, {
          deep: true,
          inherited: true
        })).to.be["true"];
      });
    });
    return describe("With inherited properties:", function () {
      it("recognises non-disjoint (shallow clones):", function () {
        expect(_B.isRefDisjoint(inheritedShallowClone, object, {
          deep: true,
          inherited: true
        })).to.be["false"];
        return expect(_B.isRefDisjoint(object, inheritedShallowClone, {
          deep: true,
          inherited: true
        })).to.be["false"];
      });
      return it("recognises disjoint (deep clones):", function () {
        expect(_B.isRefDisjoint(inheritedDeepClone, object, {
          deep: true,
          inherited: true
        })).to.be["true"];
        return expect(_B.isRefDisjoint(object, inheritedDeepClone, {
          deep: true,
          inherited: true
        })).to.be["true"];
      });
    });
  });
});

return module.exports;

});
define('objects/mutate-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('objects/mutate-spec.js');

describe("mutate :", function () {
  var simpleCalc;
  simpleCalc = function (v) {
    if (v < 0) {
      return v + 10;
    } else {
      return v + 20;
    }
  };
  it("mutate Object values", function () {
    var o;
    o = {
      a: 1,
      b: 2,
      c: -1
    };
    return expect(_B.mutate(o, simpleCalc)).to.deep.equal({
      a: 21,
      b: 22,
      c: 9
    });
  });
  it("arrayize if string", function () {
    var o;
    o = {
      key1: "lalakis",
      key2: [
        "ok",
        "yes"
      ]
    };
    return expect(_B.mutate(o, _B.arrayize, _.isString)).to.deep.equal({
      key1: ["lalakis"],
      key2: [
        "ok",
        "yes"
      ]
    });
  });
  return describe("mutate arrays :", function () {
    var a;
    a = [
      1,
      2,
      -1
    ];
    it("mutate array with simplecalc ", function () {
      return expect(_B.mutate(a, simpleCalc)).to.deep.equal([
        21,
        22,
        9
      ]);
    });
    return it("mutate array again with fltr", function () {
      return expect(_B.mutate(a, simpleCalc, function (v) {
        return v > 10;
      })).to.deep.equal([
        41,
        42,
        9
      ]);
    });
  });
});

return module.exports;

});
define('objects/okv-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('objects/okv-spec.js');

describe("okv :", function () {
  var weirdKeyName;
  weirdKeyName = " $#%!@&";
  it("builds a simple object, with weird keyName", function () {
    return expect(_B.okv({}, "foo_" + weirdKeyName, 8, "bar" + weirdKeyName, "some bar")).to.deep.equal({
      "foo_ $#%!@&": 8,
      "bar $#%!@&": "some bar"
    });
  });
  describe("build a more invloved object", function () {
    var bar, o, theO;
    o = theO = {};
    o = _B.okv(o, "foo_" + weirdKeyName, 8, bar = "bar" + weirdKeyName, "some bar");
    o[bar] = _B.okv({}, "nestedBar" + weirdKeyName, "This is a secret bar", "anotherBar" + weirdKeyName, "Many bars, no foo");
    it("the object passed, is the object returned", function () {
      return expect(o).to.equal(theO);
    });
    it("o is build, then part of it augmented", function () {
      return expect(o).to.deep.equal({
        "foo_ $#%!@&": 8,
        "bar $#%!@&": {
          "nestedBar $#%!@&": "This is a secret bar",
          "anotherBar $#%!@&": "Many bars, no foo"
        }
      });
    });
    return it("add nested weird keyd bars on existing key, with ignored reduntan key", function () {
      var i;
      _B.okv(o[bar], "newbar" + weirdKeyName, "a new bar!", "bar" + function () {
        var j, len, ref, results;
        ref = [
          1,
          2,
          3
        ];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          results.push("" + i);
        }
        return results;
      }().join("-"), "ther weirest bar!", "reduntantKey");
      return expect(o).to.deep.equal({
        "foo_ $#%!@&": 8,
        "bar $#%!@&": {
          "nestedBar $#%!@&": "This is a secret bar",
          "anotherBar $#%!@&": "Many bars, no foo",
          "newbar $#%!@&": "a new bar!",
          "bar1-2-3": "ther weirest bar!"
        }
      });
    });
  });
  return describe("passing a string instead of obj as 1st param & toString objects as keys", function () {
    it("creates a new object, when 1st param is a String, which becomes the 1st key", function () {
      var o;
      o = _B.okv("some" + "property", { a: "value" });
      return expect(o).to.deep.equal({ "someproperty": { a: "value" } });
    });
    return it("key is an object, converted toString", function () {
      var o, objectWithToString;
      objectWithToString = {
        prop: "a property of an object",
        toString: function () {
          return this.prop + " that becomes a String";
        }
      };
      o = _B.okv({}, objectWithToString, { a: "value" });
      return expect(o).to.deep.equal({ "a property of an object that becomes a String": { a: "value" } });
    });
  });
});

return module.exports;

});
define('objects/setp-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('objects/setp-spec.js');

describe("objects/setp:", function () {
  var o;
  o = {
    "$": {
      bundle: {
        anArray: [
          "arrayItem1",
          2,
          { "arrayItem3": 3 }
        ],
        dependencies: { depsVars: "Bingo" }
      }
    }
  };
  describe("existent paths:", function () {
    it("primitive", function () {
      var isSet, oClone;
      oClone = _.clone(o, true);
      isSet = _B.setp(oClone, "$/bundle/dependencies/depsVars", "just_a_String");
      return expect(oClone).to.deep.equal({
        "$": {
          bundle: {
            anArray: [
              "arrayItem1",
              2,
              { "arrayItem3": 3 }
            ],
            dependencies: { depsVars: "just_a_String" }
          }
        }
      });
    });
    it("object, with sep at end & alt sep", function () {
      var isSet, oClone;
      oClone = _.clone(o, true);
      isSet = _B.setp(oClone, "$.bundle.dependencies.depsVars.", { property: "just_a_String" }, { separator: "." });
      expect(oClone).to.deep.equal({
        "$": {
          bundle: {
            anArray: [
              "arrayItem1",
              2,
              { "arrayItem3": 3 }
            ],
            dependencies: { depsVars: { property: "just_a_String" } }
          }
        }
      });
      return expect(isSet).to.be["true"];
    });
    it("object, overwriting object property", function () {
      var isSet, oClone;
      oClone = _.clone(o, true);
      isSet = _B.setp(oClone, "$.bundle.dependencies.", { property: "just_a_String" }, { separator: "." });
      expect(oClone).to.deep.equal({
        "$": {
          bundle: {
            anArray: [
              "arrayItem1",
              2,
              { "arrayItem3": 3 }
            ],
            dependencies: { property: "just_a_String" }
          }
        }
      });
      return expect(isSet).to.be["true"];
    });
    return it("array item, overwriting object property", function () {
      var isSet, oClone;
      oClone = _.clone(o, true);
      isSet = _B.setp(oClone, "$.bundle.anArray.2.arrayItem3", { "3_is_now": 33 }, { separator: "." });
      expect(oClone).to.deep.equal({
        "$": {
          bundle: {
            anArray: [
              "arrayItem1",
              2,
              { "arrayItem3": { "3_is_now": 33 } }
            ],
            dependencies: { depsVars: "Bingo" }
          }
        }
      });
      return expect(isSet).to.be["true"];
    });
  });
  return describe("inexistent key paths:", function () {
    it("not setting by default", function () {
      var isSet, oClone;
      oClone = _.clone(o, true);
      isSet = _B.setp(oClone, "$/bundle/dependencies/depsVars/hi", { joke: { joke2: "JOKER" } });
      expect(oClone).to.deep.equal(o);
      return expect(isSet).to.be["false"];
    });
    describe("options.create:", function () {
      it("create new objects for inexistent paths, adding object properties", function () {
        var isSet, oClone;
        oClone = _.clone(o, true);
        isSet = _B.setp(oClone, "$.bundle.dependencies.moreDeps.evenMoreDeps.", { property: "just_a_String" }, {
          create: true,
          separator: "."
        });
        expect(oClone).to.deep.equal({
          "$": {
            bundle: {
              anArray: [
                "arrayItem1",
                2,
                { "arrayItem3": 3 }
              ],
              dependencies: {
                depsVars: "Bingo",
                moreDeps: { evenMoreDeps: { property: "just_a_String" } }
              }
            }
          }
        });
        return expect(isSet).to.be["true"];
      });
      return it("NOT overwritting primitives:", function () {
        var isSet, oClone;
        oClone = _.clone(o, true);
        isSet = _B.setp(oClone, "$/bundle/dependencies/depsVars/newKey/", { property: "just_a_String" }, { create: true });
        expect(oClone).to.deep.equal({
          "$": {
            bundle: {
              anArray: [
                "arrayItem1",
                2,
                { "arrayItem3": 3 }
              ],
              dependencies: { depsVars: "Bingo" }
            }
          }
        });
        return expect(isSet).to.be["false"];
      });
    });
    return describe("options.overwrite:", function () {
      it("create new objects, overwritting primitives:", function () {
        var isSet, oClone;
        oClone = _.clone(o, true);
        isSet = _B.setp(oClone, "$/bundle/dependencies/depsVars/newKey", { joke: { joke2: "JOKER" } }, { overwrite: true });
        expect(oClone).to.deep.equal({
          "$": {
            bundle: {
              anArray: [
                "arrayItem1",
                2,
                { "arrayItem3": 3 }
              ],
              dependencies: { depsVars: { newKey: { joke: { joke2: "JOKER" } } } }
            }
          }
        });
        return expect(isSet).to.be["true"];
      });
      return it("create new objects, preserving `oldValue`", function () {
        var isSet, oClone;
        oClone = _.clone(o, true);
        isSet = _B.setp(oClone, "$/bundle/dependencies/depsVars/newKey/anotherNewKey", { joke: { joke2: "JOKER" } }, { overwrite: "_oldValue" });
        expect(oClone).to.deep.equal({
          "$": {
            bundle: {
              anArray: [
                "arrayItem1",
                2,
                { "arrayItem3": 3 }
              ],
              dependencies: {
                depsVars: {
                  _oldValue: "Bingo",
                  newKey: { anotherNewKey: { joke: { joke2: "JOKER" } } }
                }
              }
            }
          }
        });
        return expect(isSet).to.be["true"];
      });
    });
  });
});

return module.exports;

});
define('types/types-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('types/types-spec.js');

var A, AClass, anInstance, oOs;
AClass = function () {
  function AClass(prop) {
    this.prop = prop != null ? prop : "a property value";
  }
  return AClass;
}();
anInstance = new AClass();
oOs = {
  "Array": [
    [
      "this",
      "is",
      1,
      "array"
    ],
    new Array(1, 2, 3)
  ],
  "Arguments": [function () {
      return arguments;
    }()],
  "Function": [
    function (x) {
      return x;
    },
    new Function("var a = 'a'"),
    A = function () {
      function A() {
      }
      return A;
    }(),
    function () {
    }
  ],
  "String": [
    "I am a String!",
    new String("I am another String")
  ],
  "Number": [
    667,
    new Number(668.13)
  ],
  "Date": [new Date()],
  "RegExp": [
    /./g,
    new RegExp("/./")
  ],
  "Boolean": [
    true,
    false,
    new Boolean(true)
  ],
  "Null": [null],
  "Undefined": [
    void 0,
    void 0,
    function () {
    }()
  ],
  "Object": [
    { someProp: "SomeVal" },
    anInstance,
    new Object(),
    new function () {
    }()
  ]
};
describe("types & its associates:", function () {
  describe("`type` distisquishes all types", function () {
    var fn, i, len, typeName, value, values;
    for (typeName in oOs) {
      values = oOs[typeName];
      fn = function (typeName, value, longType, shortType) {
        return it("`type` recognises value of type '" + typeName + "' both as long='" + longType + "', as short='" + shortType, function () {
          expect(longType).to.equal(_B.type.toLong(typeName));
          expect(_B.type.isType(longType)).to.be["true"];
          expect(shortType).to.equal(_B.type.toShort(typeName));
          expect(_B.type.isType(shortType)).to.be["true"];
          return expect(_B.type.areEqual(longType, shortType)).to.be["true"];
        });
      };
      for (i = 0, len = values.length; i < len; i++) {
        value = values[i];
        fn(typeName, value, _B.type(value), _B.type(value, true));
      }
    }
    return null;
  });
  describe("`type` recognises all Object/Hashes {} correctly :", function () {
    return it("`type` correctly treats instances as Object, unlike lodash's `_.isPlainObject(anInstance) is false`", function () {
      if (_B.isLodash()) {
        expect(_.isPlainObject(anInstance)).to.be["false"];
      }
      return expect(_B.type(anInstance)).to.equal("Object");
    });
  });
  describe("`_B.isHash` uses the above to solve distinquishing an {} from other types (->, []), even if {} is an instance.", function () {
    it("`_B.isHash` recognises all {} as Objects, all Arrays & Functions are NON Objects", function () {
      expect(_B.isHash(anInstance)).to.be["true"];
      expect(_B.isHash({})).to.be["true"];
      expect(_B.isHash([])).to.be["false"];
      expect(_B.isHash(function () {
      })).to.be["false"];
      return [];
    });
    it("`_.isObject` is too broad - considers Arrays & Functions as `Object`", function () {
      expect(_.isObject(anInstance)).to.be["true"];
      expect(_.isObject({})).to.be["true"];
      expect(_.isObject([])).to.be["true"];
      return expect(_.isObject(function () {
      })).to.be["true"];
    });
    if (_B.isLodash()) {
      return it("`_.isPlainObject` (lodash) is too strict - non `Object` constructed {} are not Object!", function () {
        expect(_.isPlainObject({})).to.be["true"];
        expect(_.isPlainObject(anInstance)).to.be["false"];
        expect(_.isPlainObject([])).to.be["false"];
        return expect(_.isPlainObject(function () {
        })).to.be["false"];
      });
    }
  });
  describe("`_.isHash` recognises all types correctly:", function () {
    var fn, i, len, typeName, value, values;
    for (typeName in oOs) {
      values = oOs[typeName];
      fn = function (typeName, value) {
        return it("`_B.isHash` for '" + typeName + "' returns '" + (typeName === "Object" ? "true" : "false"), function () {
          if (typeName === "Object") {
            return expect(_B.isHash(value)).to.be["true"];
          } else {
            return expect(_B.isHash(value)).to.be["false"];
          }
        });
      };
      for (i = 0, len = values.length; i < len; i++) {
        value = values[i];
        fn(typeName, value);
      }
    }
    return null;
  });
  return describe("isPlain correctly recognises plain (non-nested) value types:", function () {
    var fn, i, isPlainType, len, typeName, value, values;
    isPlainType = function (typeName) {
      return typeName === "String" || typeName === "Date" || typeName === "RegExp" || typeName === "Number" || typeName === "Boolean" || typeName === "Null" || typeName === "Undefined";
    };
    for (typeName in oOs) {
      values = oOs[typeName];
      fn = function (typeName, value) {
        return it("`isPlain` recognises all '" + typeName + "' as a " + (isPlainType(typeName) ? "" : "NON") + " plain type", function () {
          if (isPlainType(typeName)) {
            return expect(_B.isPlain(value)).to.be["true"];
          } else {
            return expect(_B.isPlain(value)).to.be["false"];
          }
        });
      };
      for (i = 0, len = values.length; i < len; i++) {
        value = values[i];
        fn(typeName, value);
      }
    }
    return null;
  });
});

return module.exports;

});
define('uberscore',[],function () {
  if (__isNode) {
  return __nodeRequire('uberscore');
} else {
    return (typeof _B !== 'undefined') ? _B :  (typeof _uB !== 'undefined') ? _uB : __throwMissing('uberscore', '_B, _uB')
}
});
define('uberscore-spec',['require', 'exports', 'module', 'uberscore'], function (require, exports, module) {
  

var l = new _B.Logger('uberscore-spec.js');

describe("uRequire's `rootExports` & `noConflict():` (running on " + (__isNode ? "nodejs" : "Web") + " & loading via " + (__isAMD ? "AMD" : "noAMD/script") + "):", function () {
  var _uB;
  _uB = require("uberscore");
  it("registers globals - RUNS only `if __isWeb and !__isAMD` ", function () {
    if (__isWeb && !__isAMD) {
      return equal(window._B, _uB);
    }
  });
  it("Doesn't register globals & noConflict on AMD (RUNS only `if __isAMD and !__isNode`) ", function () {
    if (__isAMD && !__isNode) {
      return equal(window._B, "Old global `_B`");
    }
  });
  return it("`noConflict()` returns module & sets old values (NOT only `if __isAMD and !__isNode`)", function () {
    if (!__isAMD && !__isNode) {
      equal(window._B.noConflict(), _uB);
      return equal(window._B, "Old global `_B`");
    }
  });
});

return module.exports;

});
define('utils/CalcCachedProperties-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('utils/CalcCachedProperties-spec.js');

var extend = function (child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key))
        child[key] = parent[key];
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    return child;
  }, hasProp = {}.hasOwnProperty;
describe("_B.CalcCachedProperties:", function () {
  var CalcCachedProperties2, DirtyNumbers, SelfishNumber;
  CalcCachedProperties2 = function (superClass) {
    extend(CalcCachedProperties2, superClass);
    function CalcCachedProperties2() {
      return CalcCachedProperties2.__super__.constructor.apply(this, arguments);
    }
    return CalcCachedProperties2;
  }(_B.CalcCachedProperties);
  SelfishNumber = function (superClass) {
    extend(SelfishNumber, superClass);
    function SelfishNumber() {
      SelfishNumber.__super__.constructor.apply(this, arguments);
      this.setNums.apply(this, arguments);
    }
    SelfishNumber.prototype.setNums = function (x, y) {
      this.x = x;
      this.y = y;
      return this.calcHits = {};
    };
    SelfishNumber.calcProperties = {
      doubled: function () {
        this.calcHits.doubled = (this.calcHits.doubled || 0) + 1;
        if (this.x < 1000) {
          return this.x + this.x;
        } else {
          return void 0;
        }
      },
      added: function () {
        this.calcHits.added = (this.calcHits.added || 0) + 1;
        return this.x + 1;
      }
    };
    return SelfishNumber;
  }(CalcCachedProperties2);
  DirtyNumbers = function (superClass) {
    extend(DirtyNumbers, superClass);
    function DirtyNumbers() {
      return DirtyNumbers.__super__.constructor.apply(this, arguments);
    }
    DirtyNumbers.calcProperties = {
      added: function () {
        this.calcHits.added = (this.calcHits.added || 0) + 1;
        return this.x + this.y;
      },
      multiplied: function () {
        this.calcHits.multiplied = (this.calcHits.multiplied || 0) + 1;
        return this.x * this.y;
      }
    };
    return DirtyNumbers;
  }(SelfishNumber);
  describe("Get classes & calcProperties of inherited classes", function () {
    var dn, sn;
    dn = new DirtyNumbers();
    sn = new SelfishNumber();
    describe("called on target instance:", function () {
      it("#1", function () {
        return expect(dn.classes).to.deep.equal([
          _B.CoffeeUtils,
          _B.CalcCachedProperties,
          CalcCachedProperties2,
          SelfishNumber,
          DirtyNumbers
        ]);
      });
      return it("#2", function () {
        return expect(sn.classes).to.deep.equal([
          _B.CoffeeUtils,
          _B.CalcCachedProperties,
          CalcCachedProperties2,
          SelfishNumber
        ]);
      });
    });
    return describe("Get all calculated properties, overriding properties in parent classes:", function () {
      var allDnProperties, allSnProperties;
      allDnProperties = {
        doubled: SelfishNumber.calcProperties.doubled,
        added: DirtyNumbers.calcProperties.added,
        multiplied: DirtyNumbers.calcProperties.multiplied
      };
      allSnProperties = {
        doubled: SelfishNumber.calcProperties.doubled,
        added: SelfishNumber.calcProperties.added
      };
      describe("without params:", function () {
        describe("called on instance:", function () {
          it("#1", function () {
            expect(dn.getAllCalcProperties()).to.deep.equal(allDnProperties);
            return expect(dn.allCalcProperties).to.deep.equal(allDnProperties);
          });
          return it("#2", function () {
            expect(sn.getAllCalcProperties()).to.deep.equal(allSnProperties);
            return expect(sn.allCalcProperties).to.deep.equal(allSnProperties);
          });
        });
        return describe("called statically:", function () {
          it("#1", function () {
            return expect(DirtyNumbers.getAllCalcProperties()).to.deep.equal(allDnProperties);
          });
          return it("#2", function () {
            return expect(SelfishNumber.getAllCalcProperties()).to.deep.equal(allSnProperties);
          });
        });
      });
      describe("with instance as param:", function () {
        describe("called on (any) instance:", function () {
          it("#1", function () {
            return expect(sn.getAllCalcProperties(dn)).to.deep.equal(allDnProperties);
          });
          return it("#2", function () {
            return expect(dn.getAllCalcProperties(sn)).to.deep.equal(allSnProperties);
          });
        });
        return describe("called statically (on any class):", function () {
          it("#1", function () {
            expect(DirtyNumbers.getAllCalcProperties(dn)).to.deep.equal(allDnProperties);
            expect(SelfishNumber.getAllCalcProperties(dn)).to.deep.equal(allDnProperties);
            return expect(_B.CalcCachedProperties.getAllCalcProperties(dn)).to.deep.equal(allDnProperties);
          });
          return it("#2", function () {
            expect(DirtyNumbers.getAllCalcProperties(sn)).to.deep.equal(allSnProperties);
            expect(SelfishNumber.getAllCalcProperties(sn)).to.deep.equal(allSnProperties);
            return expect(_B.CalcCachedProperties.getAllCalcProperties(sn)).to.deep.equal(allSnProperties);
          });
        });
      });
      return describe("with class as param:", function () {
        describe("called on (any) instance:", function () {
          it("#1", function () {
            return expect(sn.getAllCalcProperties(DirtyNumbers)).to.deep.equal(allDnProperties);
          });
          return it("#2", function () {
            return expect(dn.getAllCalcProperties(SelfishNumber)).to.deep.equal(allSnProperties);
          });
        });
        return describe("called statically (on any class):", function () {
          it("#1", function () {
            expect(_B.CalcCachedProperties.getAllCalcProperties(DirtyNumbers)).to.deep.equal(allDnProperties);
            return expect(SelfishNumber.getAllCalcProperties(DirtyNumbers)).to.deep.equal(allDnProperties);
          });
          return it("#2", function () {
            expect(_B.CalcCachedProperties.getAllCalcProperties(SelfishNumber)).to.deep.equal(allSnProperties);
            return expect(DirtyNumbers.getAllCalcProperties(SelfishNumber)).to.deep.equal(allSnProperties);
          });
        });
      });
    });
  });
  describe("calculating & caching properties:", function () {
    var dn, dn2;
    dn = new DirtyNumbers(3, 4);
    dn2 = new DirtyNumbers(5, 6);
    describe("calculates calcProperties once:", function () {
      it("#1", function () {
        expect(dn.doubled).to.equal(6);
        expect(dn.doubled).to.equal(6);
        expect(dn.calcHits.doubled).to.equal(1);
        expect(dn.added).to.equal(7);
        expect(dn.added).to.equal(7);
        expect(dn.calcHits.added).to.equal(1);
        expect(dn.multiplied).to.equal(12);
        expect(dn.multiplied).to.equal(12);
        return expect(dn.calcHits.multiplied).to.equal(1);
      });
      return it("#2", function () {
        expect(dn2.doubled).to.equal(10);
        expect(dn2.doubled).to.equal(10);
        expect(dn2.calcHits.doubled).to.equal(1);
        expect(dn2.added).to.equal(11);
        expect(dn2.added).to.equal(11);
        expect(dn2.calcHits.added).to.equal(1);
        expect(dn2.multiplied).to.equal(30);
        expect(dn2.multiplied).to.equal(30);
        return expect(dn2.calcHits.multiplied).to.equal(1);
      });
    });
    describe("remembers cached result, without calculating", function () {
      it("#1", function () {
        dn.x = 5;
        dn.y = 4;
        expect(dn.added).to.equal(7);
        expect(dn.added).to.equal(7);
        expect(dn.calcHits.added).to.equal(1);
        expect(dn.multiplied).to.equal(12);
        expect(dn.multiplied).to.equal(12);
        return expect(dn.calcHits.multiplied).to.equal(1);
      });
      return it("#2", function () {
        dn2.x = 2;
        dn2.y = 3;
        expect(dn2.added).to.equal(11);
        expect(dn2.added).to.equal(11);
        expect(dn2.calcHits.added).to.equal(1);
        expect(dn2.multiplied).to.equal(30);
        expect(dn2.multiplied).to.equal(30);
        return expect(dn2.calcHits.multiplied).to.equal(1);
      });
    });
    return describe("clearing cached property value & recalculate 'em:", function () {
      it("clears cached properties by name & recalculates them on demand", function () {
        expect(dn.cleanProps("added")).to.deep.equal(["added"]);
        dn.x = 6;
        dn.y = 3;
        expect(dn.calcHits.added).to.equal(1);
        expect(dn.added).to.equal(9);
        expect(dn.calcHits.added).to.equal(2);
        expect(dn.added).to.equal(9);
        expect(dn.added).to.equal(9);
        expect(dn.calcHits.added).to.equal(2);
        expect(dn.calcHits.multiplied).to.equal(1);
        expect(dn.multiplied).to.equal(12);
        expect(dn.multiplied).to.equal(12);
        return expect(dn.calcHits.multiplied).to.equal(1);
      });
      it("clears cached property values by name or function, ignoring undefined", function () {
        dn.x = 6;
        dn.y = 4;
        expect(dn.cleanProps(void 0, "doubled", void 0, function (nme) {
          return nme === "multiplied";
        }, void 0)).to.deep.equal([
          "doubled",
          "multiplied"
        ]);
        expect(dn.calcHits.doubled).to.equal(1);
        expect(dn.doubled).to.equal(12);
        expect(dn.doubled).to.equal(12);
        expect(dn.calcHits.doubled).to.equal(2);
        expect(dn.calcHits.added).to.equal(2);
        expect(dn.added).to.equal(9);
        expect(dn.added).to.equal(9);
        expect(dn.calcHits.added).to.equal(2);
        expect(dn.calcHits.multiplied).to.equal(1);
        expect(dn.multiplied).to.equal(24);
        expect(dn.multiplied).to.equal(24);
        return expect(dn.calcHits.multiplied).to.equal(2);
      });
      return describe("clears all cached property values, recalculates them all on demand", function () {
        it("clears all cached property values", function () {
          return expect(dn.cleanProps()).to.deep.equal([
            "doubled",
            "added",
            "multiplied"
          ]);
        });
        it("clearing forces recaclulation of inherited property value", function () {
          dn.setNums(4, 7);
          expect(dn.calcHits.doubled).to.equal(void 0);
          expect(dn.doubled).to.equal(8);
          expect(dn.doubled).to.equal(8);
          return expect(dn.calcHits.doubled).to.equal(1);
        });
        return it("clearing forces recaclulation of property value", function () {
          dn.setNums(4, 7);
          expect(dn.calcHits.added).to.equal(void 0);
          expect(dn.added).to.equal(11);
          expect(dn.added).to.equal(11);
          expect(dn.calcHits.added).to.equal(1);
          expect(dn.calcHits.multiplied).to.equal(void 0);
          expect(dn.multiplied).to.equal(28);
          expect(dn.multiplied).to.equal(28);
          return expect(dn.calcHits.multiplied).to.equal(1);
        });
      });
    });
  });
  return describe("undefined is a valid cached result", function () {
    var dn;
    dn = new DirtyNumbers(1001);
    return it("undefined is a valid cached result", function () {
      expect(dn.calcHits.doubled).to.equal(void 0);
      expect(dn.doubled).to.equal(void 0);
      expect(dn.calcHits.doubled).to.equal(1);
      expect(dn.doubled).to.equal(void 0);
      expect(dn.doubled).to.equal(void 0);
      expect(dn.calcHits.doubled).to.equal(1);
      expect(dn.cleanProps("doubled")).to.deep.equal(["doubled"]);
      dn.setNums(5);
      expect(dn.calcHits.doubled).to.equal(void 0);
      expect(dn.doubled).to.equal(10);
      expect(dn.calcHits.doubled).to.equal(1);
      expect(dn.doubled).to.equal(10);
      expect(dn.doubled).to.equal(10);
      return expect(dn.calcHits.doubled).to.equal(1);
    });
  });
});

return module.exports;

});
define('utils/CoffeeUtils-spec',['require', 'exports', 'module'], function (require, exports, module) {
  

var l = new _B.Logger('utils/CoffeeUtils-spec.js');

var extend = function (child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key))
        child[key] = parent[key];
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    return child;
  }, hasProp = {}.hasOwnProperty;
describe("Get classes of inherited classes", function () {
  var OtherClass, SubClass, SubSubClass, sc, ssc;
  OtherClass = function (superClass) {
    extend(OtherClass, superClass);
    function OtherClass() {
      return OtherClass.__super__.constructor.apply(this, arguments);
    }
    return OtherClass;
  }(_B.CoffeeUtils);
  SubClass = function (superClass) {
    extend(SubClass, superClass);
    function SubClass() {
      return SubClass.__super__.constructor.apply(this, arguments);
    }
    return SubClass;
  }(OtherClass);
  SubSubClass = function (superClass) {
    extend(SubSubClass, superClass);
    function SubSubClass() {
      return SubSubClass.__super__.constructor.apply(this, arguments);
    }
    return SubSubClass;
  }(SubClass);
  sc = new SubClass();
  ssc = new SubSubClass();
  return describe("Get extending classes in descenting order, including the own as last:", function () {
    var scClasses, sscClasses;
    scClasses = [
      _B.CoffeeUtils,
      OtherClass,
      SubClass
    ];
    sscClasses = [
      _B.CoffeeUtils,
      OtherClass,
      SubClass,
      SubSubClass
    ];
    describe("without params:", function () {
      describe("called on target instance:", function () {
        it("#1", function () {
          return expect(ssc.getClasses()).to.deep.equal(sscClasses);
        });
        return it("#2", function () {
          return expect(sc.getClasses()).to.deep.equal(scClasses);
        });
      });
      return describe("called staticically (on target class):", function () {
        it("#1", function () {
          return expect(SubSubClass.getClasses()).to.deep.equal(sscClasses);
        });
        return it("#2", function () {
          return expect(SubClass.getClasses()).to.deep.equal(scClasses);
        });
      });
    });
    describe("with instance as param:", function () {
      describe("called on (any) instance:", function () {
        it("#1", function () {
          return expect(sc.getClasses(ssc)).to.deep.equal(sscClasses);
        });
        return it("#2", function () {
          return expect(ssc.getClasses(sc)).to.deep.equal(scClasses);
        });
      });
      return describe("called statically (on any class):", function () {
        it("#1", function () {
          expect(_B.CoffeeUtils.getClasses(ssc)).to.deep.equal(sscClasses);
          expect(SubClass.getClasses(ssc)).to.deep.equal(sscClasses);
          return expect(SubSubClass.getClasses(ssc)).to.deep.equal(sscClasses);
        });
        return it("#2", function () {
          expect(_B.CoffeeUtils.getClasses(sc)).to.deep.equal(scClasses);
          expect(SubClass.getClasses(sc)).to.deep.equal(scClasses);
          return expect(SubSubClass.getClasses(sc)).to.deep.equal(scClasses);
        });
      });
    });
    return describe("with class as param:", function () {
      describe("called on (any) instance:", function () {
        it("#1", function () {
          return expect(sc.getClasses(SubSubClass)).to.deep.equal(sscClasses);
        });
        return it("#2", function () {
          return expect(ssc.getClasses(SubClass)).to.deep.equal(scClasses);
        });
      });
      return describe("called staticically (on any class):", function () {
        it("#1", function () {
          return expect(SubClass.getClasses(SubSubClass)).to.deep.equal(sscClasses);
        });
        return it("#2", function () {
          return expect(SubSubClass.getClasses(SubClass)).to.deep.equal(scClasses);
        });
      });
    });
  });
});

return module.exports;

});

    var data = require('spec-data');
    var spH = require('specHelpers');

  var equal = spH["equal"], notEqual = spH["notEqual"], ok = spH["ok"], notOk = spH["notOk"], tru = spH["tru"], fals = spH["fals"], deepEqual = spH["deepEqual"], notDeepEqual = spH["notDeepEqual"], exact = spH["exact"], notExact = spH["notExact"], iqual = spH["iqual"], notIqual = spH["notIqual"], ixact = spH["ixact"], notIxact = spH["notIxact"], like = spH["like"], notLike = spH["notLike"], likeBA = spH["likeBA"], notLikeBA = spH["notLikeBA"], equalSet = spH["equalSet"], notEqualSet = spH["notEqualSet"], expect = chai["expect"];

require('agreement/inAgreements-spec');
require('agreement/isAgree-spec');
require('blending/ArrayizeBlender-spec');
require('blending/Blender-spec');
require('blending/clone-spec');
require('blending/DeepDefaultsBlender-spec');
require('blending/deepExtend-spec');
require('blending/lodash-merge-spec');
require('blending/Mergers_Blender-spec');
require('blending/shared/deepExtendExamples-specs');
require('blending/shared/lodashMerge_Blender-specs');
require('blending/shared/lodashMerge-specs');
require('blending/traverse-spec');
require('collections/array/arrayize-spec');
require('collections/array/isEqualArraySet-spec');
require('Logger-spec');
require('objects/getInheritedPropertyNames-spec');
require('objects/getp-spec');
require('objects/getRefs-spec');
require('objects/isDisjoint-spec');
require('objects/isEqual-spec');
require('objects/isOK-True-False-spec');
require('objects/isRefDisjoint-spec');
require('objects/mutate-spec');
require('objects/okv-spec');
require('objects/setp-spec');
require('spec-data');
require('specHelpers');
require('types/types-spec');
require('uberscore-spec');
require('utils/CalcCachedProperties-spec');
require('utils/CoffeeUtils-spec');
};
if (__isAMD) {
  return define(['uberscore', 'uberscore', 'lodash', 'chai'], bundleFactory);
} else {
    if (__isNode) {
        return module.exports = bundleFactory(require('uberscore'), require('uberscore'), require('lodash'), require('chai'));
    } else {
        return bundleFactory((typeof _B !== 'undefined') ? _B :  (typeof _uB !== 'undefined') ? _uB : __throwMissing('uberscore', '_B, _uB'), (typeof _B !== 'undefined') ? _B :  (typeof _uB !== 'undefined') ? _uB : __throwMissing('uberscore', '_B, _uB'), (typeof _ !== 'undefined') ? _ : __throwMissing('lodash', '_'), (typeof chai !== 'undefined') ? chai : __throwMissing('chai', 'chai'));
    }
}
}).call(this, (typeof exports === 'object' || typeof window === 'undefined' ? global : window),
              (typeof exports === 'object' || typeof window === 'undefined' ? global : window))
