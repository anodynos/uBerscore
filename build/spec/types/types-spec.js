// Generated by uRequire v0.5.0beta1
(function () {
  var __isAMD = (typeof define === 'function' && define.amd),
    __isNode = (typeof exports === 'object'),
    __isWeb = !__isNode;
(function (root,factory) {
  if (typeof exports === 'object') {
   var nr = new (require('urequire').NodeRequirer) ('types/types-spec', module, __dirname, '.');
   module.exports = factory(nr.require, exports, module, nr.require('lodash'), nr.require('agreement/isAgree'), nr.require('chai'), nr.require('uberscore'), nr.require('../spec-data'));
 } else if (typeof define === 'function' && define.amd) {
     define(['require', 'exports', 'module', 'lodash', 'agreement/isAgree', 'chai', 'uberscore', '../spec-data'], factory);
 }
})(this,function (require, exports, module, _, isAgree, chai, _B, data) {
  // uRequire: start body of original nodejs module
var A, AClass, anInstance, assert, chai, expect, l, oOs, _, _B;

chai = require("chai");

assert = chai.assert;

expect = chai.expect;

_ = require("lodash");

_B = require("uberscore");

l = new _B.Logger("type-spec");

AClass = function() {
    function AClass(prop) {
        this.prop = prop != null ? prop : "a property value";
    }
    return AClass;
}();

anInstance = new AClass;

oOs = {
    Array: [ [ "this", "is", 1, "array" ], new Array(1, 2, 3) ],
    Arguments: [ function() {
        return arguments;
    }() ],
    Function: [ function(x) {
        return x;
    }, new Function("var a = 'a'"), A = function() {
        function A() {}
        return A;
    }(), function() {} ],
    String: [ "I am a String!", new String("I am another String") ],
    Number: [ 667, new Number(668.13) ],
    Date: [ new Date ],
    RegExp: [ /./g, new RegExp("/./") ],
    Boolean: [ true, false, new Boolean(true) ],
    Null: [ null ],
    Undefined: [ void 0, void 0, function() {}() ],
    Object: [ {
        someProp: "SomeVal"
    }, anInstance, new Object, new function() {} ]
};

describe("types & its associates:", function() {
    describe("`type` distisquishes all types", function() {
        var typeName, value, values, _fn, _i, _len;
        for (typeName in oOs) {
            values = oOs[typeName];
            _fn = function(typeName, value, longType, shortType) {
                return it("`type` recognises value of type '" + typeName + "' both as long='" + longType + "', as short='" + shortType, function() {
                    expect(longType).to.equal(_B.type.toLong(typeName));
                    expect(_B.type.isType(longType)).to.be["true"];
                    expect(shortType).to.equal(_B.type.toShort(typeName));
                    expect(_B.type.isType(shortType)).to.be["true"];
                    expect(_B.type.areEqual(longType, shortType)).to.be["true"];
                    return null;
                });
            };
            for (_i = 0, _len = values.length; _i < _len; _i++) {
                value = values[_i];
                _fn(typeName, value, _B.type(value), _B.type(value, true));
            }
            null;
        }
        return null;
    });
    describe("`type` recognises all Object/Hashes {} correctly :", function() {
        return it("`type` correctly treats instances as Object, unlike lodash's `_.isPlainObject(anInstance) is false`", function() {
            expect(_.isPlainObject(anInstance)).to.be["false"];
            return expect(_B.type(anInstance)).to.equal("Object");
        });
    });
    describe("`_B.isObject` uses the above to solve distinquishing an {} from other types (->, []), even if {} is an instance.", function() {
        it("`_B.isObject` recognises all {} as Objects, all Arrays & Functions are NON Objects", function() {
            expect(_B.isObject(anInstance)).to.be["true"];
            expect(_B.isObject({})).to.be["true"];
            expect(_B.isObject([])).to.be["false"];
            return expect(_B.isObject(function() {})).to.be["false"];
        });
        it("`_.isObject` is too broad - considers Arrays & Functions as `Object`", function() {
            expect(_.isObject(anInstance)).to.be["true"];
            expect(_.isObject({})).to.be["true"];
            expect(_.isObject([])).to.be["true"];
            return expect(_.isObject(function() {})).to.be["true"];
        });
        return it("`_.isPlainObject` (lodash) is too strict - non `Object` constructed {} are not Object!", function() {
            expect(_.isPlainObject({})).to.be["true"];
            expect(_.isPlainObject(anInstance)).to.be["false"];
            expect(_.isPlainObject([])).to.be["false"];
            return expect(_.isPlainObject(function() {})).to.be["false"];
        });
    });
    describe("`isObject` recognises all types correctly:", function() {
        var typeName, value, values, _fn, _i, _len;
        for (typeName in oOs) {
            values = oOs[typeName];
            _fn = function(typeName, value) {
                return it("`isObject` for '" + typeName + "' returns '" + (typeName === "Object" ? "true" : "false"), function() {
                    if (typeName === "Object") {
                        expect(_B.isObject(value)).to.be["true"];
                    } else {
                        expect(_B.isObject(value)).to.be["false"];
                    }
                    return null;
                });
            };
            for (_i = 0, _len = values.length; _i < _len; _i++) {
                value = values[_i];
                _fn(typeName, value);
            }
            null;
        }
        return null;
    });
    return describe("isPlain correctly recognises plain (non-nested) value types:", function() {
        var isPlainType, typeName, value, values, _fn, _i, _len;
        isPlainType = function(typeName) {
            return typeName === "String" || typeName === "Date" || typeName === "RegExp" || typeName === "Number" || typeName === "Boolean" || typeName === "Null" || typeName === "Undefined";
        };
        for (typeName in oOs) {
            values = oOs[typeName];
            _fn = function(typeName, value) {
                return it("`isPlain` recognises all '" + typeName + "' as a " + (isPlainType(typeName) ? "" : "NON") + " plain type", function() {
                    if (isPlainType(typeName)) {
                        expect(_B.isPlain(value)).to.be["true"];
                    } else {
                        expect(_B.isPlain(value)).to.be["false"];
                    }
                    return null;
                });
            };
            for (_i = 0, _len = values.length; _i < _len; _i++) {
                value = values[_i];
                _fn(typeName, value);
            }
            null;
        }
        return null;
    });
});
// uRequire: end body of original nodejs module


return module.exports;
})
})();