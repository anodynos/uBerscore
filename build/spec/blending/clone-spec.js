// Generated by uRequire v0.7.0-beta8 - template: 'UMDplain' 
(function () {
  
var __isAMD = !!(typeof define === 'function' && define.amd),
    __isNode = (typeof exports === 'object'),
    __isWeb = !__isNode;
(function (factory) {
  if (typeof exports === 'object') {
    module.exports = factory(require, exports, module, require('lodash'), require('chai'), require('uberscore'), require('../spec-data'), require('../specHelpers'));
} else if (typeof define === 'function' && define.amd) { define(['require', 'exports', 'module', 'lodash', 'chai', 'uberscore', '../spec-data', '../specHelpers'], factory) } else throw new Error('uRequire: Loading UMD module as <script>, without `build.noLoaderUMD`');
}).call(this, function (require, exports, module, _, chai, _B, data, spH) {
  

var equal = spH["equal"],notEqual = spH["notEqual"],ok = spH["ok"],notOk = spH["notOk"],tru = spH["tru"],fals = spH["fals"],deepEqual = spH["deepEqual"],notDeepEqual = spH["notDeepEqual"],exact = spH["exact"],notExact = spH["notExact"],iqual = spH["iqual"],notIqual = spH["notIqual"],ixact = spH["ixact"],notIxact = spH["notIxact"],like = spH["like"],notLike = spH["notLike"],likeBA = spH["likeBA"],notLikeBA = spH["notLikeBA"],equalSet = spH["equalSet"],notEqualSet = spH["notEqualSet"];
var expect = chai["expect"];


var l = new _B.Logger('blending/clone-spec.js');

return describe("_B.clone:", function () {
    var checkDeep, checkShallow;
    checkShallow = function (o1, o2) {
      expect(o1, o2).not.same;
      expect(o1, o2).deep.equal;
      expect(_B.isExact(o1, o2)).to.be["true"];
      expect(_B.isRefDisjoint(o1, o2)).to.be["false"];
      return _.each(o1, function (v, key) {
        return expect(o1[key]).equals(o2[key]);
      });
    };
    checkDeep = function (o1, o2) {
      expect(o1, o2).not.same;
      expect(o1, o2).deep.equal;
      expect(_B.isExact(o1, o2)).to.be["false"];
      expect(_B.isRefDisjoint(o1, o2)).to.be["true"];
      return _.each(o1, function (v, key) {
        if (!_B.isPlain(o1[key])) {
          return expect(o1[key]).not.equals(o2[key]);
        }
      });
    };
    describe("simple clonning:", function () {
      var obj;
      obj = [
        { a: 1 },
        { b: { b2: 2 } }
      ];
      it("defaults to shallow copy", function () {
        return checkShallow(obj, _B.clone(obj));
      });
      return describe("copies deep with option deep:", function () {
        it("as boolean", function () {
          return checkDeep(obj, _B.clone(obj, true));
        });
        return it("as options `deep` key", function () {
          return checkDeep(obj, _B.clone(obj, { deep: true }));
        });
      });
    });
    return describe("with copyProto:", function () {
      var Creator, creatorPrototype, obj;
      Creator = function () {
        this.a = 1;
        this.b = { b2: 2 };
        return this;
      };
      creatorPrototype = { creatorPrototype: "hereIam" };
      Creator.prototype.creatorPrototype = creatorPrototype;
      obj = new Creator();
      it("defaults to shallow copy", function () {
        var cloned;
        cloned = _B.clone(obj, { copyProto: true });
        checkShallow(obj, cloned);
        return expect(Object.getPrototypeOf(obj), Object.getPrototypeOf(cloned)).to.be.equal;
      });
      return it("with option deep", function () {
        var cloned;
        cloned = _B.clone(obj, { deep: true });
        checkDeep(obj, cloned);
        return expect(Object.getPrototypeOf(obj), Object.getPrototypeOf(cloned)).to.be.equal;
      });
    });
  });


})
}).call(this)