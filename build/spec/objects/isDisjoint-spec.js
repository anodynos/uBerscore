// Generated by uRequire v0.3.0beta1
(function () {
  var __isAMD = (typeof define === 'function' && define.amd),
    __isNode = (typeof exports === 'object'),
    __isWeb = !__isNode;
(function (root,factory) {
  if (typeof exports === 'object') {
   var nr = new (require('urequire').NodeRequirer) ('objects/isDisjoint-spec', module, __dirname, '.');
   module.exports = factory(nr.require, exports, module, nr.require('lodash'), nr.require('agreement/isAgree'), nr.require('chai'), nr.require('uberscore'), nr.require('../spec-data'));
 } else if (typeof define === 'function' && define.amd) {
     define(['require', 'exports', 'module', 'lodash', 'agreement/isAgree', 'chai', 'uberscore', '../spec-data'], factory);
 }
})(this,function (require, exports, module, _, isAgree, chai, _B, data) {
  // uRequire: start body of original nodejs module
var assert, expect;

assert = chai.assert;

expect = chai.expect;

describe("isDisjoint:", function() {
    describe("with primitives:", function() {
        describe("arrays:", function() {
            it("recognises disjoint:", function() {
                expect(_B.isDisjoint([ 1, 2, 3 ], [ 4, 5, 6, "1" ])).to.be["true"];
                return expect(_.intersection([ 1, 2, 3 ], [ 4, 5, 6, "1" ])).to.be.an("array").and.is.empty;
            });
            return it("recognises non disjoint:", function() {
                expect(_B.isDisjoint([ 1, 2, 3 ], [ 4, 2, 5 ])).to.be["false"];
                return expect(_.intersection([ 1, 2, 3 ], [ 4, 2, 5 ])).to.deep.equal([ 2 ]);
            });
        });
        return describe("arrays & objects:", function() {
            it("recognises disjoint in [] & {}:", function() {
                return expect(_B.isDisjoint([ 4, 5, 6 ], {
                    a: 1,
                    b: 7,
                    c: 8
                })).to.be["true"];
            });
            return it("recognises non disjoint in [] & {}:", function() {
                return expect(_B.isDisjoint([ 1, 2, 3 ], {
                    a: 1,
                    b: 7,
                    c: 8
                })).to.be["false"];
            });
        });
    });
    return describe("with references:", function() {
        var o1, o2, o3, o4;
        o1 = {
            p1: 1
        };
        o2 = {
            p2: 2
        };
        o3 = {
            p3: 3
        };
        o4 = {
            p4: 4
        };
        describe("arrays:", function() {
            it("recognises disjoint:", function() {
                expect(_B.isDisjoint([ o1, o2 ], [ {
                    p1: 1
                }, o3, o4 ])).to.be["true"];
                return expect(_.intersection([ o1, o2 ], [ {
                    p1: 1
                }, o3, o4 ])).to.deep.equal([]);
            });
            return it("recognises non disjoint:", function() {
                expect(_B.isDisjoint([ o1, o2 ], [ {
                    p1: 1
                }, o3, o4, o2 ])).to.be["false"];
                return expect(_.intersection([ o1, o2 ], [ {
                    p1: 1
                }, o3, o4, o2 ])).to.deep.equal([ o2 ]);
            });
        });
        describe("arrays & objects:", function() {
            it("recognises disjoint in [] & {}", function() {
                return expect(_B.isDisjoint([ o1, o2 ], {
                    p1: 1,
                    o3: o3,
                    o4: o4
                })).to.be["true"];
            });
            return it("recognises non disjoint in [] & {}:", function() {
                return expect(_B.isDisjoint([ o1, o2 ], {
                    p1: 1,
                    o3: o3,
                    o4: o4,
                    o2: o2
                })).to.be["false"];
            });
        });
        return describe("equality using _.isEqual :", function() {
            it("recognises disjoint in [] & {}, without _.isEqual", function() {
                return expect(_B.isDisjoint([ o1, o2 ], {
                    someP: {
                        p1: 1
                    },
                    o3: o3
                })).to.be["true"];
            });
            return it("recognises non disjoint in [] & {}, when using _.isEqual", function() {
                return expect(_B.isDisjoint([ o1, o2 ], {
                    someP: {
                        p1: 1
                    },
                    o3: o3
                }, _.isEqual)).to.be["false"];
            });
        });
    });
});
// uRequire: end body of original nodejs module


return module.exports;
})
})();