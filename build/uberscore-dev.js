/**
* uberscore https://github.com/anodynos/uBerscore
*
* uBerscore js is (still) an early experiment: a 'higher' level data manipulator for all kinds of js collections (objects+arrays); it offers functionality & shortcuts that underscore doesn't, wouldn't, shouldn't have.
* Version 0.0.18 - Compiled on 2016-02-24 21:18:59
* Repository git://github.com/anodynos/uBerscore
* Copyright(c) 2016 Agelos Pikoulas <agelos.pikoulas@gmail.com>
* License MIT http://www.opensource.org/licenses/mit-license.php
*/

// Generated by uRequire v0.7.0-beta.25 target: 'dev' template: 'combined'
// Combined template optimized with RequireJS/r.js v2.1.22 & almond v0.3.1.
(function (global, window){
  
var __isAMD = !!(typeof define === 'function' && define.amd),
    __isNode = (typeof exports === 'object'),
    __isWeb = !__isNode;


  var __nodeRequire = (__isNode ? require : function(dep){
        throw new Error("uRequire: combined template 'dev', trying to load `node` dep `" + dep + "` in non-nodejs runtime (browser).")
      }),
      __throwMissing = function(dep, vars) {
        throw new Error("uRequire: combined template 'dev', detected missing dependency `" + dep + "` - all it's known binding variables `" + vars + "` were undefined")
      },
      __throwExcluded = function(dep, descr) {
        throw new Error("uRequire: combined template 'dev', trying to access unbound / excluded `" + descr + "` dependency `" + dep + "` on browser");
      };

  var bind = function (fn, me) {
      return function () {
        return fn.apply(me, arguments);
      };
    }, extend = function (child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty, slice = [].slice, indexOf = [].indexOf || function (item) {
      for (var i = 0, l = this.length; i < l; i++) {
        if (i in this && this[i] === item)
          return i;
      }
      return -1;
    };
var bundleFactory = function(_) {
/**
 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                //Lop off the last part of baseParts, so that . matches the
                //"directory" and not name of the baseName's module. For instance,
                //baseName of "one/two/three", maps to "one/two/three.js", but we
                //want the directory, "one/two" for this normalization.
                name = baseParts.slice(0, baseParts.length - 1).concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("almond", function(){});

define('util',[],function () {
  if (__isNode) {
  return __nodeRequire('util');
} else {
    __throwExcluded('util', 'node-only & local');
}
});
define('types/type',['require', 'exports', 'module'], function (require, exports, module) {
  

var type, indexOf = [].indexOf || function (item) {
    for (var i = 0, l = this.length; i < l; i++) {
      if (i in this && this[i] === item)
        return i;
    }
    return -1;
  };
type = function (o, isShort) {
  var long, ref, shorts;
  if (isShort == null) {
    isShort = false;
  }
  ref = type.TYPES;
  for (long in ref) {
    shorts = ref[long];
    if (_["is" + long](o)) {
      if (isShort) {
        return shorts[0];
      } else {
        return long;
      }
    }
  }
  return "UNKNOWN";
};
type.toShort = function (aType) {
  var longType, ref, shorts;
  if (type.TYPES[aType]) {
    return type.TYPES[aType][0];
  } else {
    ref = type.TYPES;
    for (longType in ref) {
      shorts = ref[longType];
      if (indexOf.call(shorts, aType) >= 0) {
        return shorts[0];
      }
    }
  }
};
type.toLong = function (aType) {
  var longType, ref, shorts;
  if (type.TYPES[aType]) {
    return aType;
  } else {
    ref = type.TYPES;
    for (longType in ref) {
      shorts = ref[longType];
      if (indexOf.call(shorts, aType) >= 0) {
        return longType;
      }
    }
  }
};
type.areEqual = function (aType, bType) {
  return type.toShort(aType) === type.toShort(bType);
};
type.isType = function (aType) {
  var ref;
  return ref = type.toLong(aType), indexOf.call(_.keys(type.TYPES), ref) >= 0;
};
type.TYPES = {
  "Arguments": [
    "args",
    "..."
  ],
  "Array": [
    "[]",
    "A"
  ],
  "Function": [
    "->",
    "F"
  ],
  "String": [
    "''",
    "S",
    "\"\""
  ],
  "Date": ["D"],
  "RegExp": [
    "//",
    "R"
  ],
  "Number": ["N"],
  "Boolean": ["B"],
  "Object": [
    "{}",
    "O"
  ],
  "Null": [
    "null",
    "-"
  ],
  "Undefined": [
    "U",
    "void",
    "?"
  ]
};
module.exports = type;

return module.exports;

});
define('objects/getp',['require', 'exports', 'module'], function (require, exports, module) {
  

var defaultOptions, getp;
defaultOptions = {
  separator: "/",
  stopKey: "#",
  terminateKey: void 0,
  defaultKey: "*",
  isReturnLast: false
};
getp = function (o, path, options) {
  var i, lastO, len, op, p, returnWithTerminator;
  if (options == null) {
    options = defaultOptions;
  }
  if (options !== defaultOptions) {
    _.defaults(options, defaultOptions);
  }
  if (!_.isArray(path)) {
    if (_.isString(path)) {
      path = path.split(options.separator);
    } else {
      if (_.isNumber(path)) {
        path = [path + ""];
      } else {
        if (path === void 0) {
          return o;
        } else {
          throw "_B.getp Error: invalid path: " + path;
        }
      }
    }
  }
  for (i = 0, len = path.length; i < len; i++) {
    p = path[i];
    if (!(p + "")) {
      continue;
    }
    if (o !== void 0) {
      lastO = o;
    }
    if (!_.isObject(o)) {
      o = void 0;
      break;
    }
    if (options.terminateKey) {
      if (o[options.terminateKey]) {
        returnWithTerminator = {};
        returnWithTerminator[options.terminateKey] = o[options.terminateKey];
        o = returnWithTerminator;
        break;
      }
    }
    if ((op = o[p]) !== void 0) {
      o = op;
    } else {
      if (options.stopKey && o[options.stopKey] !== void 0) {
        o = o[options.stopKey];
        break;
      } else {
        o = options.defaultKey && o[options.defaultKey] ? o[options.defaultKey] : void 0;
      }
    }
  }
  if (o === void 0) {
    if (options.isReturnLast) {
      return lastO;
    } else {
      return o;
    }
  } else {
    return o;
  }
};
module.exports = getp;

return module.exports;

});
define('types/isHash',['require', 'exports', 'module', './type'], function (require, exports, module, type) {
  

return function (o) {
    return type(o) === "Object";
  };


});
define('utils/CoffeeUtils',['require', 'exports', 'module'], function (require, exports, module) {
  

var CoffeeUtils;
  return CoffeeUtils = function () {
    function CoffeeUtils() {
    }
    CoffeeUtils.prototype.getClasses = function (instOrClass, _classes) {
      if (_classes == null) {
        _classes = [];
      }
      if (!instOrClass) {
        instOrClass = this;
      }
      if (typeof instOrClass !== "function") {
        instOrClass = instOrClass.constructor;
      }
      _classes.unshift(instOrClass);
      if (instOrClass.__super__) {
        return this.getClasses(instOrClass.__super__.constructor, _classes);
      } else {
        return _classes;
      }
    };
    CoffeeUtils.getClasses = CoffeeUtils.prototype.getClasses;
    return CoffeeUtils;
  }();


});
define('utils/subclass',['require', 'exports', 'module'], function (require, exports, module) {
  

var subclass;
subclass = module.exports = function (protoProps, staticProps) {
  var Surrogate, child, parent;
  parent = this;
  child = void 0;
  if (protoProps && _.has(protoProps, "constructor")) {
    child = protoProps.constructor;
  } else {
    child = function () {
      return parent.apply(this, arguments);
    };
  }
  _.extend(child, parent, staticProps);
  Surrogate = function () {
    this.constructor = child;
    return this;
  };
  Surrogate.prototype = parent.prototype;
  child.prototype = new Surrogate();
  if (protoProps) {
    _.extend(child.prototype, protoProps);
  }
  child.__super__ = parent.prototype;
  return child;
};

return module.exports;

});
define('agreement/isAgree',['require', 'exports', 'module'], function (require, exports, module) {
  

return function (o, agreement) {
    if (_.isRegExp(agreement)) {
      return agreement.test(o + "");
    } else {
      if (_.isFunction(agreement)) {
        return agreement(o);
      } else {
        if (agreement === void 0) {
          return true;
        } else {
          if (_.isEqual(o, agreement)) {
            return true;
          } else {
            return o + "" === agreement + "";
          }
        }
      }
    }
  };


});
define('collections/array/arrayize',['require', 'exports', 'module', '../../agreement/isAgree'], function (require, exports, module) {
  

var isAgree, arrayize;
isAgree = require("../../agreement/isAgree");
arrayize = function (item) {
  if (_.isArray(item)) {
    return item;
  } else {
    if (_.isUndefined(item) || _.isNull(item)) {
      return [];
    } else {
      return [item];
    }
  }
};
module.exports = arrayize;

return module.exports;

});
define('agreement/inAgreements',['require', 'exports', 'module', '../collections/array/arrayize', './isAgree'], function (require, exports, module) {
  

var arrayize, isAgree;
arrayize = require("../collections/array/arrayize");
isAgree = require("./isAgree");
module.exports = function (o, agreements) {
  var agr, i, len;
  agreements = arrayize(agreements);
  if (_.isEmpty(agreements)) {
    return false;
  } else {
    for (i = 0, len = agreements.length; i < len; i++) {
      agr = agreements[i];
      if (isAgree(o, agr)) {
        return true;
      }
    }
  }
  return false;
};

return module.exports;

});
define('objects/setp',['require', 'exports', 'module'], function (require, exports, module) {
  

var defaultOptions, setp;
defaultOptions = {
  separator: "/",
  create: true,
  overwrite: false
};
setp = function (o, path, val, options) {
  var i, len, newObj, p, pi;
  if (options == null) {
    options = defaultOptions;
  }
  if (options !== defaultOptions) {
    _.defaults(options, defaultOptions);
  }
  if (!_.isArray(path)) {
    if (_.isString(path)) {
      path = path.split(options.separator);
      path = function () {
        var i, len, results;
        results = [];
        for (i = 0, len = path.length; i < len; i++) {
          p = path[i];
          if (p) {
            results.push(p);
          }
        }
        return results;
      }();
    } else {
      throw "_B.setp Error: invalid path: " + path + ".\nUse either an Array, eg ['path1', 'path2']\nor `separator`-ed String, eg 'path1.path2'";
    }
  }
  if (!_.isObject(o)) {
    throw "_B.setp Error: invalid object: " + o;
  }
  for (pi = i = 0, len = path.length; i < len; pi = ++i) {
    p = path[pi];
    if (!_.isObject(o[p])) {
      if (options.create || options.overwrite) {
        newObj = null;
        if (_.isUndefined(o[p])) {
          newObj = {};
        } else {
          if (options.overwrite) {
            newObj = {};
            if (_.isString(options.overwrite)) {
              newObj[options.overwrite] = o[p];
            }
          }
        }
        if (newObj) {
          o[p] = newObj;
        }
      } else {
        if (_.isUndefined(o[p])) {
          return false;
        }
      }
    }
    if (pi < path.length - 1) {
      o = o[p];
    }
  }
  if (_.isObject(o)) {
    o[p] = val;
    return true;
  } else {
    return false;
  }
};
module.exports = setp;

return module.exports;

});
define('Logger',['require', 'exports', 'module', './agreement/inAgreements', './objects/setp', './objects/getp'], function (require, exports, module) {
  

var Logger, getp, inAgreements, setp, slice = [].slice;
inAgreements = require("./agreement/inAgreements");
setp = require("./objects/setp");
getp = require("./objects/getp");
module.exports = Logger = function () {
  var ANSI_BLACK, ANSI_BLACK_BOLD, ANSI_BLUE, ANSI_BLUE_BOLD, ANSI_CYAN, ANSI_CYAN_BOLD, ANSI_GREEN, ANSI_GREEN_BOLD, ANSI_PURPLE, ANSI_PURPLE_BOLD, ANSI_RED, ANSI_RED_BOLD, ANSI_RESET, ANSI_WHITE, ANSI_WHITE_BOLD, ANSI_YELLOW, ANSI_YELLOW_BOLD, arrayizeDebugPath, countNewLines, getALog, key, ref, val;
  function Logger(debugPath, debugLevel1) {
    if (debugPath == null) {
      debugPath = [];
    }
    this.debugLevel = debugLevel1;
    this.setDebugPath(debugPath);
    Logger.loggerCount = (Logger.loggerCount || 0) + 1;
  }
  getALog = function (baseMsg, color, cons) {
    return function () {
      var arg, args, err, error, i, j, len, newLines, retString, title;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (_.isString(args[0])) {
        newLines = countNewLines(args[0]);
        args[0] = args[0].slice(newLines);
      }
      args = function () {
        var j, len, results;
        results = [];
        for (j = 0, len = args.length; j < len; j++) {
          arg = args[j];
          results.push(Logger.prettify(arg));
        }
        return results;
      }();
      title = "" + (_.isEmpty(typeof this !== "undefined" && this !== null ? this.debugPath : void 0) ? "Logger" + Logger.loggerCount + " " : "[" + this.debugPath.join("/") + "] ") + baseMsg;
      if (title) {
        title = title + ":";
      }
      args.unshift(title);
      if (!(typeof __isWeb !== "undefined" && __isWeb !== null && __isWeb)) {
        args.unshift("" + color);
      }
      args.unshift(function () {
        var j, ref, results;
        results = [];
        for (i = j = 1, ref = newLines; j <= ref; i = j += 1) {
          results.push("\n");
        }
        return results;
      }().join(""));
      if (!(typeof __isWeb !== "undefined" && __isWeb !== null && __isWeb)) {
        args.push(ANSI_RESET);
      }
      cons.apply(console, args);
      try {
        return args.join("");
      } catch (error) {
        err = error;
        retString = "";
        for (j = 0, len = args.length; j < len; j++) {
          arg = args[j];
          retString += Object.prototype.toString(arg);
        }
        return retString;
      }
    };
  };
  countNewLines = function (str) {
    var newLines;
    newLines = 0;
    while (str[newLines] === "\n") {
      newLines++;
    }
    return newLines;
  };
  arrayizeDebugPath = function (debugPath) {
    var j, len, path, ref, results;
    if (_.isString(debugPath)) {
      ref = debugPath.split("/");
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        path = ref[j];
        if (path) {
          results.push(path);
        }
      }
      return results;
    } else if (_.isUndefined(debugPath)) {
      return [];
    } else if (_.isArray(debugPath)) {
      return debugPath;
    } else {
      return [debugPath];
    }
  };
  Logger.prototype.setDebugPath = function (debugPath) {
    return this.debugPath = arrayizeDebugPath(debugPath);
  };
  Logger.addDebugPathLevel = function (debugPath, debugLevel) {
    if (!_.isNaN(debugLevel * 1)) {
      debugPath = _.clone(arrayizeDebugPath(debugPath));
      debugPath.unshift("debugPathsLevels");
      debugPath.push("_level");
      return setp(Logger, debugPath, debugLevel * 1, { create: true });
    } else {
      throw new Error("debugLevel '" + debugLevel + "' isNaN (Not a Number or not Number parsable)");
    }
  };
  Logger.prototype.getDebugPathLevel = function (levelPath) {
    var lastPath, levPaths, val;
    if (levelPath == null) {
      levelPath = this.debugPath;
    }
    levPaths = _.clone(levelPath);
    val = getp(Logger.debugPathsLevels, levPaths);
    lastPath = levPaths.pop();
    while (_.isUndefined(val != null ? val._level : void 0) && lastPath) {
      val = getp(Logger.debugPathsLevels, levPaths);
      lastPath = levPaths.pop();
    }
    return val != null ? val._level : void 0;
  };
  Logger.prototype.isDebug = function (level) {
    var pathLevel;
    if (_.isNumber(Logger.maxDebugLevel)) {
      if (level > Logger.maxDebugLevel) {
        return false;
      }
    }
    if (_.isNumber(this.debugLevel)) {
      if (level > this.debugLevel) {
        return false;
      }
    } else {
      if (_.isNumber(pathLevel = this.getDebugPathLevel())) {
        if (level > pathLevel) {
          return false;
        }
      } else {
        if (level > 1) {
          return false;
        }
      }
    }
    return true;
  };
  Logger.prototype.deb = function () {
    var debugLog;
    debugLog = getALog("DEBUG", "[35m", console.log);
    return function () {
      var i, level, msgs, newLines, ref;
      level = arguments[0], msgs = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (_.isEmpty(msgs) && _.isNumber(level)) {
        return this.isDebug(this.lastDebugLevelCheck = level);
      }
      if (!_.isNumber(level)) {
        msgs.unshift(level);
        level = (ref = this.lastDebugLevelCheck) != null ? ref : 1;
        msgs.unshift(this.lastDebugLevelCheck ? "(?" + this.lastDebugLevelCheck + ")" : "(!1)");
      } else {
        msgs.unshift("(" + level + ")");
      }
      if (_.isString(msgs[1])) {
        newLines = countNewLines(msgs[1]);
        msgs[1] = msgs[1].slice(newLines);
        msgs[0] = function () {
          var j, ref1, results;
          results = [];
          for (i = j = 1, ref1 = newLines; j <= ref1; i = j += 1) {
            results.push("\n");
          }
          return results;
        }().join("") + msgs[0];
      }
      delete this.lastDebugLevelCheck;
      if (this.isDebug(level)) {
        return debugLog.apply(this, msgs);
      }
    };
  }();
  Logger.prototype.debug = Logger.prototype.deb;
  Logger.prettify = typeof __isNode !== "undefined" && __isNode !== null && __isNode ? function (inspect) {
    var nodeVerLE_092;
    nodeVerLE_092 = function () {
      var i, j, len, ref, v, x;
      v = [];
      ref = process.version.slice(1).split(".");
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        x = ref[i];
        v[i] = x * 1;
      }
      if (v[0] > 0 || v[1] > 9) {
        return false;
      } else {
        if (v[1] === 9) {
          if (v[2] <= 2) {
            return true;
          } else {
            return false;
          }
        } else {
          return true;
        }
      }
    }();
    return function (o) {
      var pretty;
      pretty = nodeVerLE_092 ? "[0m" + inspect(o, false, null, true) : "[0m" + inspect(o, {
        showHidden: false,
        depth: null,
        colors: true
      });
      if (_.isArray(o)) {
        pretty.replace(/\n/g, "");
      }
      if (inAgreements(o, [
          _.isObject,
          _.isRegExp
        ])) {
        return pretty;
      } else {
        return o;
      }
    };
  }(require("util").inspect) : function (o) {
    return o;
  };
  Logger.prototype.prettify = Logger.prettify;
  Logger.prototype.err = getALog("ERROR", ANSI_RED, console.error);
  Logger.prototype.er = getALog("ERRor", ANSI_RED_BOLD, console.log);
  Logger.prototype.warn = getALog("WARNING", ANSI_YELLOW_BOLD, console.log);
  Logger.prototype.verbose = getALog("", ANSI_CYAN_BOLD, console.log);
  Logger.prototype.ver = Logger.prototype.verbose;
  Logger.prototype.ok = getALog("", ANSI_GREEN_BOLD, console.log);
  Logger.prototype.log = getALog("", ANSI_RESET, console.log);
  ANSI_RESET = "[0m";
  ANSI_BLACK = "[30m";
  ANSI_RED = "[31m";
  ANSI_GREEN = "[32m";
  ANSI_YELLOW = "[33m";
  ANSI_BLUE = "[34m";
  ANSI_PURPLE = "[35m";
  ANSI_CYAN = "[36m";
  ANSI_WHITE = "[37m";
  ANSI_BLACK_BOLD = "[30;1m";
  ANSI_RED_BOLD = "[31;1m";
  ANSI_GREEN_BOLD = "[32;1m";
  ANSI_YELLOW_BOLD = "[33;1m";
  ANSI_BLUE_BOLD = "[34;1m";
  ANSI_PURPLE_BOLD = "[35;1m";
  ANSI_CYAN_BOLD = "[36;1m";
  ANSI_WHITE_BOLD = "[37;1m";
  Logger.logger = new Logger("DefaultLogger");
  ref = Logger.prototype;
  for (key in ref) {
    val = ref[key];
    if (_.isFunction(val)) {
      Logger[key] = _.bind(val, Logger.logger);
    } else {
      Logger[key] = val;
    }
  }
  return Logger;
}();

return module.exports;

});
define('blending/Blender',['require', 'exports', 'module', '../types/type', '../objects/getp', '../types/isHash', '../utils/CoffeeUtils', '../utils/subclass', '../Logger'], function (require, exports, module, type, getp, isHash, CoffeeUtils) {
  

var ActionResult, Blender;
  isHash = require("../types/isHash");
  ActionResult = function () {
    function ActionResult(name) {
      this.name = name;
    }
    return ActionResult;
  }();
  return Blender = function (superClass) {
    extend(Blender, superClass);
    Blender.subclass = require("../utils/subclass");
    Blender.prototype.inherited = false;
    Blender.prototype.copyProto = false;
    Blender.prototype.pathTerminator = "|";
    Blender.prototype.isExactPath = true;
    Blender.prototype.pathSeparator = ":";
    Blender.prototype.debugLevel = 0;
    Blender.prototype.defaultBBOrder = [
      "src",
      "dst"
    ];
    function Blender() {
      var aClass, bb, bbi, blenderBehaviors, dbb, j, k, lastDBB, len, ref, ref1, typeName;
      blenderBehaviors = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      this.blenderBehaviors = blenderBehaviors;
      this.write = bind(this.write, this);
      this._blend = bind(this._blend, this);
      this.blend = bind(this.blend, this);
      this.getNextAction = bind(this.getNextAction, this);
      this.getAction = bind(this.getAction, this);
      if (_.isArray(this.blenderBehaviors[0])) {
        if (isHash(this.blenderBehaviors[1])) {
          _.extend(this, this.blenderBehaviors[1]);
        }
        this.blenderBehaviors = this.blenderBehaviors[0];
      }
      this.l = new (require("../Logger"))("uberscore/Blender", this.debugLevel);
      ref = this.getClasses();
      for (j = ref.length - 1; j >= 0; j += -1) {
        aClass = ref[j];
        if (aClass.behavior) {
          this.blenderBehaviors.push(aClass.behavior);
        }
      }
      lastDBB = _.last(this.blenderBehaviors);
      for (typeName in lastDBB) {
        dbb = lastDBB[typeName];
        if (_.isUndefined(dbb["*"])) {
          dbb["*"] || (dbb["*"] = lastDBB["*"]["*"]);
        }
      }
      ref1 = this.blenderBehaviors;
      for (bbi = k = 0, len = ref1.length; k < len; bbi = ++k) {
        bb = ref1[bbi];
        this.blenderBehaviors[bbi] = this.adjustBlenderBehavior(bb);
      }
      this.path = [];
    }
    Blender.prototype.adjustBlenderBehavior = function (blenderBehavior) {
      blenderBehavior.order || (blenderBehavior.order = this.defaultBBOrder);
      return this._adjustBbSrcDstPathSpec(blenderBehavior, blenderBehavior.order);
    };
    Blender.prototype._adjustBbSrcDstPathSpec = function (bbSrcDstPathSpec, orderRemaining) {
      var bbOrder, i, j, key, len, newV, p, path, pathItems, short, val;
      if (orderRemaining.length > 0) {
        bbOrder = orderRemaining[0];
        if (bbOrder === "path") {
          for (key in bbSrcDstPathSpec) {
            val = bbSrcDstPathSpec[key];
            if (key === this.pathTerminator) {
              if (isHash(val)) {
                this._adjustBbSrcDstPathSpec(val, orderRemaining.slice(1));
              }
            } else {
              pathItems = this.pathSeparator ? function () {
                var j, len, ref, results;
                ref = key.split(this.pathSeparator);
                results = [];
                for (j = 0, len = ref.length; j < len; j++) {
                  path = ref[j];
                  if (path) {
                    results.push(path.trim());
                  }
                }
                return results;
              }.call(this) : [];
              if (pathItems.length > 1) {
                newV = bbSrcDstPathSpec;
                for (i = j = 0, len = pathItems.length; j < len; i = ++j) {
                  p = pathItems[i];
                  newV[p] || (newV[p] = {});
                  if (i < pathItems.length - 1) {
                    newV = newV[p];
                  } else {
                    newV[p] = val;
                  }
                }
                delete bbSrcDstPathSpec[key];
              } else {
                if (pathItems[0] && key !== pathItems[0]) {
                  bbSrcDstPathSpec[pathItems[0]] = val;
                  delete bbSrcDstPathSpec[key];
                }
              }
              if (isHash(val)) {
                this._adjustBbSrcDstPathSpec(val, orderRemaining);
              }
            }
          }
        } else {
          for (key in bbSrcDstPathSpec) {
            val = bbSrcDstPathSpec[key];
            if (type.isType(key)) {
              short = type.toShort(key);
              if (short && key !== short) {
                bbSrcDstPathSpec[short] = bbSrcDstPathSpec[key];
                delete bbSrcDstPathSpec[key];
              }
            }
            if (isHash(val)) {
              this._adjustBbSrcDstPathSpec(val, orderRemaining.slice(1));
            }
          }
        }
      }
      return bbSrcDstPathSpec;
    };
    Blender.prototype.getAction = function (actionName, belowBlenderBehaviorIndex) {
      var bb, bbi, j, len, ref;
      if (belowBlenderBehaviorIndex == null) {
        belowBlenderBehaviorIndex = this.currentBlenderBehaviorIndex;
      }
      ref = this.blenderBehaviors;
      for (bbi = j = 0, len = ref.length; j < len; bbi = ++j) {
        bb = ref[bbi];
        if (bbi >= belowBlenderBehaviorIndex) {
          if (_.isFunction(bb[actionName])) {
            return _.bind(bb[actionName], this);
          }
        }
      }
      if (_.isFunction(this[actionName])) {
        return _.bind(this[actionName], this);
      } else {
        throw this.l.err("_B.Blender.blend: Error: Invalid BlenderBehavior `actionName` = ", actionName, " - no Function by that name is found in a preceding BlenderBehavior or Blender it self.", " belowBlenderBehaviorIndex=" + belowBlenderBehaviorIndex, " @currentBlenderBehaviorIndex=" + this.currentBlenderBehaviorIndex, " @blenderBehaviors=", this.blenderBehaviors);
      }
    };
    Blender.prototype.getNextAction = function (blenderBehavior, bbi, bbOrderValues) {
      var bbOrder, currentBBSrcDstSpec, j, len, nextBBSrcDstSpec, ref;
      currentBBSrcDstSpec = blenderBehavior;
      ref = blenderBehavior.order;
      for (j = 0, len = ref.length; j < len; j++) {
        bbOrder = ref[j];
        if (currentBBSrcDstSpec === void 0 || _.isString(currentBBSrcDstSpec) || _.isFunction(currentBBSrcDstSpec) || currentBBSrcDstSpec instanceof ActionResult) {
          break;
        }
        if (this.l.deb(80)) {
          this.l.deb("At bbOrder='" + bbOrder + "'", bbOrder === "path" ? " @path=" + this.l.prettify(this.path) : " bbOrderValues[bbOrder]='" + bbOrderValues[bbOrder] + "'", " currentBBSrcDstSpec =\n", currentBBSrcDstSpec);
        }
        if (_.isUndefined(bbOrderValues[bbOrder])) {
          throw this.l.err("_.Blender.blend: Error: Invalid BlenderBehavior `order` '" + bbOrder + "',\nwhile reading BlenderBehavior #" + bbi + " :\n", this.blenderBehaviors[bbi], "\n\nDefault BlenderBehavior order is ", this.defaultBBOrder);
        } else {
          if (bbOrder === "path") {
            this.l.deb("@isExactPath", this.isExactPath, "path=", this.path, "@path[1..]=", this.path.slice(1));
            nextBBSrcDstSpec = getp(currentBBSrcDstSpec, this.path.slice(1), { terminateKey: this.isExactPath ? void 0 : this.pathTerminator });
            this.l.deb(80, "bbOrder is 'path', nextBBSrcDstSpec=\n", nextBBSrcDstSpec);
            if (isHash(nextBBSrcDstSpec)) {
              nextBBSrcDstSpec = nextBBSrcDstSpec[this.pathTerminator];
              this.l.deb(80, "found an {} as nextBBSrcDstSpec, reading pathTerminator `" + this.pathTerminator + "`, nextBBSrcDstSpec=\n", nextBBSrcDstSpec);
            }
          } else {
            nextBBSrcDstSpec = currentBBSrcDstSpec[bbOrderValues[bbOrder]] || currentBBSrcDstSpec["*"];
          }
          if (this.l.deb(70)) {
            this.l.deb(function () {
              if (nextBBSrcDstSpec === void 0) {
                return "Found NO nextBBSrcDstSpec - NEXT BlenderBehavior";
              } else {
                if (bbOrder === "path") {
                  return "Got out of the path, having something!";
                } else if (nextBBSrcDstSpec === currentBBSrcDstSpec[bbOrderValues[bbOrder]]) {
                  return "Found ";
                } else if (nextBBSrcDstSpec === currentBBSrcDstSpec["*"]) {
                  return "Found NOT exact nextBBSrcDstSpec, but a '*'";
                } else if (_.isString(nextBBSrcDstSpec)) {
                  return "Found a String ";
                } else if (_.isFunction(nextBBSrcDstSpec)) {
                  return "Found a Function ";
                } else if (nextBBSrcDstSpec instanceof ActionResult) {
                  return "Found an ActionResult";
                } else {
                  throw "Unknown nextBBSrcDstSpec = " + this.l.prettify(nextBBSrcDstSpec);
                }
              }
            }.call(this), " \nbbOrder='" + bbOrder + "'", " \nbbOrderValues[bbOrder]='" + bbOrderValues[bbOrder] + "'", " \nnextBBSrcDstSpec=\n", nextBBSrcDstSpec);
          }
          currentBBSrcDstSpec = nextBBSrcDstSpec;
        }
      }
      return currentBBSrcDstSpec;
    };
    Blender.prototype.blend = function () {
      var dst, dstObject, j, len, sources, src;
      dst = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (_.isEmpty(this.path)) {
        if (_.isUndefined(sources) || _.isEmpty(sources)) {
          sources = [dst];
          dst = this.createAs(dst);
        }
        dstObject = { "$": dst };
        this.dstRoot = dst;
        for (j = 0, len = sources.length; j < len; j++) {
          src = sources[j];
          this.srcRoot = src;
          this._blend(dstObject, { "$": src });
        }
        return dstObject.$;
      } else {
        return this._blend.apply(this, arguments);
      }
    };
    Blender.prototype._blend = function () {
      var action, bb, bbi, dst, j, k, l, len, len1, len2, nextBBSrcDstSpec, prop, props, ref, result, sources, src, visitNextBB;
      dst = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      for (j = 0, len = sources.length; j < len; j++) {
        src = sources[j];
        props = this.properties(src);
        for (k = 0, len1 = props.length; k < len1; k++) {
          prop = props[k];
          this.path.push(prop);
          if (this.l.deb(50)) {
            this.l.deb("@path = /" + this.path.join("/") + "\n'" + type(this.read(dst, prop)) + "'    <--  '" + type(this.read(src, prop)) + "'\n", this.read(dst, prop), "    <--  ", this.read(src, prop));
          }
          visitNextBB = true;
          ref = this.blenderBehaviors;
          for (bbi = l = 0, len2 = ref.length; l < len2; bbi = ++l) {
            bb = ref[bbi];
            if (!visitNextBB) {
              continue;
            }
            if (this.l.deb(60)) {
              this.l.deb("Currently at @blenderBehaviors[" + bbi + "] =\n", bb);
            }
            this.currentBlenderBehaviorIndex = bbi;
            this.currentBlenderBehavior = this.blenderBehaviors[bbi];
            nextBBSrcDstSpec = this.getNextAction(bb, bbi, {
              dst: type(this.read(dst, prop), true),
              src: type(this.read(src, prop), true),
              path: this.path
            });
            if (nextBBSrcDstSpec === void 0) {
              continue;
            } else {
              action = nextBBSrcDstSpec;
              if (!_.isFunction(action)) {
                if (_.isString(action)) {
                  action = this.getAction(action, bbi);
                } else {
                  if (action instanceof ActionResult) {
                    result = action;
                  } else {
                    throw this.l.err("_B.Blender.blend: Invalid `action` (neither 'Function' nor 'String'): ", action);
                  }
                }
              }
            }
            if (!(action instanceof ActionResult)) {
              result = action.call(this, prop, src, dst, this);
            }
            visitNextBB = false;
            if (!(result instanceof ActionResult)) {
              if (_.isArray(result) && result[0] === this.NEXT) {
                result = result[1];
                visitNextBB = true;
              }
              if (this.l.deb(20)) {
                this.l.deb("Result handling: @path =", this.path.join("/"), "\n value =", this.l.prettify(result));
              }
              this.resultHandler(dst, prop, result);
            } else {
              if (this.l.deb(30)) {
                this.l.deb("ActionResult = ", result);
              }
              if (result === this.DELETE || result === this.DELETE_NEXT) {
                this["delete"](dst, prop);
              }
              if (result === this.NEXT || result === this.DELETE_NEXT) {
                visitNextBB = true;
              }
            }
          }
          this.path.pop();
        }
      }
      return dst;
    };
    Blender.prototype.createAs = function (obj) {
      if (_.isArray(obj)) {
        return [];
      } else {
        if (this.copyProto) {
          return Object.create(Object.getPrototypeOf(obj));
        } else {
          return {};
        }
      }
    };
    Blender.prototype.read = function (obj, prop) {
      if (_.isUndefined(prop)) {
        throw "Read without a prop";
      }
      return obj[prop];
    };
    Blender.prototype.write = function (obj, prop, val) {
      if (_.isUndefined(prop)) {
        throw "Write without a prop";
      }
      obj[prop] = val;
      return val;
    };
    Blender.prototype["delete"] = function (obj, prop) {
      if (_.isUndefined(prop)) {
        throw "Delete without a prop";
      }
      return delete obj[prop];
    };
    Blender.prototype.properties = function (obj) {
      var j, len, p, results, results1, results2, v;
      if (_.isArray(obj)) {
        results = [];
        for (p = j = 0, len = obj.length; j < len; p = ++j) {
          v = obj[p];
          results.push(p);
        }
        return results;
      } else {
        if (this.inherited) {
          results1 = [];
          for (p in obj) {
            results1.push(p);
          }
          return results1;
        } else {
          results2 = [];
          for (p in obj) {
            if (!hasProp.call(obj, p))
              continue;
            results2.push(p);
          }
          return results2;
        }
      }
    };
    Blender.prototype.copy = function (dst, src) {
      var j, len, prop, ref;
      ref = this.properties(src);
      for (j = 0, len = ref.length; j < len; j++) {
        prop = ref[j];
        this.write(dst, prop, this.read(src, prop));
      }
      return dst;
    };
    Blender.prototype.resultHandler = Blender.prototype.write;
    Blender.prototype.overwrite = function (prop, src) {
      return this.read(src, prop);
    };
    Blender.prototype.deepOverwrite = function (prop, src, dst) {
      var copiedObjWithProto;
      if (this.copyProto) {
        if ({}.__proto__ === Object.prototype) {
          this.read(dst, prop).__proto__ = this.read(src, prop).__proto__;
        } else {
          copiedObjWithProto = Object.create(Object.getPrototypeOf(this.read(src, prop)));
          this.copy(copiedObjWithProto, this.read(dst, prop));
          this.write(dst, prop, copiedObjWithProto);
        }
      }
      return this.blend(this.read(dst, prop), this.read(src, prop));
    };
    Blender.prototype.arrayAppend = function (prop, src, dst) {
      var dstArr, j, len, ref, s, srcArr;
      ref = [
        this.read(src, prop),
        this.read(dst, prop)
      ], srcArr = ref[0], dstArr = ref[1];
      for (j = 0, len = srcArr.length; j < len; j++) {
        s = srcArr[j];
        dstArr.push(s);
      }
      return dstArr;
    };
    Blender.behavior = {
      order: [
        "dst",
        "src"
      ],
      "*": { "*": "overwrite" },
      "[]": {
        "[]": "deepOverwrite",
        "{}": "deepOverwrite",
        "->": "deepOverwrite"
      },
      "{}": {
        "{}": "deepOverwrite",
        "[]": "deepOverwrite",
        "->": "deepOverwrite"
      },
      "->": {
        "{}": "deepOverwrite",
        "[]": "deepOverwrite",
        "->": "deepOverwrite"
      }
    };
    Blender.SKIP = new ActionResult("SKIP");
    Blender.prototype.SKIP = Blender.SKIP;
    Blender.NEXT = new ActionResult("NEXT");
    Blender.prototype.NEXT = Blender.NEXT;
    Blender.DELETE = new ActionResult("DELETE");
    Blender.prototype.DELETE = Blender.DELETE;
    Blender.DELETE_NEXT = new ActionResult("DELETE_NEXT");
    Blender.prototype.DELETE_NEXT = Blender.DELETE_NEXT;
    return Blender;
  }(CoffeeUtils);


});
define('blending/blenders/DeepCloneBlender',['require', 'exports', 'module', '../../types/type', '../Blender'], function (require, exports, module, type) {
  

var DeepCloneBlender;
  return DeepCloneBlender = require("../Blender").subclass({}, {
    behavior: {
      order: [
        "dst",
        "src"
      ],
      "*": {
        "[]": "deepCloneOverwrite",
        "{}": "deepCloneOverwrite",
        "->": function (prop, src) {
          return this.read(src, prop);
        },
        "Undefined": function () {
          return this.SKIP;
        }
      },
      deepCloneOverwrite: function (prop, src, dst) {
        var dstType, similarTypes, srcType;
        srcType = type(this.read(src, prop));
        dstType = type(this.read(dst, prop));
        if (dstType !== srcType) {
          similarTypes = [
            "Function",
            "Object"
          ];
          if (!(indexOf.call(similarTypes, dstType) >= 0 && indexOf.call(similarTypes, srcType) >= 0)) {
            this.write(dst, prop, srcType === "Array" ? [] : {});
          }
        }
        return this.deepOverwrite(prop, src, dst);
      }
    }
  });


});
define('blending/blenders/DeepExtendBlender',['require', 'exports', 'module', '../Blender', '../../Logger'], function (require, exports, module, Blender) {
  

var DeepExtendBlender, l;
  l = new (require("../../Logger"))("uberscore/DeepExtendBlender");
  return DeepExtendBlender = function (superClass) {
    extend(DeepExtendBlender, superClass);
    function DeepExtendBlender() {
      return DeepExtendBlender.__super__.constructor.apply(this, arguments);
    }
    DeepExtendBlender.behavior = {
      order: [
        "src",
        "dst"
      ],
      String: { "*": "overwriteOrReplace" },
      "[]": {
        "[]": function (prop, src, dst) {
          return _.reject(this.deepOverwrite(prop, src, dst), function (v) {
            return v === null || v === void 0;
          });
        },
        "*": function (prop, src, dst) {
          throw "deepExtend: Error: Trying to combine an array with a non-array.\n\nProperty: " + prop + "\ndestination[prop]: " + l.prettify(dst[prop]) + "\nsource[prop]: " + l.prettify(src[prop]);
        }
      },
      "{}": {
        "{}": function (prop, src, dst) {
          var deepBlended, key, ref, val;
          ref = deepBlended = this.getAction("deepOverwrite")(prop, src, dst);
          for (key in ref) {
            val = ref[key];
            if (val === null || val === void 0) {
              delete deepBlended[key];
            }
          }
          return deepBlended;
        },
        "*": function (prop, src, dst) {
          throw "deepExtend: Error trying to combine a PlainObject with a non-PlainObject.\n\nProperty: " + prop + "\ndestination[prop]: " + l.prettify(dst[prop]) + "\nsource[prop]: " + l.prettify(src[prop]);
        }
      },
      overwriteOrReplace: function (prop, src, dst) {
        var replaceRE;
        replaceRE = /\${\s*?_\s*?}/;
        if (_.isString(src[prop]) && replaceRE.test(src[prop])) {
          if (_.isString(dst[prop])) {
            return src[prop].replace(replaceRE, dst[prop]);
          } else {
            return dst[prop];
          }
        } else {
          return src[prop];
        }
      }
    };
    return DeepExtendBlender;
  }(Blender);


});
define('blending/blenders/DeepDefaultsBlender',['require', 'exports', 'module', '../../types/type', './DeepCloneBlender'], function (require, exports, module, type, DeepCloneBlender) {
  

var DeepDefaultsBlender;
  return DeepDefaultsBlender = DeepCloneBlender.subclass({}, {
    behavior: {
      order: [
        "dst",
        "src"
      ],
      "Undefined": function () {
        return this.NEXT;
      },
      "Null": function () {
        return this.NEXT;
      },
      "{}": {
        "{}": function () {
          return this.NEXT;
        },
        "->": function () {
          return this.NEXT;
        },
        "*": function () {
          return this.SKIP;
        }
      },
      "->": {
        "{}": function () {
          return this.NEXT;
        },
        "->": function () {
          return this.NEXT;
        },
        "*": function () {
          return this.SKIP;
        }
      },
      "[]": {
        "[]": function () {
          return this.NEXT;
        },
        "*": function () {
          return this.SKIP;
        }
      },
      "*": function () {
        return this.SKIP;
      }
    }
  });


});
define('blending/blenders/ArrayizeBlender',['require', 'exports', 'module', '../../collections/array/arrayize', './DeepCloneBlender'], function (require, exports, module, arrayize) {
  

var ArrayizeBlender;
  return ArrayizeBlender = function (superClass) {
    extend(ArrayizeBlender, superClass);
    function ArrayizeBlender() {
      return ArrayizeBlender.__super__.constructor.apply(this, arguments);
    }
    ArrayizeBlender.prototype.addMethod = "push";
    ArrayizeBlender.prototype.unique = false;
    ArrayizeBlender.prototype.reverse = false;
    ArrayizeBlender.behavior = {
      order: ["src"],
      "*": "addToArray",
      addToArray: function (prop, src, dst) {
        var dstArray, i, itemsToAdd, len, srcArray, v;
        dstArray = this.write(dst, prop, arrayize(this.read(dst, prop)));
        srcArray = arrayize(this.read(src, prop));
        if (_.isEqual(srcArray[0], [null])) {
          dstArray = this.write(dst, prop, []);
          srcArray = srcArray.slice(1);
        }
        itemsToAdd = this.unique ? function () {
          var i, len, results;
          results = [];
          for (i = 0, len = srcArray.length; i < len; i++) {
            v = srcArray[i];
            if (indexOf.call(dstArray, v) < 0) {
              results.push(v);
            }
          }
          return results;
        }() : _.clone(srcArray);
        if (this.reverse) {
          itemsToAdd.reverse();
        }
        for (i = 0, len = itemsToAdd.length; i < len; i++) {
          v = itemsToAdd[i];
          dstArray[this.addMethod](v);
        }
        return dstArray;
      }
    };
    return ArrayizeBlender;
  }(require("./DeepCloneBlender"));


});
define('blending/blenders/index',['require', 'exports', 'module', './DeepCloneBlender', './DeepExtendBlender', './DeepDefaultsBlender', './ArrayizeBlender'], function (require, exports, module) {
  

module.exports = {
  DeepCloneBlender: require("./DeepCloneBlender"),
  DeepExtendBlender: require("./DeepExtendBlender"),
  DeepDefaultsBlender: require("./DeepDefaultsBlender"),
  ArrayizeBlender: require("./ArrayizeBlender")
};

return module.exports;

});
define('blending/traverse',['require', 'exports', 'module', './Blender'], function (require, exports, module) {
  

var Blender, traverse;
Blender = require("./Blender");
traverse = function (data, callback) {
  var dummy, recurse, traverseBlender;
  dummy = {};
  recurse = true;
  traverseBlender = new Blender([{
      order: ["src"],
      "[]": "traverse",
      "{}": "traverse",
      "->": "traverse",
      "*": Blender.SKIP,
      traverse: function (prop, src, dst, blender) {
        if (this.read(src, prop) !== data) {
          recurse = callback.call(this, prop, src, blender);
        }
        if (recurse !== false) {
          this.blend(dummy, this.read(src, prop));
        }
        return this.SKIP;
      }
    }], { debugLevel: 0 });
  return traverseBlender.blend(dummy, data);
};
module.exports = traverse;

return module.exports;

});
define('blending/clone',['require', 'exports', 'module', './blenders/DeepCloneBlender'], function (require, exports, module) {
  

var DeepCloneBlender, clone;
DeepCloneBlender = require("./blenders/DeepCloneBlender");
clone = function (obj, options) {
  if (!options) {
    return _.clone(obj, options);
  } else {
    if (!(options === true || options.deep)) {
      return new DeepCloneBlender([{ "*": { "*": "overwrite" } }], options).blend(obj);
    } else {
      return new DeepCloneBlender([], options).blend(obj);
    }
  }
};
module.exports = clone;

return module.exports;

});
define('objects/okv',['require', 'exports', 'module'], function (require, exports, module) {
  

var okv, slice = [].slice;
okv = function () {
  var i, idx, keyName, keyValPairs, len, obj;
  obj = arguments[0], keyValPairs = 2 <= arguments.length ? slice.call(arguments, 1) : [];
  if (_.isString(obj)) {
    keyValPairs.unshift(obj);
    obj = {};
  }
  if (_.isObject(obj)) {
    for (idx = i = 0, len = keyValPairs.length; i < len; idx = i += 2) {
      keyName = keyValPairs[idx];
      if (idx + 1 < keyValPairs.length) {
        obj[keyName + ""] = keyValPairs[idx + 1];
      }
    }
    return obj;
  } else {
    return null;
  }
};
module.exports = okv;

return module.exports;

});
define('objects/mutate',['require', 'exports', 'module', '../agreement/isAgree'], function (require, exports, module) {
  

var isAgree = require("../agreement/isAgree");
var mutate = function (oa, mutator, fltr) {
  if (_.isFunction(mutator)) {
    _.each(oa, function (val, key) {
      if (isAgree(val, fltr)) {
        return oa[key] = mutator(val, key);
      }
    });
  }
  return oa;
};
module.exports = mutate;

return module.exports;

});
define('objects/isDisjoint',['require', 'exports', 'module'], function (require, exports, module) {
  

var isDisjoint;
isDisjoint = function (oa1, oa2, equality) {
  var found;
  if (equality == null) {
    equality = function (v1, v2) {
      return v1 === v2;
    };
  }
  found = false;
  _.each(oa1, function (v1) {
    if (_.some(oa2, function (v2) {
        return equality(v1, v2);
      })) {
      found = true;
      return false;
    }
  });
  return !found;
};
module.exports = isDisjoint;

return module.exports;

});
define('objects/getRefs',['require', 'exports', 'module'], function (require, exports, module) {
  

var getRefs, getRefsDefaults, hasProp = {}.hasOwnProperty;
getRefsDefaults = {
  deep: false,
  inherited: false
};
getRefs = function (oa, options, refsArray) {
  var i, key, keys, len, v;
  if (options == null) {
    options = getRefsDefaults;
  }
  if (refsArray == null) {
    refsArray = [];
  }
  if (options !== getRefsDefaults) {
    _.defaults(options, getRefsDefaults);
  }
  keys = options.inherited ? function () {
    var results;
    results = [];
    for (key in oa) {
      results.push(key);
    }
    return results;
  }() : function () {
    var results;
    results = [];
    for (key in oa) {
      if (!hasProp.call(oa, key))
        continue;
      results.push(key);
    }
    return results;
  }();
  for (i = 0, len = keys.length; i < len; i++) {
    key = keys[i];
    v = oa[key];
    if (_.isObject(v)) {
      refsArray.push(v);
      if (options.deep) {
        getRefs(v, options, refsArray);
      }
    }
  }
  return refsArray;
};
module.exports = getRefs;

return module.exports;

});
define('objects/isRefDisjoint',['require', 'exports', 'module', './getRefs', './isDisjoint'], function (require, exports, module) {
  

var getRefs, isDisjoint, isRefDisjoint, isRefDisjointDefaults;
getRefs = require("./getRefs");
isDisjoint = require("./isDisjoint");
isRefDisjointDefaults = {
  deep: false,
  inherited: false
};
isRefDisjoint = function (oa1, oa2, options) {
  var refs1, refs2;
  if (options == null) {
    options = isRefDisjointDefaults;
  }
  if (options !== isRefDisjointDefaults) {
    _.defaults(options, isRefDisjointDefaults);
  }
  if (oa1 === oa2) {
    return false;
  } else {
    refs1 = getRefs(oa1, options);
    refs1.unshift(oa1);
    refs2 = getRefs(oa2, options);
    refs2.unshift(oa2);
    return isDisjoint(refs1, refs2);
  }
};
module.exports = isRefDisjoint;

return module.exports;

});
define('objects/getInheritedPropertyNames',['require', 'exports', 'module'], function (require, exports, module) {
  

var _getInheritedPropertyNames, getInheritedPropertyNames;
getInheritedPropertyNames = function (obj) {
  return _getInheritedPropertyNames(Object.getPrototypeOf(obj));
};
_getInheritedPropertyNames = function (obj) {
  var props;
  props = [];
  while (true) {
    if (!obj || obj === void 0 || _.isEmpty(obj) && !Object.getPrototypeOf(obj)) {
      break;
    }
    Object.getOwnPropertyNames(obj).forEach(function (prop) {
      if (props.indexOf(prop) === -1 && prop !== "constructor") {
        return props.push(prop);
      }
    });
    obj = Object.getPrototypeOf(obj);
  }
  return props;
};
module.exports = getInheritedPropertyNames;

return module.exports;

});
define('types/isPlain',['require', 'exports', 'module', './type'], function (require, exports, module) {
  

var type, isPlain;
type = require("./type");
isPlain = function (o) {
  return in$(type(o), isPlain.PLAIN_TYPES);
};
isPlain.PLAIN_TYPES = [
  "String",
  "Date",
  "RegExp",
  "Number",
  "Boolean",
  "Null",
  "Undefined"
];
module.exports = isPlain;
function in$(x, xs) {
  var i = -1, l = xs.length >>> 0;
  while (++i < l)
    if (x === xs[i])
      return true;
  return false;
}

return module.exports;

});
define('collections/array/isEqualArraySet',['require', 'exports', 'module'], function (require, exports, module) {
  

var isEqualArraySet;
isEqualArraySet = function (a1, a2, equalsFn) {
  if (_.difference(a1, a2).length === 0) {
    return _.difference(a2, a1).length === 0;
  } else {
    return false;
  }
};
module.exports = isEqualArraySet;

return module.exports;

});
define('objects/isEqual',['require', 'exports', 'module', '../types/type', '../types/isPlain', '../types/isHash', '../collections/array/isEqualArraySet', '../Logger'], function (require, exports, module) {
  

var getProps, isEqual, isEqualArraySet, isHash, isPlain, l, type;
type = require("../types/type");
isPlain = require("../types/isPlain");
isHash = require("../types/isHash");
isEqualArraySet = require("../collections/array/isEqualArraySet");
l = new (require("../Logger"))("uberscore/isEqual");
isEqual = function (a, b, callback, ctx, options) {
  var aKeys, bKeys, cb, cbResult, isValueType, j, key, len, prop;
  if (options == null) {
    options = isEqual.defaults;
  }
  if (isHash(callback)) {
    options = _.defaults(callback, options);
  }
  if (options !== isEqual.defaults) {
    _.defaults(options || (options = {}), isEqual.defaults);
  }
  if (options.callback) {
    callback = options.callback;
  }
  if (options.ctx) {
    ctx = options.ctx;
  }
  if (_.isFunction(callback)) {
    if (!callback.optioned) {
      cb = callback;
      callback = function (a, b) {
        return cb.call(this, a, b, options);
      };
      callback.optioned = true;
      if (options.callback) {
        options.callback = callback;
      }
    }
    cbResult = callback.call(ctx, a, b);
    if (cbResult !== void 0) {
      return cbResult ? true : false;
    }
  } else {
    callback = void 0;
    options.callback = void 0;
  }
  if (l.deb(20)) {
    l.deb("options = ", options);
  }
  if (a === b) {
    if (l.deb(40)) {
      l.deb("return true - a is b");
    }
    return true;
  }
  if (_.isFunction(a != null ? a.isEqual : void 0)) {
    return a.isEqual(b);
  }
  if (_.isFunction(b != null ? b.isEqual : void 0)) {
    return b.isEqual(a);
  }
  if (_.isEqual(isEqual.defaults, _.pick(options, _.keys(isEqual.defaults)))) {
    if (l.deb(40)) {
      l.deb("return _.isEqual a, b - no _B.isEqual options");
    }
    return _.isEqual(a, b, callback, ctx);
  }
  if (!(options.onlyProps && _.isObject(b) && (_.isObject(a) || options.like))) {
    if (type(a) !== type(b)) {
      if (l.deb(40)) {
        l.deb("return false - type(a) isnt type(b) and not options.onlyProps");
      }
      return false;
    }
    isValueType = function (x) {
      return isPlain(x) || _.isFunction(x);
    };
    if (isValueType(a) || isValueType(b)) {
      if (!_.isEqual(a, b, callback, ctx)) {
        return false;
      } else {
        if (!options.allProps) {
          return true;
        }
      }
    }
  }
  aKeys = getProps(a, options);
  bKeys = getProps(b, options);
  if (!options.like) {
    if (aKeys.length !== bKeys.length || !isEqualArraySet(aKeys, bKeys)) {
      if (_.isArray(options.path)) {
        if (!(key = _.difference(aKeys, bKeys)[0])) {
          key = _.difference(bKeys, aKeys)[0];
        }
        options.path.push(key);
      }
      return false;
    }
  }
  for (j = 0, len = aKeys.length; j < len; j++) {
    prop = aKeys[j];
    if (_.isArray(options.path)) {
      options.path.push(prop);
    }
    if (options.exact) {
      if (a[prop] !== b[prop]) {
        if (l.deb(40)) {
          l.deb("return false - exact ref not same");
        }
        return false;
      }
    }
    if (!isEqual(a[prop], b[prop], callback, ctx, options)) {
      if (l.deb(40)) {
        l.deb("return false - not isEqual nested for prop =", prop, "values = ", a[prop], b[prop]);
      }
      return false;
    }
    if (_.isArray(options.path)) {
      options.path.pop();
    }
  }
  if (l.deb(40)) {
    l.deb("return true - all properties considered true");
  }
  return true;
};
isEqual.defaults = {
  inherited: false,
  exact: false,
  like: false,
  path: void 0,
  exclude: [],
  allProps: false,
  onlyProps: false
};
getProps = function (oa, options) {
  var i, isExcluded, j, pi, ref, results, results1;
  if (options == null) {
    options = {};
  }
  isExcluded = function (prop) {
    return _.some(options.exclude, function (p) {
      return p + "" === prop + "";
    });
  };
  if (_.isArray(oa) && !(options.allProps || options.onlyProps)) {
    results = [];
    for (i = j = 0, ref = oa.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (!isExcluded(i)) {
        results.push(i);
      }
    }
    return results;
  } else {
    results1 = [];
    for (pi in oa) {
      if (!isExcluded(pi) && (options.inherited || {}.hasOwnProperty.call(oa, pi))) {
        results1.push(pi);
      }
    }
    return results1;
  }
};
module.exports = isEqual;

return module.exports;

});
define('objects/isIqual',['require', 'exports', 'module', './isEqual'], function (require, exports, module) {
  

var isEqual, isIqual;
isEqual = require("./isEqual");
isIqual = function (a, b, callback, ctx, options) {
  if (options == null) {
    options = {};
  }
  options.inherited = true;
  (options.exclude || (options.exclude = [])).push("constructor");
  return isEqual(a, b, callback, ctx, options);
};
module.exports = isIqual;

return module.exports;

});
define('objects/isExact',['require', 'exports', 'module', './isEqual'], function (require, exports, module) {
  

var isEqual, isExact;
isEqual = require("./isEqual");
isExact = function (a, b, callback, ctx, options) {
  if (options == null) {
    options = {};
  }
  options.exact = true;
  return isEqual(a, b, callback, ctx, options);
};
module.exports = isExact;

return module.exports;

});
define('objects/isIxact',['require', 'exports', 'module', './isIqual'], function (require, exports, module) {
  

var isIqual, isIxact;
isIqual = require("./isIqual");
isIxact = function (a, b, callback, ctx, options) {
  if (options == null) {
    options = {};
  }
  options.exact = true;
  return isIqual(a, b, callback, ctx, options);
};
module.exports = isIxact;

return module.exports;

});
define('objects/isLike',['require', 'exports', 'module', './isEqual'], function (require, exports, module) {
  

var isEqual, isLike;
isEqual = require("./isEqual");
isLike = function (a, b, callback, ctx, options) {
  if (options == null) {
    options = {};
  }
  options.like = true;
  return isEqual(a, b, callback, ctx, options);
};
module.exports = isLike;

return module.exports;

});
define('types/isTrue',['require', 'exports', 'module'], function (require, exports, module) {
  

return function (val) {
    return _.isEqual(val, true);
  };


});
define('types/isFalse',['require', 'exports', 'module'], function (require, exports, module) {
  

return function (val) {
    return _.isEqual(val, false);
  };


});
define('certain',['require', 'exports', 'module', './types/isHash'], function (require, exports, module) {
  

var certain, isHash;
isHash = require("./types/isHash");
certain = function (o, defaultKey, defaultVal, isStrict) {
  if (isStrict == null) {
    isStrict = false;
  }
  if (!(isHash(o) || _.isFunction(o))) {
    throw "Error: _B.certain: o is neither an Object or Function.\no=" + JSON.stringify(o, null, "");
  }
  if (_.isUndefined(defaultKey)) {
    defaultKey = "*";
  }
  return function (key) {
    var ref, ref1, val;
    val = (ref = (ref1 = o[key]) != null ? ref1 : o[defaultKey]) != null ? ref : defaultVal;
    if (isStrict && _.isUndefined(val)) {
      throw new Error("_B.certain: defaultKey is undefined.\n  defaultVal is also undefined.\n  key='" + key + "' (o[" + key + "] is obviously undefined too)\n  defaultKey='" + defaultKey + "'\n  o=" + JSON.stringify(o, null, ""));
    }
    return val;
  };
};
module.exports = certain;

return module.exports;

});
define('utils/CalcCachedProperties',['require', 'exports', 'module', './CoffeeUtils', '../Logger'], function (require, exports, module, CoffeeUtils) {
  

var CalcCachedProperties, l;
  l = new (require("../Logger"))("uberscore/utils/CalcCachedProperties");
  return CalcCachedProperties = function (superClass) {
    var cUndefined, cacheKey, prefix;
    extend(CalcCachedProperties, superClass);
    prefix = function (prop) {
      return "__$$" + prop + "__$$";
    };
    cacheKey = prefix("cache");
    cUndefined = { "cUndefined": true };
    CalcCachedProperties.prototype.getAllCalcProperties = function (instOrClass) {
      var aClass, cFunct, cProp, calcProps, i, len, ref, ref1;
      if (instOrClass == null) {
        instOrClass = this;
      }
      calcProps = {};
      ref = this.getClasses(instOrClass);
      for (i = 0, len = ref.length; i < len; i++) {
        aClass = ref[i];
        ref1 = aClass.calcProperties;
        for (cProp in ref1) {
          cFunct = ref1[cProp];
          calcProps[cProp] = cFunct;
        }
      }
      return calcProps;
    };
    CalcCachedProperties.getAllCalcProperties = CalcCachedProperties.prototype.getAllCalcProperties;
    Object.defineProperties(CalcCachedProperties.prototype, {
      allCalcProperties: {
        get: function () {
          if (!this.constructor.prototype.hasOwnProperty("_allCalcProperties")) {
            Object.defineProperty(this.constructor.prototype, "_allCalcProperties", {
              value: this.getAllCalcProperties(),
              enumerable: false
            });
          }
          return this.constructor.prototype._allCalcProperties;
        }
      },
      classes: {
        get: function () {
          if (!this.constructor.prototype.hasOwnProperty("_classes")) {
            Object.defineProperty(this.constructor.prototype, "_classes", {
              value: this.getClasses(),
              enumerable: false
            });
          }
          return this.constructor.prototype._classes;
        }
      }
    });
    function CalcCachedProperties() {
      this.defineCalcProperties();
    }
    CalcCachedProperties.prototype.defineCalcProperties = function (isOverwrite) {
      var cPropFn, cPropName, ref;
      Object.defineProperty(this, cacheKey, {
        value: {},
        enumerable: false,
        configurable: false,
        writeable: false
      });
      ref = this.allCalcProperties;
      for (cPropName in ref) {
        cPropFn = ref[cPropName];
        this[cacheKey][cPropName] = cUndefined;
        if (!this.constructor.prototype.hasOwnProperty(cPropName) || isOverwrite) {
          (function (_this) {
            return function (cPropName, cPropFn) {
              if (l.deb(99)) {
                l.deb("...defining calculated property " + _this.constructor.name + "." + cPropName);
              }
              return Object.defineProperty(_this.constructor.prototype, cPropName, {
                enumerable: true,
                configurable: true,
                get: function () {
                  if (l.deb(99)) {
                    l.deb("...requesting calculated property " + this.constructor.name + "." + cPropName);
                  }
                  if (this[cacheKey][cPropName] === cUndefined) {
                    if (l.deb(95)) {
                      l.deb("...refreshing calculated property " + this.constructor.name + "." + cPropName);
                    }
                    this[cacheKey][cPropName] = cPropFn.call(this);
                  }
                  return this[cacheKey][cPropName];
                },
                set: function (v) {
                  return this[cacheKey][cPropName] = v;
                }
              });
            };
          }(this)(cPropName, cPropFn));
        }
      }
      return null;
    };
    CalcCachedProperties.prototype.cleanProps = function () {
      var ca, cleanArgs, cleaned, i, j, len, len1, p, propKeys;
      cleanArgs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (_.isEmpty(cleanArgs)) {
        cleanArgs = _.keys(this.allCalcProperties);
      }
      cleaned = [];
      for (i = 0, len = cleanArgs.length; i < len; i++) {
        ca = cleanArgs[i];
        if (ca) {
          if (_.isFunction(ca)) {
            if (!propKeys) {
              propKeys = _.keys(this.allCalcProperties);
            }
            for (j = 0, len1 = propKeys.length; j < len1; j++) {
              p = propKeys[j];
              if (ca(p)) {
                if (this[cacheKey][p] !== cUndefined) {
                  if (l.deb(100)) {
                    l.deb("...delete (via fn) value of property " + this.constructor.name + "." + p);
                  }
                  this[cacheKey][p] = cUndefined;
                  cleaned.push(p);
                }
              }
            }
          } else {
            if (this[cacheKey][ca] !== cUndefined) {
              if (l.deb(100)) {
                l.deb("...delete value of property " + this.constructor.name + "." + ca);
              }
              this[cacheKey][ca] = cUndefined;
              cleaned.push(ca);
            }
          }
        }
      }
      return cleaned;
    };
    return CalcCachedProperties;
  }(CoffeeUtils);


});
define('uberscore',['require', 'exports', 'module', './blending/blenders/index', './blending/Blender', './blending/traverse', './blending/clone', './objects/okv', './objects/mutate', './objects/setp', './objects/getp', './objects/isDisjoint', './objects/isRefDisjoint', './objects/getRefs', './objects/getInheritedPropertyNames', './objects/isEqual', './objects/isIqual', './objects/isExact', './objects/isIxact', './objects/isLike', './types/isTrue', './types/isFalse', './collections/array/isEqualArraySet', './collections/array/arrayize', './agreement/isAgree', './agreement/inAgreements', './types/type', './types/isPlain', './types/isHash', './Logger', './certain', './utils/CoffeeUtils', './utils/CalcCachedProperties', './utils/subclass'], function (require, exports, module) {
  var __umodule__ = (function (require, exports, module) {
  

var VERSION = '0.0.18'; // injected by urequire-rc-inject-version

var Uberscore;
  Uberscore = function () {
    var key, ref, ref1, val;
    function Uberscore() {
    }
    Uberscore.prototype.VERSION = typeof VERSION === "undefined" || VERSION === null ? "{NO_VERSION}" : VERSION;
    Uberscore.prototype["_"] = _;
    Uberscore.prototype.isLodash = function (lodash) {
      if (lodash == null) {
        lodash = _;
      }
      return _.name === "lodash" || _.isFunction(lodash.isPlainObject) && _.isFunction(lodash.merge) && _.isFunction(lodash.omit);
    };
    ref = {
      Blender: require("./blending/Blender"),
      traverse: require("./blending/traverse"),
      clone: require("./blending/clone"),
      okv: require("./objects/okv"),
      mutate: require("./objects/mutate"),
      setp: require("./objects/setp"),
      getp: require("./objects/getp"),
      isDisjoint: require("./objects/isDisjoint"),
      isRefDisjoint: require("./objects/isRefDisjoint"),
      getRefs: require("./objects/getRefs"),
      getInheritedPropertyNames: require("./objects/getInheritedPropertyNames"),
      isEqual: require("./objects/isEqual"),
      isIqual: require("./objects/isIqual"),
      isExact: require("./objects/isExact"),
      isIxact: require("./objects/isIxact"),
      isLike: require("./objects/isLike"),
      isTrue: require("./types/isTrue"),
      isFalse: require("./types/isFalse"),
      isOk: function (val) {
        return !!val;
      },
      isEqualArraySet: require("./collections/array/isEqualArraySet"),
      arrayize: require("./collections/array/arrayize"),
      isAgree: require("./agreement/isAgree"),
      inAgreements: require("./agreement/inAgreements"),
      type: require("./types/type"),
      isPlain: require("./types/isPlain"),
      isHash: require("./types/isHash"),
      Logger: require("./Logger"),
      certain: require("./certain"),
      CoffeeUtils: require("./utils/CoffeeUtils"),
      CalcCachedProperties: require("./utils/CalcCachedProperties"),
      subclass: require("./utils/subclass")
    };
    for (key in ref) {
      val = ref[key];
      Uberscore.prototype[key] = val;
    }
    ref1 = require("./blending/blenders/index");
    for (key in ref1) {
      val = ref1[key];
      Uberscore.prototype[key] = val;
    }
    return Uberscore;
  }();
  return new Uberscore();


}).call(this, require, exports, module);
var __old___b0 = window['_B'];
if (!__isAMD && !__isNode) {window['_B'] = __umodule__;

__umodule__.noConflict = function () {
  window['_B'] = __old___b0;
return __umodule__;
};
}return __umodule__;
});
    return require('uberscore');

};
if (__isAMD) {
  return define('uberscore', ['lodash'], bundleFactory);
} else {
    if (__isNode) {
        return module.exports = bundleFactory(require('lodash'));
    } else {
        return bundleFactory((typeof _ !== 'undefined') ? _ : __throwMissing('lodash', '_'));
    }
}
}).call(this, (typeof exports === 'object' || typeof window === 'undefined' ? global : window),
              (typeof exports === 'object' || typeof window === 'undefined' ? global : window))